@page "/Eclipse/Tournament"
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Views
@using ScoreTracker.Web.Components
@using MediatR
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Events
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Web.Shared
@using System.Text.RegularExpressions

<PageTitle>Eclipse 2023 Brackets</PageTitle>
@if (IsLoggedInAsAdmin)
{
    <MudGrid>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddRandomDialog">Add Randomizer Settings</MudButton>
        </MudItem>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddMatchDialog">Add Match</MudButton>
        </MudItem>
    </MudGrid>
    

    <MudDialog @bind-IsVisible="_showAddRandomDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_currentRandomName" Label="Settings Name"></MudTextField>
                </MudItem>
            </MudGrid>
            <RandomizerSettingsConfiguration Settings="_currentSettings"></RandomizerSettingsConfiguration>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="SaveRandomSettings">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddRandomDialog = false">@L["Close"]</MudButton>
        </DialogActions>

    </MudDialog>

    <MudDialog @bind-IsVisible="_showAddMatchDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_playerCount" Label="Player Count"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_matchName" Label="Match Name"></MudTextField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_chartCount" Label="Chart Count"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudSelect T="string" @bind-Value="_phaseName" Label="Phase">
                        <MudSelectItem T="string" Value=@("Mids")>Mids</MudSelectItem>
                        <MudSelectItem T="string" Value=@("Uppers")>Uppers</MudSelectItem>
                        <MudSelectItem T="string" Value=@("Pros")>Pros</MudSelectItem>
                    </MudSelect>
                </MudItem>
                <MudItem xs="12">
                    <MudSelect @bind-Value="_randomSettings" Label="Random Settings">
                        @foreach (var key in _chartPullSettings.Keys.OrderBy(k=>k))
                        {
                            <MudSelectItem Value="@key">@key</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateMatch">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddMatchDialog = false">@L["Close"]</MudButton>
        </DialogActions>
    </MudDialog>

}
<br/>
<br/>
<MudGrid>
    <MudItem xs="12">
        <MudAutocomplete T="string"
                         Value="@_searchedPlayer"
                         ValueChanged="SearchForPlayer"
                         ResetValueOnEmptyText="true"
                         CoerceText="true"
                         Label=@($"Search For My Next Match")
                         AdornmentIcon="@Icons.Material.Filled.Search"
                         SearchFunc="@(s => Task.FromResult(Players.Keys.Where(o=>!string.IsNullOrWhiteSpace(s)&&o.Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

        </MudAutocomplete>
        </MudItem>
    @if (_nextMatch != null)
    {
        <MudItem xs="12"><MudText>Your next Match is @_nextMatch.MatchName</MudText></MudItem>
        <MudItem xs="12"><MudText>There are @_matchesLeft Matches until Then</MudText></MudItem>
        <MudItem xs="12"><MudText>This is expected to be @_expectedTime.ToString("dddd h:mm") (this is a very rough estimate)</MudText></MudItem>
    }
</MudGrid>
<br />
<br />
@foreach (var parameters in MatchSections())
{
    @if (parameters.matches.Any())
    {
        <MudTable T="MatchView" Items="parameters.matches">
            <ToolBarContent>
                <MudText Typo="Typo.h6">@parameters.header</MudText>
            </ToolBarContent>
            <HeaderContent>
                <MudTh>Match Name</MudTh>
                <MudTh>Status</MudTh>
                <MudTh>Phase</MudTh>
                <MudTh>Players</MudTh>
                @if (parameters.showWinner)
                {
                    <MudTh>Winner</MudTh>
                }
                @if (IsBracketAdmin)
                {
                    <MudTh>Player Notes</MudTh>
                }
                <MudTh>View</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>@context.MatchName</MudTd>
                <MudTd>@context.State</MudTd>
                <MudTh>@context.PhaseName</MudTh>
                <MudTh>
                    @if (IsBracketAdmin && context.Players.Any(p => Players.ContainsKey(p) && Players[p].PotentialConflict))
                    {
                        <MudTooltip Text=@($"Potential Conflicts: {string.Join(", ",context.Players.Where(p=>Players.ContainsKey(p)&&Players[p].PotentialConflict))}")>
                            <MudIcon Color="Color.Warning" Icon="@Icons.Material.Filled.Warning"></MudIcon>
                        </MudTooltip>
                    }
                    @(string.Join(", ", context.Players.Select(p => p.ToString().StartsWith("Unknown ") ? "TBD" : p.ToString())))
                </MudTh>
                
                @if (parameters.showWinner)
                {
                    <MudTh>@context.FinalPlaces[0]</MudTh>
                }
                @if (IsBracketAdmin)
                {
                    <MudTh>
                        @if (context.Players.Any(p => Players.ContainsKey(p) && !string.IsNullOrWhiteSpace(Players[p].Notes)))
                        {
                            <MudIconButton Icon="@Icons.Material.Filled.Notes" OnClick="()=>ShowNotes(context)"></MudIconButton>
                        }
                    </MudTh>
                }
                <MudTd><MudButton OnClick="() => ViewMatch(context.MatchName)" StartIcon="@Icons.Material.Filled.ViewDay" Color="Color.Primary" Variant="Variant.Outlined">View</MudButton></MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager />
            </PagerContent>
        </MudTable>
        <br/>
        <br/>
    }
}
@if (IsLoggedInAsAdmin)
{
    <MudButton OnClick="FindInvalidMatches" Color="Color.Primary" Variant="Variant.Filled">Check Matches</MudButton>
    @if (_linksChecked && !_tooManyLinks.Any() && !_notEnoughLinks.Any())
    {
        <MudText>You did it!</MudText>
    }
    
    @if (_tooManyLinks.Any())
    {
        <MudText>Too many: 
            @foreach (var match in _tooManyLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }

        </MudText>
    }
    @if (_notEnoughLinks.Any())
    {
        <MudText>
            Not enough:
            @foreach (var match in _notEnoughLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }
        </MudText>
    }

    <MudTable T="MatchLink" Items="_matchLinks">
        <ToolBarContent>
            <MudText Typo="Typo.h6">Links</MudText>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="()=>_showMatchLinkDialog=true">Create</MudButton>
        </ToolBarContent>
        <HeaderContent>
            <MudTh>From Match</MudTh>
            <MudTh>To Match</MudTh>
            <MudTh>Type</MudTh>
            <MudTh>Players</MudTh>
            <MudTh>Delete</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd>@context.FromMatch</MudTd>
            <MudTd>@context.ToMatch</MudTd>
            <MudTd>@(context.IsWinners?"Winners":"Losers")</MudTd>
            <MudTd>@context.PlayerCount</MudTd>
            <MudTd><MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Primary" OnClick="()=>DeleteLink(context)"></MudIconButton></MudTd>
        </RowTemplate>
        
        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
}
<br/>
<MudTable T="ChartStats" Items="_chartStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Chart Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>_charts[e.ChartId].Song.Name.ToString()">Song</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>(int)_charts[e.ChartId].Level">Difficulty</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.MatchCount">Card Draws</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.VetoCount">Vetoes</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.ProtectCount">Protects</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.TotalPlayCount">Total Plays</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>(int)e.AverageScore">Average Score</MudTableSortLabel></MudTh>
        <MudTh>View Leaderboard</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>
            <MudImage Src="@_charts[context.ChartId].Song.ImagePath.ToString()" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown"/>
        </MudTd>
        <MudTd>
            <DifficultyBubble Chart="_charts[context.ChartId]"></DifficultyBubble>
        </MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.VetoCount</MudTd>
        <MudTd>@context.ProtectCount</MudTd>
        <MudTd>@context.TotalPlayCount</MudTd>
        <MudTd>@context.AverageScore (@context.AverageScore.LetterGrade.GetName())</MudTd>
        <MudTd><MudIconButton Icon="@Icons.Material.Filled.ViewList" Color="Color.Primary" OnClick="@(()=>_showingChart=_showingChart==context.ChartId?Guid.Empty:context.ChartId)"></MudIconButton></MudTd>
    </RowTemplate>
    <ChildRowContent>
        <MudTr>
            <td colspan="8">
                @if (_showingChart==context.ChartId)
                {
                    foreach (var kv in _chartLeaderboards[context.ChartId].OrderByDescending(kv=>(int)kv.Value))
                    {
                        <MudText>@kv.Key - @kv.Value (@kv.Value.LetterGrade.GetName())</MudText><br/>
                    }                    
                }
            </td>
        </MudTr>
    </ChildRowContent>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<br/>
<MudTable T="SongStats" Items="_songStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Song Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.SongName.ToString()">Song</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.MatchCount">Card Draws</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.VetoCount">Vetoes</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.ProtectCount">Protects</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.TotalPlayCount">Total Plays</MudTableSortLabel></MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>
            <MudImage Src="@_songImages[context.SongName]" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown" />
        </MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.VetoCount</MudTd>
        <MudTd>@context.ProtectCount</MudTd>
        <MudTd>@context.TotalPlayCount</MudTd>
    </RowTemplate>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<br/>
<MudTable T="PlayerStats" Items="_playerStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Player Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.Player.ToString()">Name</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.MatchCount">Matches</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.ChartsPlayed">Charts</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>(int)e.AverageScore">Average Score</MudTableSortLabel></MudTh>
        <MudTh>View Charts</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>@context.Player</MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.ChartsPlayed</MudTd>
        <MudTd>@context.AverageScore (@context.AverageScore.LetterGrade.GetName())</MudTd>
        <MudTd>
            @if (_playerScores.ContainsKey(context.Player))
            {
                <MudIconButton Icon="@Icons.Material.Filled.ViewList" Color="Color.Primary" OnClick="@(() => _showingPlayer = _showingPlayer == context.Player ? null :(Name?) context.Player)"></MudIconButton>
            }
            
        </MudTd>
    </RowTemplate>
    <ChildRowContent>
        <MudTr>
            <td colspan="5">
                @if (_showingPlayer == context.Player)
                {
                    foreach (var chart in _playerScores[_showingPlayer])
                    {
                        <MudText>@_charts[chart.ChartId].Song.Name @_charts[chart.ChartId].DifficultyString - @chart.Score (@chart.Score.LetterGrade.GetName())</MudText>
                    }
                }
            </td>
        </MudTr>
    </ChildRowContent>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<MudButton OnClick=@(()=>NavManager.NavigateTo("/Eclipse/Qualifiers")) Variant="Variant.Filled">View Qualifiers</MudButton>
<MudDialog @bind-IsVisible="_showMatchDialog">
    <DialogContent>
        @if (_currentMatch != null)
        {
            <MatchOverview MatchName="_currentMatch.Value"></MatchOverview>
        }
    </DialogContent>
    <DialogActions>
        @if (IsBracketAdmin && _currentMatch!=null)
        {
            <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.AddAlert" OnClick="()=>PingMatch(_currentMatch.Value)">Ping Match</MudButton>
        }
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
<MudDialog @bind-IsVisible="_showNotesPopup">
    <DialogContent>
        @if (_notesMatch != null)
        {
            <MudGrid>
                @foreach (var player in _notesMatch.Players.Where(p => Players.ContainsKey(p) && !string.IsNullOrWhiteSpace(Players[p].Notes)))
                {
                    <MudItem xs="12">
                        <MudText>@player - @Players[player].Notes</MudText>
                    </MudItem>
                }
            </MudGrid>
        }
    </DialogContent>
    <DialogActions>
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showNotesPopup = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
<MudDialog @bind-IsVisible="_showMatchLinkDialog">
    <DialogContent>
        <MudGrid>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_fromMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"From Match")
                                 SearchFunc="@(s => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_toMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"To Match")
                                 SearchFunc="@(s => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudCheckBox T="bool" @bind-Checked="_winners" Label="Winners"></MudCheckBox>
            </MudItem>
            <MudItem xs="12">
                <MudNumericField @bind-Value="_linkPlayers" Min="1" Max="100" Label="Players" HideSpinButtons="true"></MudNumericField>
            </MudItem>
        </MudGrid>
    </DialogContent>        <DialogActions>
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateLink">Save</MudButton>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchLinkDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>

@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject ISnackbar Snackbar;
@inject NavigationManager NavManager;
@code
{
    private IDictionary<string, RandomSettings> _chartPullSettings = new Dictionary<string, RandomSettings>(StringComparer.OrdinalIgnoreCase);
    private RandomSettings _currentSettings = new();
    private string _currentRandomName = string.Empty;
    private bool _showAddRandomDialog = false;
    private bool _showAddMatchDialog = false;
    private bool _showMatchDialog = false;
    private bool _showMatchLinkDialog = false;
    private User? _user;
    private int _playerCount = 2;
    private int _chartCount = 3;
    private Guid _showingChart = Guid.Empty;
    private Name? _showingPlayer;
    private MatchView? _nextMatch;
    private MatchView? _notesMatch;
    private bool _showNotesPopup;

    private string _searchedPlayer;

    private string _randomSettings = string.Empty;
    private string _fromMatch = string.Empty;
    private string _toMatch = string.Empty;
    private int _linkPlayers = 1;
    private bool _winners = true;
    private string _matchName = string.Empty;
    private bool IsLoggedInAsAdmin => _user?.IsAdmin ?? false;
    private bool IsBracketAdmin => _user!=null && (_user.IsAdmin || MatchOverview.BracketAdmins.Contains(_user.Id));
    private Name? _currentMatch;
    private IEnumerable<MatchView> ActiveMatches => _matches.Values.Where(m => m.State is > MatchState.NotStarted and < MatchState.Completed)
        .OrderByDescending(m => m.State).ThenBy(m=>m.MatchOrder);

    private string _currentPhase = string.Empty;

    private async Task PingMatch(Name matchName)
    {
        await Mediator.Send(new PingMatchCommand(matchName));
    }

    private IEnumerable<MatchView> UpcomingMatches => _matches.Values.Where(m => m.State is MatchState.NotStarted).OrderBy(m=>m.MatchOrder);
    private IEnumerable<MatchView> CompletedMatches => _matches.Values.Where(m => m.State is MatchState.Completed).OrderBy(m=>m.MatchOrder);
    private IEnumerable<MatchView> ReadyToCardDrawMatches => UpcomingMatches.Where(m => m.PhaseName==_currentPhase && m.State is MatchState.NotStarted && !m.Players.Any(p => p.ToString().StartsWith("Unknown "))).OrderBy(m => m.MatchOrder);
    private IDictionary<string, string> _songImages = new Dictionary<string, string>();
    private IEnumerable<(string header, bool showWinner, IEnumerable<MatchView> matches)> MatchSections()
    {
        yield return ("Active Matches",false,ActiveMatches);
        yield return ("Ready To Card Draw",false,ReadyToCardDrawMatches);
        yield return ("Future Matches",false,UpcomingMatches);
        yield return ("Completed Matches",true,CompletedMatches);
    }
    private IDictionary<string, MatchView> _matches = new Dictionary<string, MatchView>();
    private ICollection<MatchLink> _matchLinks = new List<MatchLink>();
    private readonly ICollection<Name> _tooManyLinks = new List<Name>();
    private readonly ICollection<Name> _notEnoughLinks = new List<Name>();
    private string _phaseName = "Mids";
    private bool _linksChecked = false;
    private TimeSpan _expectedTimeToMatch = TimeSpan.Zero;
    private DateTime _expectedTime = DateTime.Now;
    private int _matchesLeft = 0;
    public void ShowNotes(MatchView match)
    {
        _notesMatch = match;
        _showNotesPopup = true;
    }
    private void SearchForPlayer(string player)
    {
        _searchedPlayer = player;
        if (string.IsNullOrWhiteSpace(player))
        {
            _nextMatch = null;
            return;            
        }
        _nextMatch = UpcomingMatches.FirstOrDefault(m => m.Players.Contains(player));
        if (_nextMatch == null) return;

        _matchesLeft = _nextMatch.MatchOrder-UpcomingMatches.Min(m => m.MatchOrder);
        var playerCount = UpcomingMatches.Where(m => m.MatchOrder < _nextMatch.MatchOrder).Sum(m => m.Players.Length);
        var cabUseCount = playerCount / 2;
        var cabWaveCount = cabUseCount / 4;
        _expectedTimeToMatch = cabWaveCount * TimeSpan.FromMinutes(25);

        var now =  DateTime.Now;

            _expectedTime = now + _expectedTimeToMatch;

    }
    private async Task CreateLink()
    {
        var link = new MatchLink(_fromMatch, _toMatch, _winners, _linkPlayers);
        if (link.FromMatch == link.ToMatch)
        {
            return;
        }
        await Mediator.Send(new CreateMatchLinkCommand(link));
        foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == link.FromMatch && ml.ToMatch == link.ToMatch))
        {
            _matchLinks.Remove(existingLink);
        }
        _matchLinks.Add(link);
        _showMatchLinkDialog = false;
    }

    private async Task DeleteLink(MatchLink link)
    {
        await Mediator.Send(new DeleteMatchLinkCommand(link.FromMatch, link.ToMatch));
        _matchLinks.Remove(link);
    }
    private void FindInvalidMatches()
    {

        _tooManyLinks.Clear();
        _notEnoughLinks.Clear();
        var linkDict = _matchLinks
            .Where(l=>_matches[l.FromMatch].State is not MatchState.Completed)
            .GroupBy(l => l.ToMatch.ToString()).ToDictionary(g => g.Key, g => g.ToArray());

        foreach (var match in _matches.Values)
        {
            var progressingCount = linkDict.TryGetValue(match.MatchName, out var value)?value.Sum(l => l.PlayerCount):0;
            var existingCount = match.Players.Count(p => !p.ToString().StartsWith("Unknown "));
            if (progressingCount + existingCount < match.Players.Length)
            {
                _notEnoughLinks.Add(match.MatchName);
            }
            if (progressingCount + existingCount > match.Players.Length)
            {
                _tooManyLinks.Add(match.MatchName);
            }
        }
        _linksChecked = true;
    }
    public void OpenAddRandomDialog()
    {
        _currentSettings = new();
        _showAddRandomDialog = true;
        _currentRandomName = string.Empty;
    }
    public void OpenAddMatchDialog()
    {
        _matchName = string.Empty;
        _showAddMatchDialog = true;
    }

    private void ViewMatch(Name matchName)
    {
        _currentMatch = matchName;
        _showMatchDialog = true;
    }

    private IDictionary<string, MatchPlayer> Players = new Dictionary<string, MatchPlayer>();

    private async Task CreateMatch()
    {
        var players = Enumerable.Range(0, _playerCount).Select(c => Name.From($"Unknown {c}")).ToArray();
        await Mediator.Send(new UpdateMatchCommand(new MatchView(_matchName,
            _phaseName,
            _matches.Any()?_matches.TryGetValue(_matchName, out var existingMatch)?existingMatch.MatchOrder:_matches.Max(m=>m.Value.MatchOrder)+1:0,
            _chartCount,
            _randomSettings, MatchState.NotStarted,
            players, Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
            players
            )));
        _showAddMatchDialog = false;
    }

    private void MatchUpdated(MatchUpdatedEvent e)
    {
        _matches[e.NewState.MatchName] = e.NewState;
        UpdateCurrentPhase();
        RecalculateStates();
        InvokeAsync(StateHasChanged);
    }

    private void UpdateCurrentPhase()
    {
        var remainingPhases = _matches.Values.Where(m => m.State is not MatchState.Completed)
            .Select(m => m.PhaseName.ToString()).Distinct().ToHashSet(StringComparer.OrdinalIgnoreCase);
        _currentPhase = "Pros";
        if (remainingPhases.Contains("Uppers"))
        {
            _currentPhase = "Uppers";
        }
        if (remainingPhases.Contains("Mids"))
        {
            _currentPhase = "Mids";
        }
    }

    public async Task SaveRandomSettings()
    {
        if (!Name.TryParse(_currentRandomName, out var name))
        {
            return;
        }
        try
        {
            await Mediator.Send(new GetRandomChartsQuery(_currentSettings));
        }
        catch (Exception e)
        {
            Snackbar.Add(e.Message, Severity.Error);
            return;
        }
        await Mediator.Send(new SaveRandomSettingsCommand(name, _currentSettings));
        _chartPullSettings[name] = _currentSettings;
        _showAddRandomDialog = false;
    }
    protected override async Task OnInitializedAsync()
    {
        _user = CurrentUser.IsLoggedIn ? CurrentUser.User : null;
        _matches = (await Mediator.Send(new GetAllMatchesQuery())).ToDictionary(m => m.MatchName.ToString());
        _chartPullSettings = (await Mediator.Send(new GetAllRandomSettingsQuery())).ToDictionary(s => (string) s.name, s => s.settings);
        _matchLinks = (await Mediator.Send(new GetMatchLinksQuery())).ToList();
        Players = (await Mediator.Send(new GetMatchPlayersQuery())).ToDictionary(m => m.Name.ToString(),StringComparer.OrdinalIgnoreCase);
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).ToDictionary(c => c.Id);
        _songImages = _charts.Values.GroupBy(c => c.Song.Name.ToString()).ToDictionary(g => g.Key, g => g.Select(c => c.Song.ImagePath.ToString()).First(),StringComparer.OrdinalIgnoreCase);
        UpdateCurrentPhase();
        RecalculateStates();
        MainLayout.MatchUpdated += (o, e) => MatchUpdated(e);

    }

    private IEnumerable<ChartStats> _chartStats = Array.Empty<ChartStats>();
    private IEnumerable<PlayerStats> _playerStats = Array.Empty<PlayerStats>();
    private IEnumerable<SongStats> _songStats = Array.Empty<SongStats>();
    private IDictionary<string, ICollection<PlayerChartScore>> _playerScores = new Dictionary<string, ICollection<PlayerChartScore>>();
    private IDictionary<Guid, IDictionary<string, PhoenixScore>> _chartLeaderboards = new Dictionary<Guid, IDictionary<string, PhoenixScore>>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private sealed record ChartStats(Guid ChartId, int MatchCount, int VetoCount, int ProtectCount, int TotalPlayCount, PhoenixScore AverageScore)
    {

    }

    private sealed record SongStats(Name SongName, int MatchCount, int VetoCount, int ProtectCount, int TotalPlayCount)
    {

    }
    private sealed record PlayerStats(Name Player, int MatchCount, int ChartsPlayed, PhoenixScore AverageScore)
    {

    }

    private sealed record PlayerChartScore(Guid ChartId, PhoenixScore Score)
    {

    }
    private void RecalculateStates()
    {
        var chartCounts = new Dictionary<Guid, int>();
        var chartVetoCounts = new Dictionary<Guid, int>();
        var chartProtectCounts = new Dictionary<Guid, int>();
        var chartPlayerCounts = new Dictionary<Guid, int>();
        var chartScoreTotal = new Dictionary<Guid, long>();
        var playerMatches = new Dictionary<string, int>();
        var playerChartCount = new Dictionary<string, int>();
        var playerScoreTotal = new Dictionary<string, long>();
        var playerScores = new Dictionary<string, ICollection<PlayerChartScore>>(StringComparer.OrdinalIgnoreCase);
        var chartLeaderboards = new Dictionary<Guid, IDictionary<string, PhoenixScore>>();

        foreach (var match in CompletedMatches)
        {
            foreach (var chartId in match.ActiveCharts.Concat(match.ProtectedCharts).Concat(match.VetoedCharts).Distinct())
            {
                    
                chartCounts.TryAdd(chartId, 0);
                chartPlayerCounts.TryAdd(chartId, 0);
                chartScoreTotal.TryAdd(chartId, 0);
                chartVetoCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartCounts.TryAdd(chartId, 0);
                chartVetoCounts.TryAdd(chartId, 0);
                chartLeaderboards.TryAdd(chartId, new Dictionary<string, PhoenixScore>(StringComparer.OrdinalIgnoreCase));
            }
            for (var i = 0; i < match.ActiveCharts.Length; i++)
            {
                var chartId = match.ActiveCharts[i];

                chartCounts[chartId]++;
                if (match.Scores.All(s => s.Value[i] <=1)) continue;
                chartPlayerCounts[chartId] += match.Scores.Count(s => s.Value[i]>1);
                chartScoreTotal[chartId] += match.Scores.Sum(kv => kv.Value[i]);
                foreach (var player in match.Players)
                {
                    if (match.Scores[player][i] <=1)
                    {
                        continue;
                    }
                    playerScores.TryAdd(player, new List<PlayerChartScore>());
                    playerScores[player].Add(new PlayerChartScore(chartId, match.Scores[player][i]));
                    if (!chartLeaderboards[chartId].ContainsKey(player) || match.Scores[player][i] > chartLeaderboards[chartId][player])
                    {
                        chartLeaderboards[chartId][player] = match.Scores[player][i];
                    }
                }
            
            }
            foreach (var chartId in match.ProtectedCharts)
            {
                chartProtectCounts[chartId]++;
            }
            foreach (var chartId in match.VetoedCharts)
            {
                chartCounts[chartId]++;
                chartVetoCounts[chartId]++;
            }
            foreach (var player in match.Players)
            {
                
                playerMatches.TryAdd(player, 0);
                playerMatches[player]++;
                playerChartCount.TryAdd(player, 0);
                playerChartCount[player] += match.Scores[player].Count(s => s >1);
                playerScoreTotal.TryAdd(player, 0);
                playerScoreTotal[player] += match.Scores[player].Sum(s => (int)s);
            }
        }
        _playerScores = playerScores;
        _playerStats = playerMatches.Keys.Select(player => new PlayerStats(player, playerMatches[player], playerChartCount[player],playerChartCount[player]>0? PhoenixScore.From((int)(playerScoreTotal[player] / playerChartCount[player])):0)).ToArray();
        _chartLeaderboards = chartLeaderboards;
        _chartStats= chartCounts.Keys.Select(chartId => new ChartStats(chartId, chartCounts[chartId], chartVetoCounts[chartId], chartProtectCounts[chartId], chartPlayerCounts[chartId], chartPlayerCounts[chartId] > 0 ? PhoenixScore.From((int)(chartScoreTotal[chartId] / chartPlayerCounts[chartId])) : 0)).ToArray();
        _songStats = _chartStats.GroupBy(c => _charts[c.ChartId].Song.Name.ToString()).Select(g => new SongStats(g.Key, g.Sum(c => c.MatchCount), g.Sum(c => c.VetoCount), g.Sum(c => c.ProtectCount), g.Sum(c => c.TotalPlayCount)));
    }
}
