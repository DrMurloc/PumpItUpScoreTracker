@page "/ChartSkills"
@page "/PersonalizedTierList"
@using MediatR
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Web.Components
@using ChartType = ScoreTracker.Domain.Enums.ChartType
@using ScoreTracker.Domain.Records

<PageTitle>Personalized Tier List</PageTitle>

<MudGrid>
    <MudItem xs="12">
        <MudText Typo="Typo.h3">@L["Tier Lists"] (Beta)</MudText>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudSelect T="ChartType" Value="_chartType" ValueChanged="SetType" Label="Chart Type">
            <MudSelectItem T="ChartType" Value="ChartType.Single">Singles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.Double">Doubles</MudSelectItem>
        </MudSelect>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudNumericField T="int" Value="_level" ValueChanged="SetLevel" Label="Difficulty" HideSpinButtons="true">
        </MudNumericField>
    </MudItem>
    @if (CurrentUser.IsLoggedInAsAdmin)
    {

        <MudItem xs="4">
            <MudNumericField T="int" Value="_highlightedModifier" ValueChanged="SetHighlighted" Label="HighlightedModifier"></MudNumericField>
        </MudItem>
        @foreach (var modifier in _modifiers)
        {
            <MudItem xs="4">
                <MudNumericField T="double" Value="modifier.Value" ValueChanged="v => SetCategory(modifier.Key, v)" Label="@modifier.Key"></MudNumericField>
            </MudItem>
        }
    }
    <MudItem xs="12" sm="6" md="4">

        <MudRadioGroup T="string" Value="_tierListType" ValueChanged="SetTierListType">
            <MudRadio Value="@("Pass")" Color="Color.Primary">Pass</MudRadio>
            <MudRadio Value="@("Score")" Color="Color.Primary">Score</MudRadio>
            <MudRadio Value="@("Fun")" Color="Color.Primary">Fun</MudRadio>
        </MudRadioGroup>
    </MudItem>
    @if (CurrentUser.IsLoggedIn)
    {
        <MudItem xs="12" sm="6" md="4">
            <MudCheckBox T="bool" @bind-Checked="_showPassed" Label="Show Passed Charts"></MudCheckBox>
        </MudItem>
    }
    @if (!_isLoading)
    {

        @foreach (var group in _finalEntries.Where(e => _showPassed || !_scores.TryGetValue(e.ChartId, out var score) || score == 0).GroupBy(e => e.Category).OrderBy(g => g.Key))
        {
            <MudItem xs="12">
                <MudText Typo="Typo.h6">@group.Key.ToString()</MudText>
                @if (CurrentUser.IsLoggedIn)
                {
                    <MudText Typo="Typo.subtitle1">@_messages[group.Key]</MudText>
                }
            </MudItem>
            foreach (var chart in group.OrderBy(e => e.Order).Select(c => _charts[c.ChartId]))
            {

                <MudItem xs="6" sm="3" md="2">

                    <MudCard Class="@CardClass(chart.Id)" Style="@CardStyle(chart.Id)">
                        <MudCardMedia Height="100" Image="@chart.Song.ImagePath.ToString()"/>
                        @if ((_scores.TryGetValue(chart.Id, out var s) ? s : 0) > 0)
                        {
                            <MudCardContent>
                                <MudText>@_scores[chart.Id] (@_scores[chart.Id].LetterGrade.GetName())</MudText>

                            </MudCardContent>
                        }
                        <MudCardActions>
                            <DifficultyBubble Chart="chart"></DifficultyBubble>
                            <MudSpacer>
                            </MudSpacer>
                        @if (_chartVideos.ContainsKey(chart.Id))
                        {
                            <MudIconButton Icon="@Icons.Custom.Brands.YouTube" OnClick="@(() => ShowVideo(chart))"></MudIconButton>

                        }
                        else
                        {
                            <MudIconButton Icon="@Icons.Material.Filled.Search" Href="@ChartSearch(chart)" Target="_blank"></MudIconButton>
                        }
                        </MudCardActions>

                    </MudCard>
                </MudItem>
            }
        }

        @if (CurrentUser.IsLoggedIn && _orderedSkills.Any())
        {
            
            <MudItem xs="12">
                <MudText Typo="Typo.h5">My Skills</MudText>
            </MudItem>
            @foreach (var skill in _orderedSkills.Where(s => MaxScore[s] > 0))
            {
                <MudItem xs="12">
                    <MudProgressLinear Color="Colors[skill]" Min="MinScore[skill]" Max="MaxScore[skill]" Value="MyScore[skill]">@skill.GetName()</MudProgressLinear>
                </MudItem>
            }
        }
    }
</MudGrid>
@if (!_isLoading)
{
    
    <MudTable T="SongTierListEntry" Items=@(_finalEntries)>
        <HeaderContent>
            <MudTh>
                <MudTableSortLabel T="SongTierListEntry" SortBy="e => _charts[e.ChartId].Song.Name">Song</MudTableSortLabel>
            </MudTh>
            <MudTh>Chart</MudTh>
            <MudTh>
                <MudTableSortLabel T="SongTierListEntry" SortBy="e => e.Order">Final Ranking</MudTableSortLabel>
            </MudTh>
            @foreach (var key in _categoryLists.Keys.OrderBy(k => k))
            {
                <MudTh>
                    <MudTableSortLabel T="SongTierListEntry" SortBy="e => _categoryLists[key].TryGetValue(e.ChartId, out var z) ? z.Order : 0">@key</MudTableSortLabel>
                </MudTh>
            }
        </HeaderContent>
        <RowTemplate>
            <MudTd>
                <MudImage Src="@_charts[context.ChartId].Song.ImagePath.ToString()" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown"/>
            </MudTd>
            <MudTd>
                <DifficultyBubble Chart="_charts[context.ChartId]"></DifficultyBubble>
            </MudTd>
            <MudTd>
                <MudTooltip Text="@context.Order.ToString()">
                    <MudText Style=@($"color:{CategoryColor(context.Category)}")>
                        @context.Category.ToString() (@((@context.Order / 100.0).ToString("0.00")))
                    </MudText>
                </MudTooltip>
            </MudTd>
            @foreach (var list in _categoryLists.OrderBy(k => k.Key))
            {
                <MudTd>
                    @if (list.Value.ContainsKey(context.ChartId))
                    {

                        <MudTooltip Text="@list.Value[context.ChartId].Order.ToString()">
                            <MudText Style=@($"color:{CategoryColor(list.Value[context.ChartId].Category)}")>
                                @list.Value[context.ChartId].Category
                            </MudText>
                        </MudTooltip>
                    }
                </MudTd>
            }
        </RowTemplate>

        <PagerContent>
            <MudTablePager></MudTablePager>
        </PagerContent>
    </MudTable>
}
<MudDialog @bind-IsVisible="_showVideoDialog">
    <DialogContent>
        <iframe class="video"
                id="chartVideoFrame"
                src="@(_currentVideo + "?autoplay=1")"
                allow="autoplay; encrypted-media"
                allowfullscreen></iframe>
    </DialogContent>

    <DialogActions>
        <MudSpacer></MudSpacer>
        <MudTooltip Text=@L["Report Video Tooltip"]>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Report" OnClick="NotifyBadVideo">@L["Report Video"]</MudButton>
        </MudTooltip>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="()=>_showVideoDialog=false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject NavigationManager NavManager;
@inject ITierListRepository TierLists;
@inject IAdminNotificationClient Notifications;
@inject ISnackbar Snackbar;
@code
{
    private IDictionary<Skill, List<Chart>> SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, List<Chart>> HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, int> MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IEnumerable<Skill> _orderedSkills = Array.Empty<Skill>();
    private IDictionary<Skill, double> _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
    private IDictionary<Skill, Color> Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);
    private IEnumerable<Chart> _suggestedPasses = Array.Empty<Chart>();
    private IDictionary<Guid, double> _passScore = new Dictionary<Guid, double>();
    private IDictionary<Guid, PhoenixScore> _scores = new Dictionary<Guid, PhoenixScore>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private ChartType _chartType = ChartType.Single;
    private bool _isLoading = false;
    private int _highlightedModifier = 10;
    private bool _showPassed = true;
    private int _level = 20;
    private string _tierListType = "Pass";

    private string ChartSearch(Chart chart)
    {
        var searchString = "Pump It Up " + chart.Song.Name + " " + chart.DifficultyString;
        return $"https://www.youtube.com/results?search_query={searchString.Replace("%", "Percent ").Replace(" ", "+")}";
    }
    private async Task SetTierListType(string type)
    {
        _tierListType = type;
        if (_tierListType == "Pass")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", .5 },
                { "Skill", 2 },
                { "Popularity", .5 },
                { "Pass Count",2}
            };
        }
        if (_tierListType == "Score")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", .5 },
                { "Scores", 2 },
                { "Skill", 2 },
                { "Popularity", .5 },
                { "Pass Count",.5}
            };
        }
        if (_tierListType == "Fun")
        {

            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", .5 },
                { "Skill", 0 },
                { "Popularity", 2 },
                { "Pass Count",.5}
            };
        }
        await Recalculate();
    }
    private string CategoryColor(TierListCategory category) => category switch
    {
        TierListCategory.Overrated=>"#00FFFF",
        TierListCategory.VeryEasy=>"#00FFBB",
        TierListCategory.Easy=>"#00FF55",
        TierListCategory.Medium=>"#00FF00",
        TierListCategory.Hard=>"#55BB00",
        TierListCategory.VeryHard=>"#BB5500",
        TierListCategory.Underrated=>"#FF0000",
        TierListCategory.Unrecorded=>"#888888"
    };
    private string CardClass(Guid chartId) =>
        _scores.TryGetValue(chartId,out  var score) && score>0? "border-solid border-2" : "border-dashed border-2";

    private string CardStyle(Guid chartId) =>
        _scores.TryGetValue(chartId, out var score) && score > 0 ? $@"border-color:{MudBlazor.Colors.Green.Darken1}" : "";
    private async Task SetHighlighted(int newModifier)
    {
        _highlightedModifier = newModifier;
        await Recalculate();
    }

    private async Task SetCategory(string category, double modifier)
    {
        _modifiers[category] = modifier;
        await Recalculate();
    }
    private async Task NotifyBadVideo()
    {
        await Notifications.NotifyAdmin($"The video for{_currentVideoDescription} was reported by {(CurrentUser.IsLoggedIn ? CurrentUser.User.Name : "Unknown")}", CancellationToken.None);
        Snackbar.Add("Notification was sent", Severity.Success);
    }

    private string _currentVideoDescription = string.Empty;
    private bool _showVideoDialog = false;
    private string _currentVideo = string.Empty;
    private IDictionary<Guid, string> _chartVideos = new Dictionary<Guid, string>();
    private void ShowVideo(Chart chart)
    {
        _showVideoDialog = true;
        _currentVideo = _chartVideos[chart.Id];
        _currentVideoDescription = $"{chart.Song.Name} - {chart.DifficultyString}";
        StateHasChanged();
    }
    private async Task<IEnumerable<SongTierListEntry>> BuildSkillTierList()
    {

        SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        _orderedSkills = Array.Empty<Skill>();
        _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);
        _suggestedPasses = Array.Empty<Chart>();
        _passScore = new Dictionary<Guid, double>();
        _scores = new Dictionary<Guid, PhoenixScore>();


        var skills = (await Mediator.Send(new GetChartSkillsQuery())).Where(c => _charts.ContainsKey(c.ChartId)).ToArray();

        var myScores = (await Mediator.Send(new GetPhoenixRecordsQuery(CurrentUser.User.Id)))
            .Where(s => _charts.ContainsKey(s.ChartId))
            .ToDictionary(g => g.ChartId);

        _scores = _charts.ToDictionary(c => c.Key, c => myScores.TryGetValue(c.Key, out var s) ? s.Score ?? PhoenixScore.Min : PhoenixScore.Min);
        foreach (var skillChart in skills)
        {
            if (!myScores.TryGetValue(skillChart.ChartId, out var score)||score.Score==null)
            {
                foreach (var skill in skillChart.ContainsSkills.Concat(skillChart.HighlightsSkill).Distinct())
                {
                    MissingScores[skill]++;
                }
                continue;
            }
            foreach (var skill in skillChart.ContainsSkills)
            {
                SkillCharts[skill].Add(_charts[skillChart.ChartId]);
                MinScore[skill] += PhoenixLetterGrade.AA.GetMinimumScore();
                MaxScore[skill] += 1000000;
                MyScore[skill] += score.Score!.Value;
            }
            foreach (var skill in skillChart.HighlightsSkill)
            {
                HighlightedCharts[skill].Add(_charts[skillChart.ChartId]);
                MaxScore[skill] += _highlightedModifier * 1000000;
                MinScore[skill] += _highlightedModifier * PhoenixLetterGrade.AA.GetMinimumScore();
                MyScore[skill] += _highlightedModifier * (int)score.Score!.Value;
            }
        }

        _orderedSkills = Enum.GetValues<Skill>().Where(s => MaxScore[s] > 0).OrderBy(s => MyScore[s] / (double)MaxScore[s]).ToArray();

        var average = _orderedSkills.Any()? _orderedSkills.Average(s => MyScore[s] / (double)MaxScore[s]):0;
        var standardDiv = StdDev(_orderedSkills.Select(s => MyScore[s] / (double)MaxScore[s]), true);
        _skillWeights = _orderedSkills.ToDictionary(s => s, s => ((MyScore[s] / (double)MaxScore[s]) - average) / standardDiv);
        foreach (var skill in Enum.GetValues<Skill>().Where(s => !_skillWeights.ContainsKey(s)))
        {
            _skillWeights[skill] = 0;
        }
        _passScore = skills.ToDictionary(sc => sc.ChartId, sc => sc.ContainsSkills.Sum(s => _skillWeights[s]) + sc.HighlightsSkill.Sum(s => _highlightedModifier * _skillWeights[s]) / (sc.ContainsSkills.Count() + (double)_highlightedModifier * sc.HighlightsSkill.Count()));

        _suggestedPasses = _passScore
            .Where(kv => !myScores.ContainsKey(kv.Key) || myScores[kv.Key].IsBroken)
            .OrderByDescending(kv => kv.Value).Select(c => _charts[c.Key]);

        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => MaxScore[s] == 0 ? Color.Error : (MyScore[s] / (double)MaxScore[s]) > average ? Color.Success : Color.Warning);
        var standardDeviationCompare =
            StdDev(_passScore.Select(s => s.Value), true);
        if (!_passScore.Any())
        {
            return Array.Empty<SongTierListEntry>();
        }
        var averageCompare = _passScore.Average(s => s.Value);
        var mediumMinCompare = averageCompare - standardDeviationCompare / 2;
        var easyMinCompare = averageCompare + standardDeviationCompare / 2;
        var veryEasyMinCompare = averageCompare + standardDeviationCompare;
        var oneLevelOverratedCompare = averageCompare + standardDeviationCompare * 1.5;
        var hardMinCompare = averageCompare - standardDeviationCompare;
        var veryHardMinCompare = averageCompare - standardDeviationCompare * 1.5;
        return _passScore.Select(s => new SongTierListEntry("Skill", s.Key, s.Value > oneLevelOverratedCompare ? TierListCategory.Overrated
            : s.Value > veryEasyMinCompare ? TierListCategory.VeryEasy :
                s.Value > easyMinCompare ? TierListCategory.Easy :
                    s.Value > mediumMinCompare ? TierListCategory.Medium :
                        s.Value > hardMinCompare ? TierListCategory.Hard :
                            s.Value > veryHardMinCompare ? TierListCategory.VeryHard :
                                TierListCategory.Underrated, -1 * (int)s.Value * 100)).ToArray();
    }

    private IEnumerable<SongTierListEntry> _finalEntries = Array.Empty<SongTierListEntry>();
    private IDictionary<TierListCategory, string> _messages = Enum.GetValues<TierListCategory>().ToDictionary(c => c, c => "");
    private IDictionary<string, double> _modifiers = new Dictionary<string, double>()
    {
        { "Official Scores", 0 },
        { "Scores", 1 },
        { "Skill", 2 },
        { "Popularity", .5 },
        { "Pass Count",2}
    };

    private IDictionary<string, IDictionary<Guid, SongTierListEntry>> _categoryLists = new Dictionary<string, IDictionary<Guid, SongTierListEntry>>();
    private int GetScore(TierListCategory category) => (int)category - 3;

    private async Task<IEnumerable<SongTierListEntry>> BuildTitleTierList()
    {
        var userWeights = new Dictionary<int, IEnumerable<Guid>>()
        {
            { 4, await TierLists.GetUsersOnLevel(_level - 2, CancellationToken.None) },
            { 3, await TierLists.GetUsersOnLevel(_level - 1, CancellationToken.None) },
            { 2, await TierLists.GetUsersOnLevel(_level, CancellationToken.None) },
            { 1, await TierLists.GetUsersOnLevel(_level + 1, CancellationToken.None) }
        };
        var chartSums = _charts.ToDictionary(c => c.Key, c => 0);
        foreach (var weightValue in userWeights)
        {
            foreach (var userId in weightValue.Value)
            {
                var scores = await Mediator.Send(new GetPhoenixRecordsQuery(userId));
                foreach (var score in scores.Where(s => chartSums.ContainsKey(s.ChartId)))
                {
                    chartSums[score.ChartId] += weightValue.Key;
                }
            }
        }

        var standardDeviationCompare =
            StdDev(chartSums.Select(s => (double)s.Value), true);
        var averageCompare = chartSums.Values.Average();
        var mediumMinCompare = averageCompare - standardDeviationCompare / 2;
        var easyMinCompare = averageCompare + standardDeviationCompare / 2;
        var veryEasyMinCompare = averageCompare + standardDeviationCompare;
        var oneLevelOverratedCompare = averageCompare + standardDeviationCompare * 1.5;
        var hardMinCompare = averageCompare - standardDeviationCompare;
        var veryHardMinCompare = averageCompare - standardDeviationCompare * 1.5;
        var result = new List<SongTierListEntry>();
        foreach (var chartId in chartSums.Keys)
        {
            var score = chartSums[chartId];
            if (score < veryHardMinCompare)
            {
                result.Add(new SongTierListEntry("Title", chartId, TierListCategory.Underrated, score));
            } else if (score < hardMinCompare)
            {
                result.Add(new SongTierListEntry("Title", chartId, TierListCategory.VeryHard, score));
            }
            else if (score < mediumMinCompare)
            {
                result.Add(new SongTierListEntry("Title", chartId, TierListCategory.Hard, score));
            }
            else if (score < easyMinCompare)
            {
                result.Add(new SongTierListEntry("Title", chartId, TierListCategory.Medium, score));
            }
            else if (score < veryEasyMinCompare)
            {
                result.Add(new SongTierListEntry("Title", chartId, TierListCategory.Easy, score));
            }
            else if (score < oneLevelOverratedCompare)
            {
                result.Add(new SongTierListEntry("Title", chartId, TierListCategory.VeryEasy, score));
            }
            else
            {
                result.Add(new SongTierListEntry("Title", chartId, TierListCategory.Overrated, score));
            }
        }
        return result;
    } 
    private async Task Recalculate()
    {
        _isLoading = true;

        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix, _level, _chartType))).ToDictionary(c => c.Id);
        var officialScores = (await Mediator.Send(new GetTierListQuery("Official Scores"))).ToDictionary(s => s.ChartId);
        var scores = (await Mediator.Send(new GetTierListQuery("Scores"))).ToDictionary(s => s.ChartId); 
        var popularity = (await Mediator.Send(new GetTierListQuery("Popularity"))).ToDictionary(s => s.ChartId);
        var result = new List<SongTierListEntry>();
        var baseEntries =
            CurrentUser.IsLoggedIn ?
                (await BuildSkillTierList()).ToDictionary(e => e.ChartId)
                : scores.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
        var title = (await Mediator.Send(new GetTierListQuery("Pass Count"))).ToDictionary(s => s.ChartId);
        _categoryLists = new Dictionary<string, IDictionary<Guid, SongTierListEntry>>()
        {
            { "Skill", baseEntries },
            { "Official Scores", officialScores },
            { "Scores", scores },
            { "Popularity", popularity },
            {"Pass Count",title}
        };

        foreach (var chartId in _charts.Keys)
        {
            var count = 0.0;
            var currentTotal = 0.0;
            foreach (var listItem in new[] { (officialScores, "Official Scores"), (scores, "Scores"), (popularity, "Popularity"), (baseEntries, "Skill"), (title, "Pass Count") })
            {
                if (!listItem.Item1.ContainsKey(chartId)||listItem.Item1[chartId].Category == TierListCategory.Unrecorded)
                {
                    continue;
                }
                count += _modifiers[listItem.Item2];
                currentTotal += _modifiers[listItem.Item2] * (double)GetScore(listItem.Item1[chartId].Category);
            }
            var final = currentTotal / (double)count;
            result.Add(new SongTierListEntry("Final", chartId, final < -2.5 ? TierListCategory.Overrated :
                final<-1.5?TierListCategory.VeryEasy:
                final<-.5?TierListCategory.Easy:
                final<=.5?TierListCategory.Medium:
                final<=1.5?TierListCategory.Hard:
                final<=2.5?TierListCategory.VeryHard:
                TierListCategory.Underrated,(int)(final*100.0)));

        }
        _finalEntries = result;
        _messages = Enum.GetValues<TierListCategory>().ToDictionary(c => c, c => "");
        foreach (var group in _finalEntries.GroupBy(t => t.Category))
        {
            if (!group.Any(e => (_scores.TryGetValue(e.ChartId,out var s)?s:0)>0))
            {
                _messages[group.Key] = "0% Cleared";
                continue;
            }
            var clearRate = group.Count(e => _scores[e.ChartId] > 0) / (double)group.Count();
            var minScore =(PhoenixScore)group.Where(e => _scores[e.ChartId] > 0).Min(e =>(int) _scores[e.ChartId]);
            var avgScore = (PhoenixScore)(int)group.Where(e => _scores[e.ChartId] > 0).Average(e => _scores[e.ChartId]);
            var maxScore = (PhoenixScore) group.Where(e => _scores[e.ChartId]>0).Max(e => (int)_scores[e.ChartId]);
            _messages[group.Key] = $"{clearRate * 100.0:0.00}% Cleared, {minScore} ({minScore.LetterGrade.GetName()}) - {maxScore} ({maxScore.LetterGrade.GetName()}), {avgScore} ({avgScore.LetterGrade.GetName()}) Average";
        }
        _isLoading = false;
    }
    private async Task SetType(ChartType newType)
    {
        _chartType = newType;
        await Recalculate();
    }

    private async Task SetLevel(int level)
    {
        _level = level;
        await Recalculate();
    }
    protected override async Task OnInitializedAsync()
    {
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).
        ToDictionary(c => c.Id);
        _chartVideos = (await Mediator.Send(new GetChartVideosQuery())).ToDictionary(cv => cv.ChartId, cv => cv.VideoUrl.ToString());
        await SetType(ChartType.Single);
    }

    public static double StdDev(IEnumerable<double> values,
        bool as_sample)
    {
        // Get the mean.
        double mean = values.Sum() / values.Count();

        // Get the sum of the squares of the differences
        // between the values and the mean.
        var squares_query =
            from double value in values
            select (value - mean) * (value - mean);
        double sum_of_squares = squares_query.Sum();

        if (as_sample)
        {
            return Math.Sqrt(sum_of_squares / (values.Count() - 1));
        }
        else
        {
            return Math.Sqrt(sum_of_squares / values.Count());
        }
    }
}
