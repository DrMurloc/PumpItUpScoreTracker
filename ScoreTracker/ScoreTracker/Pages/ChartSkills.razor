@page "/ChartSkills"
@using MediatR
@using Microsoft.EntityFrameworkCore
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Queries
@using ScoreTracker.Data.Persistence
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Domain.Services.Contracts
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Web.Services.Contracts
@using ChartType = ScoreTracker.Domain.Enums.ChartType
@using MassTransit
@using ScoreTracker.Domain.Events
@using ScoreTracker.Domain.Records

<PageTitle>Chart Skills</PageTitle>

<MudGrid>
    <MudItem xs="12">
        <MudSelect T="ChartType" Value="_chartType" ValueChanged="SetType" Label="Chart Type">
            <MudSelectItem T="ChartType" Value="ChartType.Single">Singles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.Double">Doubles</MudSelectItem>
        </MudSelect>
    </MudItem>
    <MudItem xs="4">
        <MudNumericField T="int" Value="_highlightedModifier" ValueChanged="SetHighlighted" Label="HighlightedModifier"></MudNumericField>
    </MudItem>
    @foreach (var modifier in _modifiers)
    {
        <MudItem xs="4">
            <MudNumericField T="double" Value="modifier.Value" ValueChanged="v=>SetCategory(modifier.Key,v)" Label="@modifier.Key"></MudNumericField>
        </MudItem>
    }
    <MudItem xs="12">
        <MudText Typo="Typo.h5">Recommended New Passes</MudText>
    </MudItem>
    <MudItem xs="12">
        <MudCheckBox T="bool" @bind-Checked="_showPassed" Label="Show Passed Charts"></MudCheckBox>
    </MudItem>
    @if (!_isLoading)
    {
        
        @foreach (var group in _finalEntries.Where(e=>_showPassed|| !_scores.TryGetValue(e.ChartId,out var score) || score==0).GroupBy(e => e.Category).OrderBy(g => g.Key))
        {
            <MudItem xs="12">
                <MudText Typo="Typo.h6">@group.Key.ToString()</MudText>
            </MudItem>
            foreach (var chart in group.OrderBy(e => e.Order).Select(c=>_charts[c.ChartId]))
            {
            
                <MudItem xs="6" sm="3" md="2">

                    <MudCard Class="@CardClass(chart.Id)" Style="@CardStyle(chart.Id)">
                        <MudCardMedia Height="100" Image="@chart.Song.ImagePath.ToString()"/>
                        <MudCardActions>

                            <MudImage Src="@chart.DifficultyBubblePath" Height="35" Alt="@chart.DifficultyString" ObjectFit="ObjectFit.ScaleDown"></MudImage>
                            <MudSpacer>
                            </MudSpacer>
                            @if (_scores[chart.Id] > 0)
                            {
                                <MudText>@_scores[chart.Id]</MudText>
                            }
                        </MudCardActions>

                    </MudCard>
                </MudItem>
            }
        }

        <MudItem xs="12">
            <MudText Typo="Typo.h5">My Skills</MudText>
        </MudItem>
        @foreach (var skill in _orderedSkills.Where(s => MaxScore[s] > 0))
        {
            <MudItem xs="12">
                <MudProgressLinear Color="Colors[skill]" Min="MinScore[skill]" Max="MaxScore[skill]" Value="MyScore[skill]">@skill.GetName()</MudProgressLinear>
            </MudItem>
        }
        <MudItem xs="12">
            <MudTable T="SongTierListEntry" Items=@(_finalEntries)>
                <HeaderContent>
                    <MudTh>
                        <MudTableSortLabel T="SongTierListEntry" SortBy="e => _charts[e.ChartId].Song.Name">Song</MudTableSortLabel>
                    </MudTh>
                    <MudTh>Chart</MudTh>
                    <MudTh>
                        <MudTableSortLabel T="SongTierListEntry" SortBy="e => e.Order">Final Ranking</MudTableSortLabel>
                    </MudTh>
                    @foreach (var key in _categoryLists.Keys.OrderBy(k=>k))
                    {
                        <MudTh>
                            <MudTableSortLabel T="SongTierListEntry" SortBy="e=>_categoryLists[key][e.ChartId].Order">@key</MudTableSortLabel>
                        </MudTh>
                    }
                </HeaderContent>
                <RowTemplate>
                    <MudTd>
                        <MudImage Src="@_charts[context.ChartId].Song.ImagePath.ToString()" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown"/>
                    </MudTd>
                    <MudTd>
                        <MudImage Src="@_charts[context.ChartId].DifficultyBubblePath.ToString()" Height="35" ObjectFit="ObjectFit.ScaleDown"></MudImage>
                    </MudTd>
                    <MudTd>
                        <MudTooltip Text="@context.Order.ToString()">
                            <MudText Style=@($"color:{CategoryColor(context.Category)}")>
                                @context.Category.ToString() (@((@context.Order/100.0).ToString("0.00")))
                            </MudText>
                        </MudTooltip>
                    </MudTd>
                    @foreach (var list in _categoryLists.OrderBy(k => k.Key))
                    {
                        <MudTd>
                        <MudTooltip Text="@list.Value[context.ChartId].Order.ToString()">
                            <MudText Style=@($"color:{CategoryColor(list.Value[context.ChartId].Category)}")>
                                @list.Value[context.ChartId].Category (@((_modifiers[list.Key]*GetScore(list.Value[context.ChartId].Category)).ToString("0.00")))
                            </MudText>
                        </MudTooltip>
                        </MudTd>
                    }
                </RowTemplate>
                
                <PagerContent>
                    <MudTablePager></MudTablePager>
                </PagerContent>
            </MudTable>
        </MudItem>
    }
</MudGrid>


@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject NavigationManager NavManager;
@code
{
    private IDictionary<Skill, List<Chart>> SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, List<Chart>> HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, int> MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IEnumerable<Skill> _orderedSkills = Array.Empty<Skill>();
    private IDictionary<Skill, double> _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
    private IDictionary<Skill, Color> Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);
    private IEnumerable<Chart> _suggestedPasses = Array.Empty<Chart>();
    private IDictionary<Guid, double> _passScore = new Dictionary<Guid, double>();
    private IDictionary<Guid, PhoenixScore> _scores = new Dictionary<Guid, PhoenixScore>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private ChartType _chartType = ChartType.Single;
    private bool _isLoading = false;
    private int _highlightedModifier = 10;
    private bool _showPassed = true;
    
    private string CategoryColor(TierListCategory category) => category switch
    {
        TierListCategory.Overrated=>"#00FFFF",
        TierListCategory.VeryEasy=>"#00FFBB",
        TierListCategory.Easy=>"#00FF55",
        TierListCategory.Medium=>"#00FF00",
        TierListCategory.Hard=>"#55BB00",
        TierListCategory.VeryHard=>"#BB5500",
        TierListCategory.Underrated=>"#FF0000"
        };
    private string CardClass(Guid chartId) =>
        _scores.TryGetValue(chartId,out  var score) && score>0? "border-solid border-2" : "border-dashed border-2";

    private string CardStyle(Guid chartId) =>
        _scores.TryGetValue(chartId, out var score) && score > 0 ? $@"border-color:{MudBlazor.Colors.Green.Darken1}" : "";
    private async Task SetHighlighted(int newModifier)
    {
        _highlightedModifier = newModifier;
        await Recalculate();
    }

    private async Task SetCategory(string category, double modifier)
    {
        _modifiers[category] = modifier;
        await Recalculate();
    }
    private async Task<IEnumerable<SongTierListEntry>> BuildSkillTierList()
    {

        SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        _orderedSkills = Array.Empty<Skill>();
        _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);
        _suggestedPasses = Array.Empty<Chart>();
        _passScore = new Dictionary<Guid, double>();
        _scores = new Dictionary<Guid, PhoenixScore>();


        var charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix, 20, _chartType))).ToDictionary(c => c.Id);
        var skills = (await Mediator.Send(new GetChartSkillsQuery())).Where(c => charts.ContainsKey(c.ChartId)).ToArray();
        var myScores = (await Mediator.Send(new GetPhoenixRecordsQuery(CurrentUser.User.Id)))
            .Where(s => charts.ContainsKey(s.ChartId))
            .ToDictionary(g => g.ChartId);

        _scores = charts.ToDictionary(c => c.Key, c => myScores.TryGetValue(c.Key, out var s) ? s.Score ?? PhoenixScore.Min : PhoenixScore.Min);
        foreach (var skillChart in skills)
        {
            if (!myScores.TryGetValue(skillChart.ChartId, out var score)||score.Score==null)
            {
                foreach (var skill in skillChart.ContainsSkills.Concat(skillChart.HighlightsSkill).Distinct())
                {
                    MissingScores[skill]++;
                }
                continue;
            }
            foreach (var skill in skillChart.ContainsSkills)
            {
                SkillCharts[skill].Add(charts[skillChart.ChartId]);
                MinScore[skill] += PhoenixLetterGrade.AA.GetMinimumScore();
                MaxScore[skill] += 1000000;
                MyScore[skill] += score.Score!.Value;
            }
            foreach (var skill in skillChart.HighlightsSkill)
            {
                HighlightedCharts[skill].Add(charts[skillChart.ChartId]);
                MaxScore[skill] += _highlightedModifier * 1000000;
                MinScore[skill] += _highlightedModifier * PhoenixLetterGrade.AA.GetMinimumScore();
                MyScore[skill] += _highlightedModifier * (int)score.Score!.Value;
            }
        }

        _orderedSkills = Enum.GetValues<Skill>().Where(s => MaxScore[s] > 0).OrderBy(s => MyScore[s] / (double)MaxScore[s]).ToArray();
        
        var average = _orderedSkills.Any()? _orderedSkills.Average(s => MyScore[s] / (double)MaxScore[s]):0;
        var standardDiv = StdDev(_orderedSkills.Select(s => MyScore[s] / (double)MaxScore[s]), true);
        _skillWeights = _orderedSkills.ToDictionary(s => s, s => ((MyScore[s] / (double)MaxScore[s]) - average) / standardDiv);
        foreach (var skill in Enum.GetValues<Skill>().Where(s => !_skillWeights.ContainsKey(s)))
        {
            _skillWeights[skill] = 0;
        }
        _passScore = skills.ToDictionary(sc => sc.ChartId, sc => sc.ContainsSkills.Sum(s => _skillWeights[s]) + sc.HighlightsSkill.Sum(s => _highlightedModifier * _skillWeights[s]) / (sc.ContainsSkills.Count() + (double)_highlightedModifier * sc.HighlightsSkill.Count()));

        _suggestedPasses = _passScore
            .Where(kv => !myScores.ContainsKey(kv.Key) || myScores[kv.Key].IsBroken)
            .OrderByDescending(kv => kv.Value).Select(c => charts[c.Key]);

        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => MaxScore[s] == 0 ? Color.Error : (MyScore[s] / (double)MaxScore[s]) > average ? Color.Success : Color.Warning);
        var standardDeviationCompare =
            StdDev(_passScore.Select(s => s.Value), true);
        var averageCompare = _passScore.Average(s => s.Value);
        var mediumMinCompare = averageCompare - standardDeviationCompare / 2;
        var easyMinCompare = averageCompare + standardDeviationCompare / 2;
        var veryEasyMinCompare = averageCompare + standardDeviationCompare;
        var oneLevelOverratedCompare = averageCompare + standardDeviationCompare * 1.5;
        var hardMinCompare = averageCompare - standardDeviationCompare;
        var veryHardMinCompare = averageCompare - standardDeviationCompare * 1.5;
        return _passScore.Select(s => new SongTierListEntry("Skill", s.Key, s.Value > oneLevelOverratedCompare ? TierListCategory.Overrated
            : s.Value > veryEasyMinCompare ? TierListCategory.VeryEasy :
                s.Value > easyMinCompare ? TierListCategory.Easy :
                    s.Value > mediumMinCompare ? TierListCategory.Medium :
                        s.Value > hardMinCompare ? TierListCategory.Hard :
                            s.Value > veryHardMinCompare ? TierListCategory.VeryHard :
                                TierListCategory.Underrated, -1 * (int)s.Value * 100)).ToArray();
    }

    private IEnumerable<SongTierListEntry> _finalEntries = Array.Empty<SongTierListEntry>();

    private IDictionary<string, double> _modifiers = new Dictionary<string, double>()
    {
        { "Official Scores", 1 },
        { "Scores", 1 },
        { "Skill", 2 },
        { "Popularity", .5 },
        { "Stage Break", 1 }
    };

    private IDictionary<string, IDictionary<Guid, SongTierListEntry>> _categoryLists = new Dictionary<string, IDictionary<Guid, SongTierListEntry>>();
    private int GetScore(TierListCategory category) => (int)category - 3;
    private async Task Recalculate()
    {
        _isLoading = true;
        var officialScores = (await Mediator.Send(new GetTierListQuery("Official Scores"))).ToDictionary(s => s.ChartId);
        var scores = (await Mediator.Send(new GetTierListQuery("Scores"))).ToDictionary(s => s.ChartId); 
        var popularity = (await Mediator.Send(new GetTierListQuery("Popularity"))).ToDictionary(s => s.ChartId);
        var difficulty = (await Mediator.Send(new GetTierListQuery("Difficulty"))).ToDictionary(s => s.ChartId);
        var result = new List<SongTierListEntry>();
        var baseEntries = (await BuildSkillTierList()).ToArray();
        _categoryLists = new Dictionary<string, IDictionary<Guid, SongTierListEntry>>()
        {
            { "Skill", baseEntries.ToDictionary(e => e.ChartId) },
            { "Official Scores", officialScores },
            { "Scores", scores },
            { "Popularity", popularity },
            { "Stage Break", difficulty }
        };
        foreach (var baseEntry in baseEntries)
        {
            var count = _modifiers["Skill"];
            var currentTotal = _modifiers["Skill"]*(double) GetScore(baseEntry.Category);
            foreach (var listItem in new[] { (officialScores,"Official Scores"), (scores,"Scores"), (popularity,"Popularity"), (difficulty,"Stage Break") })
            {
                if (listItem.Item1[baseEntry.ChartId].Category == TierListCategory.Unrecorded)
                {
                    continue;
                }
                count += _modifiers[listItem.Item2];
                currentTotal += _modifiers[listItem.Item2]*(double)GetScore(listItem.Item1[baseEntry.ChartId].Category);
            }
            var final = currentTotal / (double)count;
            result.Add(new SongTierListEntry("Final",baseEntry.ChartId,final<-2.5?TierListCategory.Overrated:
                final<-1.5?TierListCategory.VeryEasy:
                final<-.5?TierListCategory.Easy:
                final<=.5?TierListCategory.Medium:
                final<=1.5?TierListCategory.Hard:
                final<=2.5?TierListCategory.VeryHard:
                TierListCategory.Underrated,(int)(final*100.0)));

        }
        _finalEntries = result;
        _isLoading = false;
    }
    private async Task SetType(ChartType newType)
    {
        _chartType = newType;
        await Recalculate();
    }
    protected override async Task OnInitializedAsync()
    {

        if (!CurrentUser.IsLoggedIn)
        {
            NavManager.NavigateTo("/Login");
        }
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).
        ToDictionary(c => c.Id);
        await SetType(ChartType.Single);
    }

    public static double StdDev(IEnumerable<double> values,
        bool as_sample)
    {
        // Get the mean.
        double mean = values.Sum() / values.Count();

        // Get the sum of the squares of the differences
        // between the values and the mean.
        var squares_query =
            from double value in values
            select (value - mean) * (value - mean);
        double sum_of_squares = squares_query.Sum();

        if (as_sample)
        {
            return Math.Sqrt(sum_of_squares / (values.Count() - 1));
        }
        else
        {
            return Math.Sqrt(sum_of_squares / values.Count());
        }
    }
}
