@page "/Account"
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Models
@using MediatR
@using ScoreTracker.Application.Commands
@using ScoreTracker.Domain.ValueTypes
@using CsvHelper
@using System.Globalization
@using ScoreTracker.Domain.Exceptions
@using ScoreTracker.Web.Dtos

<PageTitle>Account</PageTitle>

<MudCard>
    <MudCardHeader>Account Settings</MudCardHeader>
    <MudCardContent>
        <MudTextField Label="Id" Disabled="true" Value="@_id" HelperText="Used primarily for debugging"></MudTextField>
        <MudTextField T="string" Label="Username" MaxLength="100" Value="@_name" ValueChanged="UpdateName"></MudTextField>
        <br/>
        <MudFab StartIcon="@Icons.Filled.Upload" Label="Upload Charts" Color="@Color.Primary" Size="@Size.Small" OnClick="@(_=>_isUploadShowing=true)"></MudFab>
        <MudFab StartIcon="@Icons.Filled.Download" Label="Download Charts" Color="@Color.Primary" Size="@Size.Small"></MudFab>
    </MudCardContent>
</MudCard>

<InputFile id="uploadInput" OnChange="@UploadFile" hidden accept=".csv"/>

<MudDialog @bind-IsVisible="_isUploadShowing">
    <TitleContent>
        Upload Charts
    </TitleContent>
    <DialogContent>
        
        @if (!_isUploading)
        {
            
            <p>
                Some players already maintain scores via Spreadsheets.
                <br/><br/>
                In some of those cases, it may be faster to upload a Spreadsheet instead of manually inputting thousands of grades.
            </p>
        }
        else
        {
            <p>
                If you leave this page, the upload will stop but you will not lose any scores that have already been recorded from your upload.
            </p>
            <br/>
            <span>@_currentUpload/@_maxUpload Uploaded. @_remainingTime.ToString(@"m\:ss") Remaining. @_failedCount Failed to record</span>
            <MudProgressLinear Color="Color.Primary" Size="Size.Large" Value="@_currentUpload" Min="1" Max="@_maxUpload"/>
        }
    </DialogContent>
    <DialogActions>
        
        <MudButton HtmlTag="label"
                   Variant="Variant.Filled"
                   Color="Color.Primary"
                   StartIcon="@Icons.Filled.Upload"
                   Disabled="@_isUploading"
                   for="uploadInput">
            Upload Charts
        </MudButton>
        <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="@(() => _isUploadShowing = false)" Class="px-10">Close</MudButton>
    </DialogActions>

</MudDialog>

@inject NavigationManager NavManager
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject ISnackbar Snackbar;
@inject NavigationManager NavigationManager;
@inject IJSRuntime JSRuntime;
@code
{
    private string _id = string.Empty;
    private string _name = string.Empty;
    private bool _isUploadShowing = false;
    private bool _isUploading = false;
    private int _maxUpload = 0;
    private int _currentUpload = 0;
    private int _failedCount = 0;
    private TimeSpan _remainingTime = TimeSpan.MinValue;
    protected override Task OnInitializedAsync()
    {
        if (!CurrentUser.IsLoggedIn)
        {
            NavManager.NavigateTo("/Login");
            return Task.CompletedTask;
        }
        _id = CurrentUser.User.Id.ToString();
        _name = CurrentUser.User.Name;
        return Task.CompletedTask;
    }

    private async Task UploadFile(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file.Size > 500000)
        {
            Snackbar.Add("File cannot be larger than .5 MB", Severity.Error);
            return;
        }
        await using var readStream = file.OpenReadStream(500000);
        using var reader = new StreamReader(readStream);
        using var csv = new CsvReader(reader,CultureInfo.InvariantCulture);
        var result = new List<BestChartAttempt>();
        var failedResults = new List<SpreadsheetScoreErrorDto>();
        await csv.ReadAsync();
        csv.ReadHeader();

        if (!csv.TryGetField<string>(nameof(SpreadsheetScoreDto.Song), out var _))
        {
            Snackbar.Add("Spreadsheet is missing Song column",Severity.Error);
            return;
        }
        if (!csv.TryGetField<string>(nameof(SpreadsheetScoreDto.Difficulty), out _))
        {
            Snackbar.Add("Spreadsheet is missing Difficulty column",Severity.Error);
            return;
        }
        if (!csv.TryGetField<string>(nameof(SpreadsheetScoreDto.LetterGrade), out _name))
        {
            Snackbar.Add("Spreadsheet is missing LetterGrade column", Severity.Error);
            return;
        }

        await foreach (var record in csv.GetRecordsAsync<SpreadsheetScoreDto>())
        {
            try
            {
                result.Add(record.ToBestAttempt());
            }
            catch (Exception ex)
            {
                failedResults.Add(record.ToError("Could not parse row"));
            }
        }
        _isUploading = true;
        _maxUpload = result.Count;
        _currentUpload = 0;
        _failedCount = failedResults.Count;
        var startTime = DateTimeOffset.Now;
        foreach (var best in result)
        {
            
            StateHasChanged();
            _currentUpload++;
            _remainingTime = (DateTimeOffset.Now - startTime) * (((double)_maxUpload - (double)_currentUpload) / (double)_currentUpload);
            try
            {
                await Mediator.Send(new UpdateBestAttemptCommand(best.Chart.Song.Name, best.Chart.Type, best.Chart.Level, best.BestAttempt?.LetterGrade, best.BestAttempt?.IsBroken ?? true));
            }
            catch (ChartNotFoundException)
            {
                failedResults.Add(new SpreadsheetScoreErrorDto
                {
                    Difficulty = best.Chart.DifficultyString,
                    LetterGrade = best.BestAttempt?.LetterGrade.ToString() ?? "",
                    Song = best.Chart.Song.Name,
                    Error = "Could not find chart"
                });
                _failedCount = failedResults.Count;
            }
            catch (Exception)
            {
                
                failedResults.Add(new SpreadsheetScoreErrorDto
                {
                    Difficulty = best.Chart.DifficultyString,
                    LetterGrade = best.BestAttempt?.LetterGrade.ToString() ?? "",
                    Song = best.Chart.Song.Name,
                    Error = "An unknown error occured"
                });
                _failedCount = failedResults.Count;
            }
        }
    }
    private async Task UpdateName(string newName)
    {
        _name = newName;
        if (Name.TryParse(newName, out var name))
        {
            await Mediator.Send(new UpdateUserCommand(name));
            /*
              Why does it always come back to javascript...
              Blazor interacts over WebSockets that close HTTP responses before it processes.
              This means we can't update a user's signed in information (stored in a cookie) utilizing standard Blazor back end interactions
              HttpClient interactions all happen via sockets in the back end, so does not contain cookie information for managing user claims.
              So the conclusion was to do a quick javascript fetch to a Refresh endpoint to log out and log back in a user when their claims
              are updated.
              See https://github.com/dotnet/aspnetcore/issues/34095#issuecomment-874012924 for Microsoft's stance on this.
              See: >:(  for my stance on this.
            */
            var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/helpers.js");
            await module.InvokeVoidAsync("refreshLogin");
            Snackbar.Add($"Username set to {name}");
            _name = name;
        }
    }
}
