@page "/Account"
@using ScoreTracker.Domain.SecondaryPorts
@using MediatR
@using ScoreTracker.Application.Commands
@using ScoreTracker.Domain.ValueTypes

<PageTitle>Account</PageTitle>

<MudCard>
    <MudCardHeader>Account Settings</MudCardHeader>
    <MudCardContent>
        <MudTextField Label="Id" Disabled="true" Value="@_id" HelperText="Used primarily for debugging"></MudTextField>
        <MudTextField T="string" Label="Username" MaxLength="100" Value="@_name" ValueChanged="UpdateName"></MudTextField>
        <MudSwitch T="bool" Label="Public" Checked="_isPublic" CheckedChanged="UpdateIsPublic" Color="Color.Success"></MudSwitch>
    </MudCardContent>
    <MudCardActions>
        <MudSpacer></MudSpacer>
        <MudButton Href="/UploadScores" Icon="@Icons.Filled.UploadFile" Variant="Variant.Filled" Color="Color.Primary">Upload Scores</MudButton>
        <MudButton Href="/Logout" Icon="@Icons.Filled.Logout" Variant="Variant.Filled" Color="Color.Primary">Logout</MudButton>
    </MudCardActions>
</MudCard>

@inject NavigationManager NavManager
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject ISnackbar Snackbar;
@inject NavigationManager NavigationManager;
@inject IJSRuntime JSRuntime;
@code
{
    private string _id = string.Empty;
    private string _name = string.Empty;
    private bool _isPublic = false;
    protected override Task OnInitializedAsync()
    {
        if (!CurrentUser.IsLoggedIn)
        {
            NavManager.NavigateTo("/Login");
            return Task.CompletedTask;
        }
        _id = CurrentUser.User.Id.ToString();
        _name = CurrentUser.User.Name;
        _isPublic = CurrentUser.User.IsPublic;
        return Task.CompletedTask;
    }

    private async Task UpdateUser()
    {
        
        await Mediator.Send(new UpdateUserCommand(_name,_isPublic));
       /*
          Why does it always come back to javascript...
          Blazor interacts over WebSockets that close HTTP responses before it processes.
          This means we can't update a user's signed in information (stored in a cookie) utilizing standard Blazor back end interactions
          HttpClient interactions all happen via sockets in the back end, so does not contain cookie information for managing user claims.
          So the conclusion was to do a quick javascript fetch to a Refresh endpoint to log out and log back in a user when their claims
          are updated.
          See https://github.com/dotnet/aspnetcore/issues/34095#issuecomment-874012924 for Microsoft's stance on this.
          See: >:(  for my stance on this.*/
        var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/helpers.js");
        await module.InvokeVoidAsync("refreshLogin");
    }

    private async Task UpdateIsPublic(bool newIsPublic)
    {
        _isPublic = newIsPublic;
        await UpdateUser();
        var message = newIsPublic ? "Public" : "Private";
        Snackbar.Add($"User made {message}", Severity.Success);
    }
    private async Task UpdateName(string newName)
    {
        if (Name.TryParse(newName, out var name) || name.ToString().Length>100)
        {
            _name = name;
            await UpdateUser();
            Snackbar.Add($"User Profile Up set to {_name}",Severity.Success);
        }
        else
        {
            Snackbar.Add("Invalid Name",Severity.Error);
        }
    }
}
