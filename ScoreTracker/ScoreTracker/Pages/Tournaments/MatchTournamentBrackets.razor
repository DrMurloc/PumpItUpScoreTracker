@page "/Tournament/{TournamentId:guid}/Brackets"
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Views
@using ScoreTracker.Web.Components
@using MediatR
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Events
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Web.Shared
@using System.Text.RegularExpressions
@using ScoreTracker.Domain.Records
@using Syncfusion.Blazor.Buttons
@using Syncfusion.Blazor.Diagram
@using Syncfusion.Blazor.Diagram.Overview
@using SelectionChangedEventArgs = Syncfusion.Blazor.Diagram.SelectionChangedEventArgs
@using Syncfusion.Blazor.Kanban

<PageTitle>@TournamentName Brackets</PageTitle>

<br/>
<MudGrid>
    <MudItem xs="6">
        <MudTooltip Text="Automatically pulls up matches as they change">
            <MudCheckBox T="bool" @bind-Value="_spectatorMode" Label="Spectator Mode"></MudCheckBox>
        </MudTooltip>
    </MudItem>
    @if (_myRole ==TournamentRole.HeadTournamentOrganizer)
    {
        <MudItem xs="6">
            <MudCheckBox T="bool" @bind-Value="_showAdminTools" Label="Show Admin Tools"></MudCheckBox>
        </MudItem>        
    }
</MudGrid>
<br />
<br />

@if (_myRole == TournamentRole.HeadTournamentOrganizer && _showAdminTools)
{
    <MudGrid>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddRandomDialog">Add Randomizer Settings</MudButton>
        </MudItem>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddMatchDialog">Add Match</MudButton>
        </MudItem>
        <MudItem xs="12" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenBulkAddMatchDialog">Bulk Create Matches</MudButton>
        </MudItem>
    </MudGrid>


    <MudDialog @bind-Visible="_showAddRandomDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_currentRandomName" Label="Settings Name"></MudTextField>
                </MudItem>
            </MudGrid>
            <RandomizerSettingsConfiguration Settings="_currentSettings"></RandomizerSettingsConfiguration>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="SaveRandomSettings">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddRandomDialog = false">@L["Close"]</MudButton>
        </DialogActions>

    </MudDialog>

    <MudDialog @bind-Visible="_showAddMatchDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudNumericField T="int" Value="_playerCount" ValueChanged="SetPlayerCount" Label="Player Count"></MudNumericField>
                </MudItem>
                @if (_playerCount > 2)
                {
                    <MudItem xs="12">
                        <MudTextField T="string" Label="Points by place (1st place 1st)" @bind-Value="_pointsByPlace"></MudTextField>
                    </MudItem>
                }
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_matchName" Label="Match Name"></MudTextField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_chartCount" Label="Chart Count"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_round" Label="Round (Horizontal Order Within Phase for display purposes)"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudAutocomplete T="string" @bind-Value="_phaseName" Label="Phase" CoerceText="false" CoerceValue="true" SearchFunc="(s,c)=>Task.FromResult(_matches.Select(m=>m.Value.PhaseName).Distinct().Where(n=>n.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).Select(s=>s.ToString()))"></MudAutocomplete>

                </MudItem>
                <MudItem xs="12">
                    <MudSelect @bind-Value="_randomSettings" Label="Random Settings" Required="true">
                        @foreach (var key in _chartPullSettings.Keys.OrderBy(k => k))
                        {
                            <MudSelectItem Value="@key">@key</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateMatch" Disabled="!IsPointsByPlaceValid ||_playerCount<=1 || _chartCount<=1 || string.IsNullOrWhiteSpace(_randomSettings) || string.IsNullOrWhiteSpace(_matchName)">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddMatchDialog = false">@L["Close"]</MudButton>
        </DialogActions>
    </MudDialog>
    <MudDialog @bind-Visible="_showBulkCreate">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudAutocomplete Disabled="_bulkCreating" T="string" @bind-Value="_phaseName" Label="Phase" CoerceText="false" CoerceValue="true" SearchFunc="(s,c)=>Task.FromResult(_matches.Select(m=>m.Value.PhaseName).Distinct().Where(n=>n.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).Select(s=>s.ToString()))"></MudAutocomplete>

                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" Disabled="_bulkCreating" @bind-Value="_playersPerMatch" Min="1" Max="100" Label="Players Per Match"></MudNumericField>
                </MudItem>
                @if (_playerCount > 2)
                {
                    <MudItem xs="12">
                        <MudTextField T="string" Label="Points by place (1st place 1st)" @bind-Value="_pointsByPlace"></MudTextField>
                    </MudItem>
                }
                <MudItem xs="12">
                    <MudNumericField T="int" Disabled="_bulkCreating" @bind-Value="_matchesPerRound" Min="1" Max="10" Label="Matches Per Round"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" Disabled="_bulkCreating" @bind-Value="_chartCount" Min="1" Max="10" Label="Charts Per Match"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" Disabled="_bulkCreating" @bind-Value="_winnersProgressCount" Min="1" Max="_playersPerMatch-1" Label="Progressing Winner Count"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudCheckBox T="bool" Disabled="_bulkCreating" @bind-Value="_isDoubleElimination" Label="Double Elimination"></MudCheckBox>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" Disabled="_bulkCreating" Value="_rounds" ValueChanged="SetRoundCount" Min="1" Max="30" Label="Rounds"></MudNumericField>
                </MudItem>
                @for (var i = 0; i < _rounds; i++)
                {
                    var roundIndex = i;
                    <MudItem xs="12">
                        <MudSelect T="Name" Disabled="_bulkCreating" @bind-Value="_roundSettings[roundIndex]" Label=@($"Round {roundIndex + 1} Card Draw")>
                            @foreach (var setting in _chartPullSettings.Keys)
                            {
                                <MudSelectItem T="Name" Value="@setting">@setting</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                }
            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="BulkCreate" Disabled=@(!IsPointsByPlaceValid ||_bulkCreating || _roundSettings.Any(r=>r=="Not Set"))>@L["Create"]</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showBulkCreate = false">@L["Close"]</MudButton>
        </DialogActions>
    </MudDialog>
<br />
    <MudButton OnClick="FindInvalidMatches" Color="Color.Primary" Variant="Variant.Filled">Check Matches</MudButton>
    @if (_linksChecked && !_tooManyLinks.Any() && !_notEnoughLinks.Any())
    {
        <MudText>You did it!</MudText>
    }
    
    @if (_tooManyLinks.Any())
    {
        <MudText>Too many: 
            @foreach (var match in _tooManyLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }

        </MudText>
    }
    @if (_notEnoughLinks.Any())
    {
        <MudText>
            Not enough:
            @foreach (var match in _notEnoughLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }
        </MudText>
    }

    <MudTable T="MatchLink" Items="_matchLinks">
        <ToolBarContent>
            <MudText Typo="Typo.h6">Links</MudText>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="()=>_showMatchLinkDialog=true">Create</MudButton>
        </ToolBarContent>
        <HeaderContent>
            <MudTh>From Match</MudTh>
            <MudTh>To Match</MudTh>
            <MudTh>Type</MudTh>
            <MudTh>Players</MudTh>
            <MudTh>Delete</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd>@context.FromMatch</MudTd>
            <MudTd>@context.ToMatch</MudTd>
            <MudTd>@(context.IsWinners?"Winners":"Losers")</MudTd>
            <MudTd>@context.PlayerCount</MudTd>
            <MudTd><MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Primary" OnClick="()=>DeleteLink(context)"></MudIconButton></MudTd>
        </RowTemplate>
        
        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
}

@if (_myRole!=null)
{
    <SfKanban TValue="MatchCard" CssClass="kanban-overview" KeyField="Status" DataSource="MatchCards" EnableTooltip="true" AllowDragAndDrop="false">
        <KanbanColumns>
            <KanbanColumn HeaderText="Not Started" KeyField="@(new List<string>() { MatchState.NotStarted.ToString() })" AllowToggle="true">

            </KanbanColumn>
            <KanbanColumn HeaderText="Ready to Draw" KeyField="@(new List<string>() {"Ready to Draw"})" AllowToggle="true"></KanbanColumn>
        
            <KanbanColumn HeaderText="Card Draw" KeyField="@(new List<string>() {MatchState.CardDraw.ToString()})" AllowToggle="true"></KanbanColumn>
            <KanbanColumn HeaderText="Warming Up" KeyField="@(new List<string>() {MatchState.Ready.ToString()})" AllowToggle="true"></KanbanColumn>
            <KanbanColumn HeaderText="Playing" KeyField="@(new List<string>() {MatchState.InProgress.ToString(),MatchState.Finalizing.ToString()})" AllowToggle="true"></KanbanColumn>
            <KanbanColumn HeaderText="Complete" KeyField="@(new List<string>() {MatchState.Completed.ToString()})" AllowToggle="true"></KanbanColumn>
        </KanbanColumns>
        <KanbanCardSettings HeaderField="MatchName">
            <Template>
                <MudPaper Style="padding:10px;">
                    @{ var match = context as MatchCard; }
                    @foreach (var player in match.Players)
                    {
                        
                        <MudText>@player</MudText>
                    }
                    <MudButton Color="Color.Primary" OnClick="() => ViewMatch(match.MatchName)">Open</MudButton>
                </MudPaper>
            </Template>
    </KanbanCardSettings>

        <KanbanEvents TValue="MatchCard" DialogOpen="@OnKanbanDialogOpen"></KanbanEvents>
</SfKanban>
}
<br/>

<MudAutocomplete T="string"
                 Value="@_searchedPlayer"
                 ValueChanged="SearchForPlayer"
                 ResetValueOnEmptyText="true"
                 CoerceText="true"
                 Label=@($"Player Search")
                 AdornmentIcon="@Icons.Material.Filled.Search"
                 SearchFunc="@((s,c) => Task.FromResult(_players.Keys.Where(o=>string.IsNullOrWhiteSpace(s)||o.Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

</MudAutocomplete>
@if (_matches.Any())
{
    
    <br/>
    <div class="control-section">

        <SfDiagramComponent @ref="@Diagram" ID="diagram" InteractionController="DiagramInteractions.SingleSelect" NodeCreating="OnNodeCreating" SelectionChanged="SelectionChanged" ConnectorCreating="OnConnectorCreating" Created="OnCreated" Height="590px" Nodes="@NodeCollection" Connectors="@ConnectorCollection">
            <SnapSettings Constraints=SnapConstraints.None>
            </SnapSettings>

        </SfDiagramComponent>

    </div>
    <div class="col-lg-4" style="width:50%; padding:0px;right:30px;bottom:50px;border: #eeeeee;border-style: solid;box-shadow: 0px 2px 2px rgba(0,0,0,0.3); background:#f7f7f7;position:relative;display:block;">
        <div style="top:30px">
            <SfDiagramOverviewComponent Height="150px" SourceID="diagram"></SfDiagramOverviewComponent>
        </div>
    </div>
}

<br/>
<MudTable T="ChartStats" Items="_chartStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Chart Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>_charts[e.ChartId].Song.Name.ToString()">Song</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>(int)_charts[e.ChartId].Level">Difficulty</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.MatchCount">Card Draws</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.VetoCount">Vetoes</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.ProtectCount">Protects</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.TotalPlayCount">Total Plays</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>(int)e.AverageScore">Average Score</MudTableSortLabel></MudTh>
        <MudTh>View Leaderboard</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>
            <MudImage Src="@_charts[context.ChartId].Song.ImagePath.ToString()" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown"/>
        </MudTd>
        <MudTd>
            <DifficultyBubble Chart="_charts[context.ChartId]"></DifficultyBubble>
        </MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.VetoCount</MudTd>
        <MudTd>@context.ProtectCount</MudTd>
        <MudTd>@context.TotalPlayCount</MudTd>
        <MudTd>@context.AverageScore (@context.AverageScore.LetterGrade.GetName())</MudTd>
        <MudTd><MudIconButton Icon="@Icons.Material.Filled.ViewList" Color="Color.Primary" OnClick="@(()=>_showingChart=_showingChart==context.ChartId?Guid.Empty:context.ChartId)"></MudIconButton></MudTd>
    </RowTemplate>
    <ChildRowContent>
        <MudTr>
            <td colspan="8">
                @if (_showingChart==context.ChartId)
                {
                    foreach (var kv in _chartLeaderboards[context.ChartId].OrderByDescending(kv=>(int)kv.Value))
                    {
                        <MudText>@kv.Key - @kv.Value (@kv.Value.LetterGrade.GetName())</MudText><br/>
                    }                    
                }
            </td>
        </MudTr>
    </ChildRowContent>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<br/>
<MudTable T="SongStats" Items="_songStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Song Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.SongName.ToString()">Song</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.MatchCount">Card Draws</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.VetoCount">Vetoes</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.ProtectCount">Protects</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.TotalPlayCount">Total Plays</MudTableSortLabel></MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>
            <MudImage Src="@_songImages[context.SongName]" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown" />
        </MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.VetoCount</MudTd>
        <MudTd>@context.ProtectCount</MudTd>
        <MudTd>@context.TotalPlayCount</MudTd>
    </RowTemplate>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<br/>
<MudTable T="PlayerStats" Items="_playerStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Player Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.Player.ToString()">Name</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.MatchCount">Matches</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.ChartsPlayed">Charts</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>(int)e.AverageScore">Average Score</MudTableSortLabel></MudTh>
        <MudTh>View Charts</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>@context.Player</MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.ChartsPlayed</MudTd>
        <MudTd>@context.AverageScore (@context.AverageScore.LetterGrade.GetName())</MudTd>
        <MudTd>
            @if (_playerScores.ContainsKey(context.Player))
            {
                <MudIconButton Icon="@Icons.Material.Filled.ViewList" Color="Color.Primary" OnClick="@(() => _showingPlayer = _showingPlayer == context.Player ? null :(Name?) context.Player)"></MudIconButton>
            }
            
        </MudTd>
    </RowTemplate>
    <ChildRowContent>
        <MudTr>
            <td colspan="5">
                @if (_showingPlayer == context.Player)
                {
                    foreach (var chart in _playerScores[_showingPlayer])
                    {
                        <MudText>@_charts[chart.ChartId].Song.Name @_charts[chart.ChartId].DifficultyString - @chart.Score (@chart.Score.LetterGrade.GetName())</MudText>
                    }
                }
            </td>
        </MudTr>
    </ChildRowContent>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<MudButton OnClick=@(()=>NavManager.NavigateTo($"/Tournament/{TournamentId}/Qualifiers")) Variant="Variant.Filled">View Qualifiers</MudButton>
<br/>
@if (_myRole == TournamentRole.HeadTournamentOrganizer)
{
    
    <MudButton OnClick=@(()=>NavManager.NavigateTo($"/Tournament/{TournamentId}/Admin")) Variant="Variant.Filled">Admin Page</MudButton>
}
<br/>

<MudDialog @bind-Visible="_showMatchDialog">
    <DialogContent>
        @if (_currentMatch != null)
        {
            <MatchOverview MatchName="_currentMatch.Value" TournamentId="TournamentId" MyRole="_myRole"></MatchOverview>
        }
    </DialogContent>
    <DialogActions>
        @if (_myRole != null && _currentMatch != null)
        {
            <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.AddAlert" OnClick="()=>PingMatch(_currentMatch.Value)">Ping Match</MudButton>
        }
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
<MudDialog @bind-Visible="_showNotesPopup">
    <DialogContent>
        @if (_notesMatch != null)
        {
            <MudGrid>
                @foreach (var player in _notesMatch.Players.Where(p => _players.ContainsKey(p) && !string.IsNullOrWhiteSpace(_players[p].Notes)))
                {
                    <MudItem xs="12">
                        <MudText>@player - @_players[player].Notes</MudText>
                    </MudItem>
                }
            </MudGrid>
        }
    </DialogContent>
    <DialogActions>
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showNotesPopup = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
<MudDialog @bind-Visible="_showMatchLinkDialog">
    <DialogContent>
        <MudGrid>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_fromMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"From Match")
                                 SearchFunc="@((s,c) => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_toMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"To Match")
                                 SearchFunc="@((s,c) => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudCheckBox T="bool" @bind-Value="_winners" Label="Winners"></MudCheckBox>
            </MudItem>
            <MudItem xs="12">
                <MudNumericField @bind-Value="_linkPlayers" Min="1" Max="100" Label="Players" HideSpinButtons="true"></MudNumericField>
            </MudItem>
        </MudGrid>
    </DialogContent>        <DialogActions>
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateLink">Save</MudButton>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchLinkDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>

<style>
    #rotateThumb {
        display:none;
    }
    #pivotLine {
        display:none;
    }
    .e-diagram-resize-handle {
        display:none;
    }


</style>
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject ISnackbar Snackbar;
@inject ITournamentRepository Tournaments;
@inject NavigationManager NavManager;
@code
{

    [Parameter]
    [SupplyParameterFromQuery(Name = "TournamentId")]
    public Guid TournamentId { get; set; }

    private IDictionary<string, RandomSettings> _chartPullSettings = new Dictionary<string, RandomSettings>(StringComparer.OrdinalIgnoreCase);
    private RandomSettings _currentSettings = new();
    private string _currentRandomName = string.Empty;
    private bool _showAddRandomDialog = false;
    private bool _showAddMatchDialog = false;
    private bool _showMatchDialog = false;
    private bool _showMatchLinkDialog = false;
    private User? _user;
    private int _playerCount = 2;
    private int _chartCount = 3;
    private Guid _showingChart = Guid.Empty;
    private Name? _showingPlayer;
    private MatchView? _notesMatch;
    private TournamentRole? _myRole;
    private IEnumerable<UserTournamentRole> _userRoles = Array.Empty<UserTournamentRole>();
    private bool _showNotesPopup;
    private bool _spectatorMode = false;
    private string _searchedPlayer = string.Empty;
    private string _pointsByPlace = "";
    private string _randomSettings = string.Empty;
    private string _fromMatch = string.Empty;
    private string _toMatch = string.Empty;
    private int _linkPlayers = 1;
    private bool _winners = true;
    private string _matchName = string.Empty;

    private static readonly BasicShape _matchShape = new BasicShape()
    {
        Type = NodeShapes.Basic,
        Shape = NodeBasicShapes.Rectangle
    };

    public SfDiagramComponent Diagram;

    private void OnCreated()
    {

        Diagram.BringIntoView(new DiagramRect(0, 0, 500, 300));
    }

    private PointPort rightPort = new PointPort { ID = "rightPort", Offset = new DiagramPoint { X = 1, Y = .5 }, Visibility = PortVisibility.Connect };
    private PointPort leftPort = new PointPort { ID = "leftPort", Offset = new DiagramPoint { X = 0, Y = 0.5 }, Visibility = PortVisibility.Connect };

    private void OnNodeCreating(IDiagramObject obj)
    {
        Node node = obj as Node;
        node.Shape.Type = Syncfusion.Blazor.Diagram.NodeShapes.Basic;
        (node.Shape as BasicShape).Shape = NodeBasicShapes.Rectangle;
        node.Style.StrokeColor = "#024249";
        node.Constraints = NodeConstraints.Default & ~NodeConstraints.Drag & ~NodeConstraints.Delete & ~NodeConstraints.Resize;
        node.Annotations[0].Style.Color = "White";
        node.Annotations[0].Margin = new DiagramThickness() { Left = 0, Right = 0 };
        node.Ports = new DiagramObjectCollection<PointPort>(new[] { leftPort, rightPort });
    }

    // Defines default values for Connector object
    private void OnConnectorCreating(IDiagramObject obj)
    {
        var con = obj as Connector;

        con.Constraints = ConnectorConstraints.None;
        con.TargetDecorator = new DecoratorSettings() { Shape = DecoratorShape.Arrow, Style = new ShapeStyle() { Fill = "#024249", StrokeColor = "#024249" } };
        con.Style = new ShapeStyle() { StrokeColor = "#6d6d6d", StrokeWidth = 2 };
        con.Type = ConnectorSegmentType.Bezier;
    }

    private void OnKanbanDialogOpen(DialogOpenEventArgs<MatchCard> args)
    {
        args.Cancel = true;
        if (args?.Data?.MatchName == null)
        {
            return;
        }
        ViewMatch(args.Data.MatchName);
    }
    private DiagramObjectCollection<Connector> ConnectorCollection = new DiagramObjectCollection<Connector>();
    private DiagramObjectCollection<Node> NodeCollection = new DiagramObjectCollection<Node>();
    private Name? _currentMatch;

    private IEnumerable<MatchView> InProgressMatches => _matches.Values.Where(m => m.State is MatchState.InProgress or MatchState.Finalizing)
        .OrderByDescending(m => m.State).ThenBy(m => m.MatchOrder);

    private IEnumerable<MatchView> WarmingUpMatches => _matches.Values.Where(m => m.State == MatchState.Ready && !string.IsNullOrWhiteSpace(m.Machine))
        .OrderByDescending(m => m.MatchOrder);

    private IEnumerable<MatchView> StandbyMatches => _matches.Values.Where(m => m.State == MatchState.Ready && string.IsNullOrWhiteSpace(m.Machine))
        .OrderByDescending(m => m.MatchOrder);

    private IEnumerable<MatchView> CardDrawing => _matches.Values.Where(m => m.State == MatchState.CardDraw)
        .OrderByDescending(m => m.MatchOrder);

    private string _currentPhase = string.Empty;

    private async Task PingMatch(Name matchName)
    {
        await Mediator.Send(new PingMatchCommand(TournamentId, matchName));
    }

    private async Task SelectionChanged(SelectionChangedEventArgs arg)
    {
        if (arg.NewValue.Count() > 1)
        {
            return;
        }
        var node = arg.NewValue[0] as Node;
        if (node == null && !_matches.ContainsKey(node.ID))
        {
            return;
        }

        ViewMatch(node.ID);

    }

    private bool isMobileDevice = false;
    private IEnumerable<MatchView> UpcomingMatches => _matches.Values.Where(m => m.State is MatchState.NotStarted).OrderBy(m => m.MatchOrder);
    private IEnumerable<MatchView> CompletedMatches => _matches.Values.Where(m => m.State is MatchState.Completed).OrderBy(m => m.MatchOrder);
    private IEnumerable<MatchView> ReadyToCardDrawMatches => UpcomingMatches.Where(m => m.PhaseName == _currentPhase && m.State is MatchState.NotStarted && !m.Players.Any(p => p.ToString().StartsWith("Unknown "))).OrderBy(m => m.MatchOrder);
    private IDictionary<string, string> _songImages = new Dictionary<string, string>();

    private IEnumerable<(string header, bool showWinner,bool showMachine, IEnumerable<MatchView> matches)> MatchSections()
    {
        yield return ("In Progress Matches", false, true, InProgressMatches);
        yield return ("Warming Up",false,true,WarmingUpMatches);
        yield return ("Standby/Ready",false,false,StandbyMatches);
        yield return ("Card Draw",false,false,CardDrawing);
        yield return ("Ready To Card Draw",false,false,ReadyToCardDrawMatches);
        yield return ("Future Matches",false,false,UpcomingMatches);
        yield return ("Completed Matches",true,false,CompletedMatches);
    }

    private bool _showAdminTools = false;
    private IDictionary<string, MatchView> _matches = new Dictionary<string, MatchView>();
    private ICollection<MatchLink> _matchLinks = new List<MatchLink>();
    private readonly ICollection<Name> _tooManyLinks = new List<Name>();
    private readonly ICollection<Name> _notEnoughLinks = new List<Name>();
    private string _phaseName = "";
    private bool _linksChecked = false;
    private Name TournamentName { get; set; } = "...";
    private bool _showBulkCreate = false;
    private int _playersPerMatch = 4;
    private int _matchesPerRound = 2;
    private int _rounds = 1;
    private int _winnersProgressCount = 1;
    private bool _isDoubleElimination = false;
    private Name[] _roundSettings = new Name[] { "Not Set" };
    private bool _bulkCreating = false;

    private sealed record MatchCard(string MatchName, string Status, string[] Players);

    private IEnumerable<MatchCard> MatchCards => _matches.Values
        .OrderBy(m=>m.MatchOrder).Select(m => new MatchCard(
        m.MatchName,
        m.State == MatchState.NotStarted && m.Players.All(p => !p.ToString().StartsWith("Unknown ")) ? "Ready to Draw" : m.State.ToString(),
        m.Players.Select(n=>n.ToString()).ToArray()));

    private void SetPlayerCount(int playerCount)
    {
        _playerCount = playerCount;
        _pointsByPlace = playerCount <= 2 ? "" : string.Join(",", Enumerable.Range(1, playerCount).Reverse());
    }

    private async Task BulkCreate()
    {
        _bulkCreating = true;
        var winnersLabel = _isDoubleElimination ? " Winners" : "";
        var losersLabel = _isDoubleElimination ? " Losers" : "";
        var nextOrder = _matches.Any() ? _matches.Max(m => m.Value.MatchOrder) + 1 : 0;

        var places =
            string.IsNullOrWhiteSpace(_pointsByPlace) ? null
                : _pointsByPlace.Split(",").Select(s => s.Trim())
                    .Select(int.Parse).ToArray();
        for (var currentRound = 0; currentRound < _rounds; currentRound++)
        {
            var settings = _roundSettings[currentRound];
            for (var currentMatch = 0; currentMatch < _matchesPerRound; currentMatch++)
            {
                var matchName = $"{_phaseName}{winnersLabel} Round {currentRound + 1} Match {currentMatch + 1}";
                var players = Enumerable.Range(0, _playersPerMatch).Select(c => Name.From($"Unknown {c}")).ToArray();
                await Mediator.Send(new UpdateMatchCommand(TournamentId, new MatchView(matchName,
                    _phaseName,
                    nextOrder++,
                    _chartCount,
                    settings,
                    MatchState.NotStarted,
                    players, Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    players.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
                    players.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
                    players, currentRound + 1, "", places
                    )));
                if (currentRound > 0)
                {
                    var previousMatch = $"{_phaseName}{winnersLabel} Round {currentRound} Match {currentMatch + 1}";

                    var link = new MatchLink(previousMatch, matchName, true, _winnersProgressCount);
                    await Mediator.Send(new CreateMatchLinkCommand(TournamentId, link));
                    foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == link.FromMatch && ml.ToMatch == link.ToMatch))
                    {
                        _matchLinks.Remove(existingLink);
                    }
                    _matchLinks.Add(link);
                }
                if (!_isDoubleElimination) continue;

                var losersMatchName = $"{_phaseName}{losersLabel} Round {currentRound + 1} Match {currentMatch + 1}";
                var lPlayers = Enumerable.Range(0, currentRound == 0 ? _playersPerMatch - 1 : _playersPerMatch).Select(c => Name.From($"Unknown {c}")).ToArray();
                await Mediator.Send(new UpdateMatchCommand(TournamentId, new MatchView(losersMatchName,
                    _phaseName,
                    nextOrder++,
                    _chartCount,
                    settings,
                    MatchState.NotStarted,
                    lPlayers, Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    lPlayers.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
                    lPlayers.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
                    lPlayers, currentRound + 1, "", places
                    )));
                if (currentRound > 0)
                {
                    var previousMatch = $"{_phaseName}{losersLabel} Round {currentRound} Match {currentMatch + 1}";

                    var link = new MatchLink(previousMatch, losersMatchName, true, _winnersProgressCount);
                    await Mediator.Send(new CreateMatchLinkCommand(TournamentId, link));
                    foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == link.FromMatch && ml.ToMatch == link.ToMatch))
                    {
                        _matchLinks.Remove(existingLink);
                    }
                    _matchLinks.Add(link);
                }

                var winnersToLosers = new MatchLink(matchName, losersMatchName, false, _playersPerMatch - _winnersProgressCount);
                await Mediator.Send(new CreateMatchLinkCommand(TournamentId, winnersToLosers));
                foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == winnersToLosers.FromMatch && ml.ToMatch == winnersToLosers.ToMatch))
                {
                    _matchLinks.Remove(existingLink);
                }
                _matchLinks.Add(winnersToLosers);

            }
        }
        _bulkCreating = true;
        Snackbar.Add("Matches Created!", Severity.Success);
        _showBulkCreate = false;
    }

    private void SetRoundCount(int rounds)
    {
        if (rounds < _rounds)
        {
            _roundSettings = _roundSettings.Take(rounds).ToArray();
        }
        if (rounds > _rounds)
        {
            _roundSettings = _roundSettings.Concat(Enumerable.Repeat((Name)"Not Set", rounds - _rounds)).ToArray();
        }
        _rounds = rounds;
    }

    public void ShowNotes(MatchView match)
    {
        _notesMatch = match;
        _showNotesPopup = true;
    }

    private void OpenBulkAddMatchDialog()
    {
        _showBulkCreate = true;
        _phaseName = string.Empty;
        SetRoundCount(1);
        _isDoubleElimination = false;
        _playersPerMatch = 4;
        _chartCount = 3;
    }

    private void SearchForPlayer(string player)
    {
        _searchedPlayer = player;

        foreach (var node in NodeCollection)
        {
            var match = _matches[node.ID];
            node.Style.Fill = ColorOfMatch(match);
        }

        StateHasChanged();
    }

    private string ColorOfMatch(MatchView match) =>
        !string.IsNullOrWhiteSpace(_searchedPlayer) && match.Players.Any(p => p.Contains(_searchedPlayer)) ?
            Colors.Yellow.Darken1 :
            match.State switch

    {
        MatchState.NotStarted => Colors.Gray.Darken1,
                MatchState.CardDraw => Colors.Green.Darken1,
        MatchState.Ready => Colors.Green.Darken1,
        MatchState.InProgress=>Colors.Green.Darken1,
        MatchState.Finalizing=>Colors.Green.Darken1,
        MatchState.Completed=>Colors.Cyan.Default,
                _ => Colors.Gray.Darken1

                };
    private async Task CreateLink()
    {
        var link = new MatchLink(_fromMatch, _toMatch, _winners, _linkPlayers);
        if (link.FromMatch == link.ToMatch)
        {
            return;
        }
        await Mediator.Send(new CreateMatchLinkCommand(TournamentId, link));
        foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == link.FromMatch && ml.ToMatch == link.ToMatch))
        {
            _matchLinks.Remove(existingLink);
        }
        _matchLinks.Add(link);
        _showMatchLinkDialog = false;
    }

    private async Task DeleteLink(MatchLink link)
    {
        await Mediator.Send(new DeleteMatchLinkCommand(TournamentId, link.FromMatch, link.ToMatch));
        _matchLinks.Remove(link);
    }

    private void FindInvalidMatches()
    {

        _tooManyLinks.Clear();
        _notEnoughLinks.Clear();
        var linkDict = _matchLinks
            .Where(l=>_matches[l.FromMatch].State is not MatchState.Completed)
            .GroupBy(l => l.ToMatch.ToString()).ToDictionary(g => g.Key, g => g.ToArray());

        foreach (var match in _matches.Values)
        {
            var progressingCount = linkDict.TryGetValue(match.MatchName, out var value)?value.Sum(l => l.PlayerCount):0;
            var existingCount = match.Players.Count(p => !p.ToString().StartsWith("Unknown "));
            if (progressingCount + existingCount < match.Players.Length)
            {
                _notEnoughLinks.Add(match.MatchName);
            }
            if (progressingCount + existingCount > match.Players.Length)
            {
                _tooManyLinks.Add(match.MatchName);
            }
        }
        _linksChecked = true;
    }
    public void OpenAddRandomDialog()
    {
        _currentSettings = new();
        _showAddRandomDialog = true;
        _currentRandomName = string.Empty;
    }
    public void OpenAddMatchDialog()
    {
        _matchName = string.Empty;
        _showAddMatchDialog = true;
    }

    private void ViewMatch(Name matchName)
    {
        _currentMatch = matchName;
        _showMatchDialog = true;
    }

    private IDictionary<string, MatchPlayer> _players = new Dictionary<string, MatchPlayer>();
    private int _round = 1;
    private bool IsPointsByPlaceValid => string.IsNullOrWhiteSpace(_pointsByPlace) || (_pointsByPlace.Split(",").Select(s => s.Trim()).All(s => int.TryParse(s, out var _))
    && _pointsByPlace.Split(",").Count()==_playerCount);
    private async Task CreateMatch()
    {
        var players = Enumerable.Range(0, _playerCount).Select(c => Name.From($"Unknown {c}")).ToArray();
        var places =
            string.IsNullOrWhiteSpace(_pointsByPlace)?null
            :_pointsByPlace.Split(",").Select(s => s.Trim())
            .Select(int.Parse).ToArray();
        await Mediator.Send(new UpdateMatchCommand(TournamentId, new MatchView(_matchName,
            _phaseName,
            _matches.Any()?_matches.TryGetValue(_matchName, out var existingMatch)?existingMatch.MatchOrder:_matches.Max(m=>m.Value.MatchOrder)+1:0,
            _chartCount,
            _randomSettings, MatchState.NotStarted,
            players, Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
            players,_round,"",places
            )));
        _showAddMatchDialog = false;
    }

    private void ProjectMatchOntoNode(MatchView match, Node node)
    {
        if (node.Annotations.Any())
        {
            
            node.Annotations[0].Content =string.Join("\n", match.Players);
        }
        else
        {
            node.Annotations = new DiagramObjectCollection<ShapeAnnotation>()
            {
                new ShapeAnnotation
                {
                    Content = string.Join("\n", match.Players)
                }
            };
        }
        node.Style.Fill = ColorOfMatch(match);
    }
    private void MatchUpdated(MatchUpdatedEvent e)
    {
        if (e.TournamentId != TournamentId)
        {
            return;
        }
        _matches[e.NewState.MatchName] = e.NewState;
        UpdateCurrentPhase();
        RecalculateStates();
        if (_spectatorMode)
        {
            ViewMatch(e.NewState.MatchName);
        }
        var node = NodeCollection.FirstOrDefault(n => n.ID == e.NewState.MatchName);
        if (node != null)
        {
            ProjectMatchOntoNode(e.NewState, node);

        }
        InvokeAsync(StateHasChanged);
    }

    private void UpdateCurrentPhase()
    {

        _currentPhase = _matches.GroupBy(m => m.Value.PhaseName, m => m.Value).
            OrderBy(g => g.Min(m => m.MatchOrder))
            .Where(g => g.Any(m => m.State < MatchState.Finalizing))
            .Select(g=>g.Key.ToString())
            .FirstOrDefault() ?? "None";
    }

    public async Task SaveRandomSettings()
    {
        if (!Name.TryParse(_currentRandomName, out var name))
        {
            return;
        }
        try
        {
            await Mediator.Send(new GetRandomChartsQuery(_currentSettings));
        }
        catch (Exception e)
        {
            Snackbar.Add(e.Message, Severity.Error);
            return;
        }
        await Mediator.Send(new SaveRandomSettingsCommand(TournamentId, name, _currentSettings));
        _chartPullSettings[name] = _currentSettings;
        _showAddRandomDialog = false;
    }

        private const int MatchHeight = 80;

    private async Task RedrawTournament()
    {
        ConnectorCollection = new DiagramObjectCollection<Connector>();

        NodeCollection = new DiagramObjectCollection<Node>();
        if (!_matches.Any())
        {
            return;
        }
        var x = 50;
        var rounds = _matches.Values.GroupBy(m => m.PhaseName).OrderBy(g => g.Min(m => m.MatchOrder))
            .SelectMany(phase => phase.GroupBy(m => m.Round).OrderBy(g => g.Key))
            .ToArray();

        var largestWinners = rounds.Max(g => g.Count(m => m.MatchName.Contains("Winner")));

        foreach (var round in rounds)
        {
            var winnersY = 50;
            var losersY = (largestWinners + 1) * (MatchHeight + 10) + 50;
            foreach (var match in round.OrderBy(m => m.MatchOrder))
            {

                var node = new Node()
                    {
                        ID = match.MatchName,
                        Shape = _matchShape,
                        OffsetX = x,
                        OffsetY = match.MatchName.Contains("Loser") ? losersY : winnersY,
                        Height = MatchHeight,
                        Width = 200
                    };
                ProjectMatchOntoNode(match, node);
                await NodeCollection.AddAsync(node);
                if (match.MatchName.Contains("Loser"))
                {
                    losersY += MatchHeight + 10;
                }
                else
                {
                    winnersY += MatchHeight + 10;
                }
            }
            x += 250;
        }
        foreach (var matchLink in _matchLinks.Where(m => !(m.FromMatch.Contains("Winner") && m.ToMatch.Contains("Loser"))))
        {
            var connector = new Connector()
                {
                    ID = matchLink.FromMatch.ToString() + " -> " + matchLink.ToMatch.ToString(),
                    SourceID = matchLink.FromMatch,
                    TargetID = matchLink.ToMatch,
                    SourcePortID = rightPort.ID,
                    TargetDecorator = new DecoratorSettings() { Shape = DecoratorShape.Arrow, Style = new ShapeStyle() { Fill = "#024249", StrokeColor = "#024249" } },
                    Style = new ShapeStyle() { StrokeColor = "#6d6d6d", StrokeWidth = 2 },

                };

            if (_matches[matchLink.FromMatch].Round == _matches[matchLink.ToMatch].Round)
            {
                connector.SourcePortID = leftPort.ID;
                connector.TargetPortID = leftPort.ID;
            }
            await ConnectorCollection.AddAsync(connector);
        }
    }
    protected override async Task OnInitializedAsync()
    {

        TournamentName = (await Mediator.Send(new GetAllTournamentsQuery()))
            .First(t => t.Id == TournamentId).Name;
        _user = CurrentUser.IsLoggedIn ? CurrentUser.User : null;
        _matches = (await Mediator.Send(new GetAllMatchesQuery(TournamentId))).ToDictionary(m => m.MatchName.ToString());
        _chartPullSettings = (await Mediator.Send(new GetAllRandomSettingsQuery(TournamentId))).ToDictionary(s => (string) s.name, s => s.settings);
        _matchLinks = (await Mediator.Send(new GetMatchLinksQuery(TournamentId))).ToList();
        _players = (await Mediator.Send(new GetMatchPlayersQuery(TournamentId))).ToDictionary(m => m.Name.ToString(), StringComparer.OrdinalIgnoreCase);
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).ToDictionary(c => c.Id);
        _songImages = _charts.Values.GroupBy(c => c.Song.Name.ToString()).ToDictionary(g => g.Key, g => g.Select(c => c.Song.ImagePath.ToString()).First(),StringComparer.OrdinalIgnoreCase);
        _userRoles = await Mediator.Send(new GetTournamentRolesQuery(TournamentId));
        _myRole = !CurrentUser.IsLoggedIn ? null : CurrentUser.IsLoggedInAsAdmin ? TournamentRole.HeadTournamentOrganizer : _userRoles.FirstOrDefault(e => e.UserId == _user?.Id)?.Role;


        
        UpdateCurrentPhase();
        RecalculateStates();
        MainLayout.MatchUpdated += (o, e) => MatchUpdated(e);
        await RedrawTournament();
        StateHasChanged();
    }

    private IEnumerable<ChartStats> _chartStats = Array.Empty<ChartStats>();
    private IEnumerable<PlayerStats> _playerStats = Array.Empty<PlayerStats>();
    private IEnumerable<SongStats> _songStats = Array.Empty<SongStats>();
    private IDictionary<string, ICollection<PlayerChartScore>> _playerScores = new Dictionary<string, ICollection<PlayerChartScore>>();
    private IDictionary<Guid, IDictionary<string, PhoenixScore>> _chartLeaderboards = new Dictionary<Guid, IDictionary<string, PhoenixScore>>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private sealed record ChartStats(Guid ChartId, int MatchCount, int VetoCount, int ProtectCount, int TotalPlayCount, PhoenixScore AverageScore)
    {

    }

    private sealed record SongStats(Name SongName, int MatchCount, int VetoCount, int ProtectCount, int TotalPlayCount)
    {

    }
    private sealed record PlayerStats(Name Player, int MatchCount, int ChartsPlayed, PhoenixScore AverageScore)
    {

    }

    private sealed record PlayerChartScore(Guid ChartId, PhoenixScore Score)
    {

    }
    private void RecalculateStates()
    {
        var chartCounts = new Dictionary<Guid, int>();
        var chartVetoCounts = new Dictionary<Guid, int>();
        var chartProtectCounts = new Dictionary<Guid, int>();
        var chartPlayerCounts = new Dictionary<Guid, int>();
        var chartScoreTotal = new Dictionary<Guid, long>();
        var playerMatches = new Dictionary<string, int>();
        var playerChartCount = new Dictionary<string, int>();
        var playerScoreTotal = new Dictionary<string, long>();
        var playerScores = new Dictionary<string, ICollection<PlayerChartScore>>(StringComparer.OrdinalIgnoreCase);
        var chartLeaderboards = new Dictionary<Guid, IDictionary<string, PhoenixScore>>();

        foreach (var match in CompletedMatches)
        {
            foreach (var chartId in match.ActiveCharts.Concat(match.ProtectedCharts).Concat(match.VetoedCharts).Distinct())
            {
                    
                chartCounts.TryAdd(chartId, 0);
                chartPlayerCounts.TryAdd(chartId, 0);
                chartScoreTotal.TryAdd(chartId, 0);
                chartVetoCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartCounts.TryAdd(chartId, 0);
                chartVetoCounts.TryAdd(chartId, 0);
                chartLeaderboards.TryAdd(chartId, new Dictionary<string, PhoenixScore>(StringComparer.OrdinalIgnoreCase));
            }
            for (var i = 0; i < match.ActiveCharts.Length; i++)
            {
                var chartId = match.ActiveCharts[i];

                chartCounts[chartId]++;
                if (match.Scores.All(s => s.Value[i] <=1)) continue;
                chartPlayerCounts[chartId] += match.Scores.Count(s => s.Value[i]>1);
                chartScoreTotal[chartId] += match.Scores.Sum(kv => kv.Value[i]);
                foreach (var player in match.Players)
                {
                    if (match.Scores[player][i] <=1)
                    {
                        continue;
                    }
                    playerScores.TryAdd(player, new List<PlayerChartScore>());
                    playerScores[player].Add(new PlayerChartScore(chartId, match.Scores[player][i]));
                    if (!chartLeaderboards[chartId].ContainsKey(player) || match.Scores[player][i] > chartLeaderboards[chartId][player])
                    {
                        chartLeaderboards[chartId][player] = match.Scores[player][i];
                    }
                }
            
            }
            foreach (var chartId in match.ProtectedCharts)
            {
                chartProtectCounts[chartId]++;
            }
            foreach (var chartId in match.VetoedCharts)
            {
                chartCounts[chartId]++;
                chartVetoCounts[chartId]++;
            }
            foreach (var player in match.Players)
            {
                
                playerMatches.TryAdd(player, 0);
                playerMatches[player]++;
                playerChartCount.TryAdd(player, 0);
                playerChartCount[player] += match.Scores[player].Count(s => s >1);
                playerScoreTotal.TryAdd(player, 0);
                playerScoreTotal[player] += match.Scores[player].Sum(s => (int)s);
            }
        }
        _playerScores = playerScores;
        _playerStats = playerMatches.Keys.Select(player => new PlayerStats(player, playerMatches[player], playerChartCount[player],playerChartCount[player]>0? PhoenixScore.From((int)(playerScoreTotal[player] / playerChartCount[player])):0)).ToArray();
        _chartLeaderboards = chartLeaderboards;
        _chartStats= chartCounts.Keys.Select(chartId => new ChartStats(chartId, chartCounts[chartId], chartVetoCounts[chartId], chartProtectCounts[chartId], chartPlayerCounts[chartId], chartPlayerCounts[chartId] > 0 ? PhoenixScore.From((int)(chartScoreTotal[chartId] / chartPlayerCounts[chartId])) : 0)).ToArray();
        _songStats = _chartStats.GroupBy(c => _charts[c.ChartId].Song.Name.ToString()).Select(g => new SongStats(g.Key, g.Sum(c => c.MatchCount), g.Sum(c => c.VetoCount), g.Sum(c => c.ProtectCount), g.Sum(c => c.TotalPlayCount)));
    }
}
