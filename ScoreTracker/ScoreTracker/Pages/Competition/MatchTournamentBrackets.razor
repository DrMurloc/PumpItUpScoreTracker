@page "/Tournament/{TournamentId:guid}/Brackets"
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Views
@using ScoreTracker.Web.Components
@using MediatR
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Events
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Web.Shared
@using System.Text.RegularExpressions
@using ScoreTracker.Domain.Records
@using Syncfusion.Blazor.Buttons
@using Syncfusion.Blazor.Diagram
@using Syncfusion.Blazor.Diagram.Overview
@using SelectionChangedEventArgs = Syncfusion.Blazor.Diagram.SelectionChangedEventArgs
@using Syncfusion.Blazor.Kanban

<PageTitle>@TournamentName Brackets</PageTitle>

<br/>
<MudGrid>
    <MudItem xs="6">
        <MudTooltip Text="Automatically pulls up matches as they change">
            <MudCheckBox T="bool" @bind-Value="_spectatorMode" Label="Spectator Mode"></MudCheckBox>
        </MudTooltip>
    </MudItem>
    @if (_myRole ==TournamentRole.HeadTournamentOrganizer)
    {
        <MudItem xs="6">
            <MudCheckBox T="bool" @bind-Value="_showAdminTools" Label="Show Admin Tools"></MudCheckBox>
        </MudItem>        
    }
</MudGrid>
<br />
<br />

@if (_myRole == TournamentRole.HeadTournamentOrganizer && _showAdminTools)
{
    <MudGrid>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddRandomDialog">Add Randomizer Settings</MudButton>
        </MudItem>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddMatchDialog">Add Match</MudButton>
        </MudItem>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenBulkAddMatchDialog">Bulk Create Matches</MudButton>
        </MudItem>
        <MudItem xs="6" sm="4" md="3">
            @if (_showSkipSeedCheck)
            {
                
                <MudButton Color="Color.Warning" Variant="Variant.Filled" OnClick="()=>PopulateSeeds(true)">Confirm Seed Population</MudButton>
            
            }
            else
            {
                
                <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="() => PopulateSeeds(false)">Populate Seeds</MudButton>
            }
        </MudItem>
    </MudGrid>


    <MudDialog @bind-Visible="_showAddRandomDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_currentRandomName" Label="Settings Name"></MudTextField>
                </MudItem>
            </MudGrid>
            <RandomizerSettingsConfiguration Settings="_currentSettings"></RandomizerSettingsConfiguration>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="SaveRandomSettings">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddRandomDialog = false">@L["Close"]</MudButton>
        </DialogActions>

    </MudDialog>

    <MudDialog @bind-Visible="_showAddMatchDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudNumericField T="int" Value="_playersPerMatch" ValueChanged="SetPlayersPerMatch" Label="Players Count"></MudNumericField>
                </MudItem>
                @if (_playersPerMatch > 2)
                {
                    <MudItem xs="12">
                        <MudTextField T="string" Label="Points by place (1st place 1st)" @bind-Value="_pointsByPlace"></MudTextField>
                    </MudItem>
                }
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_matchName" Label="Match Name"></MudTextField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_chartCount" Label="Chart Count"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_round" Label="Round (Horizontal Order Within Phase for display purposes)"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudAutocomplete T="string" @bind-Value="_phaseName" Label="Phase" CoerceText="false" CoerceValue="true" SearchFunc="(s,c)=>Task.FromResult(_matches.Select(m=>m.Value.PhaseName).Distinct().Where(n=>n.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).Select(s=>s.ToString()))"></MudAutocomplete>

                </MudItem>
                <MudItem xs="12">
                    <MudSelect @bind-Value="_randomSettings" Label="Random Settings" Required="true">
                        @foreach (var key in _chartPullSettings.Keys.OrderBy(k => k))
                        {
                            <MudSelectItem Value="@key">@key</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateMatch" Disabled="!IsPointsByPlaceValid ||_playersPerMatch<=1 || _chartCount<=1 || string.IsNullOrWhiteSpace(_randomSettings) || string.IsNullOrWhiteSpace(_matchName)">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddMatchDialog = false">@L["Close"]</MudButton>
        </DialogActions>
    </MudDialog>
    <MudDialog @bind-Visible="_showBulkCreate">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudRadioGroup T="string" Value="_bulkCreateType" ValueChanged="SetBulkCreateType">
                        <MudRadio T="string" Value=@("Pools")>Pools</MudRadio>
                        <MudRadio T="string" Value=@("Head to Head")>Head to Head</MudRadio>
                    </MudRadioGroup>
                </MudItem>
                <MudItem xs="12">
                    <MudAutocomplete Disabled="_bulkCreating" T="string" @bind-Value="_phaseName" Label="Phase" CoerceText="false" CoerceValue="true" SearchFunc="(s, c) => Task.FromResult(_matches.Select(m => m.Value.PhaseName).Distinct().Where(n => n.ToString().Contains(s, StringComparison.OrdinalIgnoreCase)).Select(s => s.ToString()))"></MudAutocomplete>

                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" Disabled="_bulkCreating" @bind-Value="_chartCount" Min="1" Max="10" Label="Charts Per Match"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudCheckBox T="bool" Disabled="_bulkCreating" @bind-Value="_isDoubleElimination" Label="Double Elimination"></MudCheckBox>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_lowestSeed" Label="Lowest Seed In Bracket (Seed 5 is lower than Seed 1)"></MudNumericField>
                </MudItem>
                @if (_bulkCreateType == "Pools")
                {
                    <MudItem xs="12">
                        <MudNumericField T="int" Disabled="_bulkCreating" Value="_playersPerMatch" ValueChanged="SetPlayersPerMatch" Min="1" Max="100" Label="Players Per Match"></MudNumericField>
                    </MudItem>
                    @if (_playersPerMatch > 2)
                    {
                        <MudItem xs="12">
                            <MudTextField T="string" Label="Points by place (1st place 1st, use all 0s for net score)" @bind-Value="_pointsByPlace"></MudTextField>
                        </MudItem>
                    }
                    <MudItem xs="12">
                        <MudNumericField T="int" Disabled="_bulkCreating" @bind-Value="_matchesPerRound" Min="1" Max="10" Label="Matches Per Round"></MudNumericField>
                    </MudItem>
                    <MudItem xs="12">
                        <MudNumericField T="int" Disabled="_bulkCreating" @bind-Value="_winnersProgressCount" Min="1" Max="_playersPerMatch - 1" Label="Progressing Winner Count"></MudNumericField>
                    </MudItem>
                    <MudItem xs="12">
                        <MudNumericField T="int" Disabled="_bulkCreating" Value="_rounds" ValueChanged="SetRoundCount" Min="1" Max="30" Label="Rounds"></MudNumericField>
                    </MudItem>
                }
                else
                {
                    <MudItem xs="12">
                        <MudNumericField T="int" Disabled="_bulkCreating" Value="_h2hPlayerCount" ValueChanged="SetHeadToHeadPlayerCount" Min="4" Max="128" Label="Player Count"></MudNumericField>
                    </MudItem>
                }
                
                @for (var i = 0; i < _rounds; i++)
                {
                    var roundIndex = i;
                    <MudItem xs="12">
                        <MudSelect T="Name" Disabled="_bulkCreating" @bind-Value="_roundSettings[roundIndex]" Label=@($"Round {roundIndex + 1} Card Draw")>
                            @foreach (var setting in _chartPullSettings.Keys)
                            {
                                <MudSelectItem T="Name" Value="@setting">@setting</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                }
            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="BulkCreate" Disabled=@(!(_bulkCreateType!="Pools" || IsPointsByPlaceValid) ||_bulkCreating || _roundSettings.Any(r=>r=="Not Set"))>@L["Create"]</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showBulkCreate = false">@L["Close"]</MudButton>
        </DialogActions>
    </MudDialog>
<br />
    <MudButton OnClick="FindInvalidMatches" Color="Color.Primary" Variant="Variant.Filled">Check Matches</MudButton>
    @if (_linksChecked && !_tooManyLinks.Any() && !_notEnoughLinks.Any())
    {
        <MudText>You did it!</MudText>
    }
    
    @if (_tooManyLinks.Any())
    {
        <MudText Color="Color.Error">Matches with Too Many Links: 
            @foreach (var match in _tooManyLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }

        </MudText>
    }
    @if (_notEnoughLinks.Any())
    {
        <MudText Color="Color.Error">
            Matches With Not Enough Links:
            @foreach (var match in _notEnoughLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }
        </MudText>
    }
    @foreach (var problem in _otherProblems)
    {
        <MudText Color="Color.Error">@problem</MudText>
    }
    <MudTable T="MatchLink" Items="_matchLinks">
        <ToolBarContent>
            <MudText Typo="Typo.h6">Links</MudText>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="()=>_showMatchLinkDialog=true">Create</MudButton>
        </ToolBarContent>
        <HeaderContent>
            <MudTh>From Match</MudTh>
            <MudTh>To Match</MudTh>
            <MudTh>Type</MudTh>
            <MudTh>Players</MudTh>
            <MudTh>Delete</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd>@context.FromMatch</MudTd>
            <MudTd>@context.ToMatch</MudTd>
            <MudTd>@(context.IsWinners?"Winners":"Losers")</MudTd>
            <MudTd>@context.PlayerCount</MudTd>
            <MudTd><MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Primary" OnClick="()=>DeleteLink(context)"></MudIconButton></MudTd>
        </RowTemplate>
        
        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
}
@if (_matches.Any())
{

    <SfKanban TValue="MatchCard" CssClass="kanban-overview" KeyField="Status" DataSource="MatchCards" EnableTooltip="true" AllowDragAndDrop="false">
        <KanbanColumns>
            <KanbanColumn HeaderText="Not Started" KeyField="@(new List<string>() { MatchState.NotStarted.ToString() })" AllowToggle="true" IsExpanded="false" >

            </KanbanColumn>
            <KanbanColumn HeaderText="Ready to Draw" KeyField="@(new List<string>() {"Ready to Draw"})" AllowToggle="true"></KanbanColumn>
        
            <KanbanColumn HeaderText="Card Draw" KeyField="@(new List<string>() {MatchState.CardDraw.ToString()})" AllowToggle="true"></KanbanColumn>
            <KanbanColumn HeaderText="Warming Up" KeyField="@(new List<string>() {MatchState.Ready.ToString()})" AllowToggle="true"></KanbanColumn>
            <KanbanColumn HeaderText="Playing" KeyField="@(new List<string>() {MatchState.InProgress.ToString(),MatchState.Finalizing.ToString()})" AllowToggle="true"></KanbanColumn>
            <KanbanColumn HeaderText="Complete" KeyField="@(new List<string>() {MatchState.Completed.ToString()})" AllowToggle="true"></KanbanColumn>
        </KanbanColumns>
        <KanbanCardSettings HeaderField="MatchName">
            <Template>
                <MudPaper Style="padding:10px;">
                    @{ var match = context as MatchCard; }
                    @foreach (var player in match.Players)
                    {
                        
                        <MudText>@player</MudText>
                    }
                    @if (_myRole != null)
                    {

                        <MudButton Color="Color.Primary" OnClick="() => ViewMatch(match.MatchName)">Open</MudButton>
                    }
                </MudPaper>
            </Template>
        </KanbanCardSettings>

        <KanbanEvents TValue="MatchCard" DialogOpen="@OnKanbanDialogOpen"></KanbanEvents>
    </SfKanban>
    
}
<br/>
@if (!_showDiagram)
{
     <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="()=>_showDiagram=true">Show Tournament Diagram (Beta)</MudButton>
}
@if (!_bulkCreating && NodeCollection.Any() && _showDiagram)
{
    <MudAutocomplete T="string"
                     Value="@_searchedPlayer"
                     ValueChanged="SearchForPlayer"
                     ResetValueOnEmptyText="true"
                     CoerceText="true"
                     Label=@($"Player Search")
                     AdornmentIcon="@Icons.Material.Filled.Search"
                     SearchFunc="@((s,c) => Task.FromResult(_players.Keys.Where(o=>string.IsNullOrWhiteSpace(s)||o.Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

    </MudAutocomplete>
    <MudSelect T="string" Label="Phase" Value="_showingPhase" ValueChanged="RedrawTournament">
        @foreach (var phase in _matches.Select(m => m.Value.PhaseName).Distinct())
        {
            <MudSelectItem T="string" Value="@phase">@phase</MudSelectItem>
        }
    </MudSelect>
    <div class="control-section">

        <SfDiagramComponent @ref="@Diagram" ID="diagram" InteractionController="DiagramInteractions.SingleSelect" NodeCreating="OnNodeCreating" SelectionChanged="SelectionChanged" ConnectorCreating="OnConnectorCreating" Created="OnCreated" Height="590px" Nodes="@NodeCollection" Connectors="@ConnectorCollection">
            <SnapSettings Constraints=SnapConstraints.None>
            </SnapSettings>

        </SfDiagramComponent>

    </div>
    <div class="col-lg-4" style="width:50%; padding:0px;right:30px;bottom:50px;border: #eeeeee;border-style: solid;box-shadow: 0px 2px 2px rgba(0,0,0,0.3); background:#f7f7f7;position:relative;display:block;">
        <div style="top:30px">
            <SfDiagramOverviewComponent Height="150px" SourceID="diagram"></SfDiagramOverviewComponent>
        </div>
    </div>
}

<br/>
<MudTable T="ChartStats" Items="_chartStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Chart Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>_charts[e.ChartId].Song.Name.ToString()">Song</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>(int)_charts[e.ChartId].Level">Difficulty</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.MatchCount">Card Draws</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.VetoCount">Vetoes</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.ProtectCount">Protects</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>e.TotalPlayCount">Total Plays</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="ChartStats" SortBy="e=>(int)e.AverageScore">Average Score</MudTableSortLabel></MudTh>
        <MudTh>View Leaderboard</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>
            <MudImage Src="@_charts[context.ChartId].Song.ImagePath.ToString()" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown"/>
        </MudTd>
        <MudTd>
            <DifficultyBubble Chart="_charts[context.ChartId]"></DifficultyBubble>
        </MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.VetoCount</MudTd>
        <MudTd>@context.ProtectCount</MudTd>
        <MudTd>@context.TotalPlayCount</MudTd>
        <MudTd>@context.AverageScore (@context.AverageScore.LetterGrade.GetName())</MudTd>
        <MudTd><MudIconButton Icon="@Icons.Material.Filled.ViewList" Color="Color.Primary" OnClick="@(()=>_showingChart=_showingChart==context.ChartId?Guid.Empty:context.ChartId)"></MudIconButton></MudTd>
    </RowTemplate>
    <ChildRowContent>
        <MudTr>
            <td colspan="8">
                @if (_showingChart==context.ChartId)
                {
                    foreach (var kv in _chartLeaderboards[context.ChartId].OrderByDescending(kv=>(int)kv.Value))
                    {
                        <MudText>@kv.Key - @kv.Value (@kv.Value.LetterGrade.GetName())</MudText><br/>
                    }                    
                }
            </td>
        </MudTr>
    </ChildRowContent>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<br/>
<MudTable T="SongStats" Items="_songStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Song Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.SongName.ToString()">Song</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.MatchCount">Card Draws</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.VetoCount">Vetoes</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.ProtectCount">Protects</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="SongStats" SortBy="e=>e.TotalPlayCount">Total Plays</MudTableSortLabel></MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>
            <MudImage Src="@_songImages[context.SongName]" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown" />
        </MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.VetoCount</MudTd>
        <MudTd>@context.ProtectCount</MudTd>
        <MudTd>@context.TotalPlayCount</MudTd>
    </RowTemplate>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
<br/>
<br/>
<MudTable T="PlayerStats" Items="_playerStats">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Player Stats</MudText>
    </ToolBarContent>
    <HeaderContent>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.Player.ToString()">Name</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.MatchCount">Matches</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>e.ChartsPlayed">Charts</MudTableSortLabel></MudTh>
        <MudTh><MudTableSortLabel T="PlayerStats" SortBy="e=>(int)e.AverageScore">Average Score</MudTableSortLabel></MudTh>
        <MudTh>View Charts</MudTh>
    </HeaderContent>
    <RowTemplate>
        <MudTd>@context.Player</MudTd>
        <MudTd>@context.MatchCount</MudTd>
        <MudTd>@context.ChartsPlayed</MudTd>
        <MudTd>@context.AverageScore (@context.AverageScore.LetterGrade.GetName())</MudTd>
        <MudTd>
            @if (_playerScores.ContainsKey(context.Player))
            {
                <MudIconButton Icon="@Icons.Material.Filled.ViewList" Color="Color.Primary" OnClick="@(() => _showingPlayer = _showingPlayer == context.Player ? null :(Name?) context.Player)"></MudIconButton>
            }
            
        </MudTd>
    </RowTemplate>
    <ChildRowContent>
        <MudTr>
            <td colspan="5">
                @if (_showingPlayer == context.Player)
                {
                    foreach (var chart in _playerScores[_showingPlayer])
                    {
                        <MudText>@_charts[chart.ChartId].Song.Name @_charts[chart.ChartId].DifficultyString - @chart.Score (@chart.Score.LetterGrade.GetName())</MudText>
                    }
                }
            </td>
        </MudTr>
    </ChildRowContent>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>

@if (_showAdminTools)
{
    <br/>
    @foreach (var kv in _playerPlaces.OrderBy(kv => kv.Value))
    {
        <MudText>@kv.Key - @kv.Value</MudText>
    }
}
<br/>
<MudButton OnClick=@(()=>NavManager.NavigateTo($"/Tournament/{TournamentId}/Qualifiers")) Variant="Variant.Filled">View Qualifiers</MudButton>
<br/>
@if (_myRole == TournamentRole.HeadTournamentOrganizer)
{
    
    <MudButton OnClick=@(()=>NavManager.NavigateTo($"/Tournament/{TournamentId}/Admin")) Variant="Variant.Filled">Admin Page</MudButton>
}
<br/>

<MudDialog @bind-Visible="_showMatchDialog">
    <DialogContent>
        @if (_currentMatch != null)
        {
            <MatchOverview MatchName="_currentMatch.Value" TournamentId="TournamentId" MyRole="_myRole" SettingOptions="_chartPullSettings.Keys"></MatchOverview>
        }
    </DialogContent>
    <DialogActions>
        @if (_myRole != null && _currentMatch != null)
        {
            <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.AddAlert" OnClick="()=>PingMatch(_currentMatch.Value)">Ping Match</MudButton>
        }
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
<MudDialog @bind-Visible="_showNotesPopup">
    <DialogContent>
        @if (_notesMatch != null)
        {
            <MudGrid>
                @foreach (var player in _notesMatch.Players.Where(p => _players.ContainsKey(p) && !string.IsNullOrWhiteSpace(_players[p].Notes)))
                {
                    <MudItem xs="12">
                        <MudText>@player - @_players[player].Notes</MudText>
                    </MudItem>
                }
            </MudGrid>
        }
    </DialogContent>
    <DialogActions>
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showNotesPopup = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
<MudDialog @bind-Visible="_showMatchLinkDialog">
    <DialogContent>
        <MudGrid>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_fromMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"From Match")
                                 SearchFunc="@((s,c) => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_toMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"To Match")
                                 SearchFunc="@((s,c) => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudCheckBox T="bool" @bind-Value="_winners" Label="Winners"></MudCheckBox>
            </MudItem>
            <MudItem xs="12">
                <MudNumericField @bind-Value="_linkPlayers" Min="1" Max="100" Label="Players" HideSpinButtons="true"></MudNumericField>
            </MudItem>
            <MudItem xs="12">
                <MudNumericField @bind-Value="_skipCount" Min="0" Max="100" Label="Skip Count (I.E if targetting 2nd place but not 1st)"></MudNumericField>
            </MudItem>
        </MudGrid>
    </DialogContent>        <DialogActions>
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateLink">Save</MudButton>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchLinkDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>

<style>
    #rotateThumb {
        display:none;
    }
    #pivotLine {
        display:none;
    }
    .e-diagram-resize-handle {
        display:none;
    }


</style>
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject ISnackbar Snackbar;
@inject ITournamentRepository Tournaments;
@inject NavigationManager NavManager;
@code
{

    [Parameter]
    [SupplyParameterFromQuery(Name = "TournamentId")]
    public Guid TournamentId { get; set; }

    private string _bulkCreateType = "Pools";
    private IDictionary<string, RandomSettings> _chartPullSettings = new Dictionary<string, RandomSettings>(StringComparer.OrdinalIgnoreCase);
    private RandomSettings _currentSettings = new();
    private string _currentRandomName = string.Empty;
    private bool _showAddRandomDialog = false;
    private bool _showAddMatchDialog = false;
    private bool _showMatchDialog = false;
    private bool _showMatchLinkDialog = false;
    private User? _user;
    private int _chartCount = 3;
    private Guid _showingChart = Guid.Empty;
    private Name? _showingPlayer;
    private MatchView? _notesMatch;
    private TournamentRole? _myRole;
    private IEnumerable<UserTournamentRole> _userRoles = Array.Empty<UserTournamentRole>();
    private bool _showNotesPopup;
    private bool _spectatorMode = false;
    private string _searchedPlayer = string.Empty;
    private string _pointsByPlace = "";
    private string _randomSettings = string.Empty;
    private string _fromMatch = string.Empty;
    private int _h2hPlayerCount = 16;
    private string _toMatch = string.Empty;
    private int _linkPlayers = 1;
    private bool _winners = true;
    private string _matchName = string.Empty;
    private int _lowestSeed = 1;
    private int _skipCount = 0;
    private bool _showDiagram = false;

    private void SetBulkCreateType(string type)
    {
        _bulkCreateType = type;
        if (type == "Pools")
        {
            SetRoundCount(4);
        }
        else
        {
            SetHeadToHeadPlayerCount(16);
        }
    }
    private static readonly BasicShape _matchShape = new BasicShape()
    {
        Type = NodeShapes.Basic,
        Shape = NodeBasicShapes.Rectangle
    };

    public SfDiagramComponent Diagram;

    private void OnCreated()
    {

        Diagram.BringIntoView(new DiagramRect(0, 0, 500, 300));
    }

    private PointPort rightPort = new PointPort { ID = "rightPort", Offset = new DiagramPoint { X = 1, Y = .5 }, Visibility = PortVisibility.Connect };
    private PointPort leftPort = new PointPort { ID = "leftPort", Offset = new DiagramPoint { X = 0, Y = 0.5 }, Visibility = PortVisibility.Connect };
    private void OnNodeCreating(IDiagramObject obj)
    {
        var node = obj as Node;
        node.Shape.Type = Syncfusion.Blazor.Diagram.NodeShapes.Basic;
        (node.Shape as BasicShape).Shape = NodeBasicShapes.Rectangle;
        node.Style.StrokeColor = "#024249";
        node.Constraints = NodeConstraints.Default & ~NodeConstraints.Drag & ~NodeConstraints.Delete & ~NodeConstraints.Resize;
        node.Annotations[0].Style.Color = "White";
        node.Annotations[0].Margin = new DiagramThickness() { Left = 0, Right = 0 };
        node.Ports = new DiagramObjectCollection<PointPort>(new[] { leftPort, rightPort });
    }

    // Defines default values for Connector object
    private void OnConnectorCreating(IDiagramObject obj)
    {
        var con = obj as Connector;

        con.Constraints = ConnectorConstraints.None;
        con.TargetDecorator = new DecoratorSettings() { Shape = DecoratorShape.Arrow, Style = new ShapeStyle() { Fill = "#024249", StrokeColor = "#024249" } };
        con.Style = new ShapeStyle() { StrokeColor = "#6d6d6d", StrokeWidth = 2 };
        con.Type = ConnectorSegmentType.Bezier;
    }

    private void OnKanbanDialogOpen(DialogOpenEventArgs<MatchCard> args)
    {
        args.Cancel = true;
        if (args?.Data?.MatchName == null)
        {
            return;
        }
        ViewMatch(args.Data.MatchName);
    }

    private DiagramObjectCollection<Connector> ConnectorCollection = new DiagramObjectCollection<Connector>();
    private DiagramObjectCollection<Node> NodeCollection = new DiagramObjectCollection<Node>();
    private Name? _currentMatch;

    private IEnumerable<MatchView> InProgressMatches => _matches.Values.Where(m => m.State is MatchState.InProgress or MatchState.Finalizing)
        .OrderByDescending(m => m.State).ThenBy(m => m.MatchOrder);

    private IEnumerable<MatchView> WarmingUpMatches => _matches.Values.Where(m => m.State == MatchState.Ready && !string.IsNullOrWhiteSpace(m.Machine))
        .OrderByDescending(m => m.MatchOrder);

    private IEnumerable<MatchView> StandbyMatches => _matches.Values.Where(m => m.State == MatchState.Ready && string.IsNullOrWhiteSpace(m.Machine))
        .OrderByDescending(m => m.MatchOrder);

    private IEnumerable<MatchView> CardDrawing => _matches.Values.Where(m => m.State == MatchState.CardDraw)
        .OrderByDescending(m => m.MatchOrder);

    private string _currentPhase = string.Empty;

    private async Task PingMatch(Name matchName)
    {
        await Mediator.Send(new PingMatchCommand(TournamentId, matchName));
    }

    private async Task SelectionChanged(SelectionChangedEventArgs arg)
    {
        if (arg.NewValue.Count() > 1)
        {
            return;
        }
        var node = arg.NewValue[0] as Node;
        if (node == null && !_matches.ContainsKey(node.ID))
        {
            return;
        }

        ViewMatch(node.ID);

    }

    private bool isMobileDevice = false;
    private IEnumerable<MatchView> UpcomingMatches => _matches.Values.Where(m => m.State is MatchState.NotStarted).OrderBy(m => m.MatchOrder);
    private IEnumerable<MatchView> CompletedMatches => _matches.Values.Where(m => m.State is MatchState.Completed).OrderBy(m => m.MatchOrder);
    private IEnumerable<MatchView> ReadyToCardDrawMatches => UpcomingMatches.Where(m => m.PhaseName == _currentPhase && !m.Players.Any(p => p.ToString().StartsWith("Unknown "))).OrderBy(m => m.MatchOrder);
    private IDictionary<string, string> _songImages = new Dictionary<string, string>();

    private bool _showAdminTools = false;
    private IDictionary<string, MatchView> _matches = new Dictionary<string, MatchView>();
    private ICollection<MatchLink> _matchLinks = new List<MatchLink>();
    private readonly ICollection<Name> _tooManyLinks = new List<Name>();
    private readonly ICollection<Name> _notEnoughLinks = new List<Name>();
    private readonly ICollection<string> _otherProblems = new List<string>();
    private string _phaseName = "";
    private bool _linksChecked = false;
    private Name TournamentName { get; set; } = "...";
    private bool _showBulkCreate = false;
    private int _playersPerMatch = 4;
    private int _matchesPerRound = 2;
    private int _rounds = 1;
    private int _winnersProgressCount = 1;
    private bool _isDoubleElimination = false;
    private Name[] _roundSettings = new Name[] { "Not Set" };
    private bool _bulkCreating = false;

    private sealed record MatchCard(string MatchName, string Status, string[] Players);

    private IEnumerable<MatchCard> MatchCards => _matches.Values
        .OrderBy(m=>m.MatchOrder).Select(m => new MatchCard(
        m.MatchName, m.PhaseName.ToString()==_currentPhase&&
        m.State == MatchState.NotStarted && m.Players.All(p => !p.ToString().StartsWith("Unknown ")) ? "Ready to Draw" : m.State.ToString(),
        m.Players.Select(n=>n.ToString()).Prepend("__________________").Prepend(m.MatchName.ToString()).ToArray()));

    private void SetPlayersPerMatch(int playerCount)
    {
        _playersPerMatch = playerCount;
        _pointsByPlace = playerCount <= 2 ? "" : string.Join(",", Enumerable.Range(1, playerCount).Reverse());
    }


    private async Task BulkCreate()
    {
        _bulkCreating = true;
        if (_bulkCreateType != "Pools")
        {
            await BulkCreateHeadToHead();
            Snackbar.Add("Matches Created!", Severity.Success);
            _showBulkCreate = false;
            _bulkCreating = false;
            return;
        }
        var winnersLabel = _isDoubleElimination ? " Winners" : "";
        var losersLabel = _isDoubleElimination ? " Losers" : "";
        var nextOrder = _matches.Any() ? _matches.Max(m => m.Value.MatchOrder) + 1 : 0;

        var places =
            string.IsNullOrWhiteSpace(_pointsByPlace) ? null
                : _pointsByPlace.Split(",").Select(s => s.Trim())
                    .Select(int.Parse).ToArray();
        var seedsPerMatch = _playersPerMatch - _winnersProgressCount;
        var baseSeed= _lowestSeed;
        for (var currentRound = 0; currentRound < _rounds; currentRound++)
        {

            baseSeed -= (currentRound == 0 ? _playersPerMatch : seedsPerMatch) * _matchesPerRound;
            var settings = _roundSettings[currentRound];
            for (var currentMatch = 0; currentMatch < _matchesPerRound; currentMatch++)
            {
                var matchName = $"{_phaseName}{winnersLabel} Round {currentRound + 1} Match {currentMatch + 1}";
                var unknown = 1;
                var currentDirection = 1;
                var currentMultiplier = 0;
                var players = new List<Name>();
                foreach (var player in Enumerable.Range(1, _playersPerMatch))
                {
                    if (currentRound != 0 && player > seedsPerMatch)
                    {
                        players.Add($"Unknown {unknown++}");
                        continue;
                    }
                    var seed = baseSeed + _matchesPerRound * currentMultiplier + (currentMatch) * currentDirection + (currentDirection == 1 ? 1 : 0);
                    players.Add($"Seed {seed}");
                    if (currentDirection == 1)
                    {
                        currentMultiplier+=2;
                    }
                    currentDirection *= -1;
                }

                await Mediator.Send(new UpdateMatchCommand(TournamentId, new MatchView(matchName,
                    _phaseName,
                    nextOrder++,
                    _chartCount,
                    settings,
                    MatchState.NotStarted,
                    players.ToArray(), Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    players.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
                    players.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
                    players.ToArray(), currentRound + 1, "", places
                    )));
                if (currentRound > 0)
                {
                    var previousMatch = $"{_phaseName}{winnersLabel} Round {currentRound} Match {currentMatch + 1}";

                    var link = new MatchLink(Guid.NewGuid(),previousMatch, matchName, true, _winnersProgressCount,0);
                    await Mediator.Send(new CreateMatchLinkCommand(TournamentId, link));
                    foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == link.FromMatch && ml.ToMatch == link.ToMatch))
                    {
                        _matchLinks.Remove(existingLink);
                    }
                    _matchLinks.Add(link);
                }
                if (!_isDoubleElimination) continue;

                var losersMatchName = $"{_phaseName}{losersLabel} Round {currentRound + 1} Match {currentMatch + 1}";
                var lPlayers = Enumerable.Range(0, currentRound == 0 ? _playersPerMatch - 1 : _playersPerMatch).Select(c => Name.From($"Unknown {c}")).ToArray();
                await Mediator.Send(new UpdateMatchCommand(TournamentId, new MatchView(losersMatchName,
                    _phaseName,
                    nextOrder++,
                    _chartCount,
                    settings,
                    MatchState.NotStarted,
                    lPlayers, Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    lPlayers.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
                    lPlayers.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
                    lPlayers, currentRound + 1, "", places
                    )));
                if (currentRound > 0)
                {
                    var previousMatch = $"{_phaseName}{losersLabel} Round {currentRound} Match {currentMatch + 1}";

                    var link = new MatchLink(Guid.NewGuid(),previousMatch, losersMatchName, true, _winnersProgressCount,0);
                    await Mediator.Send(new CreateMatchLinkCommand(TournamentId, link));
                    foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == link.FromMatch && ml.ToMatch == link.ToMatch))
                    {
                        _matchLinks.Remove(existingLink);
                    }
                    _matchLinks.Add(link);
                }

                var winnersToLosers = new MatchLink(Guid.NewGuid(), matchName, losersMatchName, false, _playersPerMatch - _winnersProgressCount, 0);
                await Mediator.Send(new CreateMatchLinkCommand(TournamentId, winnersToLosers));
                foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == winnersToLosers.FromMatch && ml.ToMatch == winnersToLosers.ToMatch))
                {
                    _matchLinks.Remove(existingLink);
                }
                _matchLinks.Add(winnersToLosers);

            }
        }
        _bulkCreating = true;
        Snackbar.Add("Matches Created!", Severity.Success);
        _showBulkCreate = false;
    }

    private void SetHeadToHeadPlayerCount(int count)
    {
        _h2hPlayerCount = count;
        var nextSquare = NearestPowerOf2(count);
        SetRoundCount((int)Math.Sqrt(nextSquare)+1);
    }
    private void SetRoundCount(int rounds)
    {
        if (rounds < _rounds)
        {
            _roundSettings = _roundSettings.Take(rounds).ToArray();
        }
        if (rounds > _rounds)
        {
            _roundSettings = _roundSettings.Concat(Enumerable.Repeat((Name)"Not Set", rounds - _rounds)).ToArray();
        }
        _rounds = rounds;
    }

    public void ShowNotes(MatchView match)
    {
        _notesMatch = match;
        _showNotesPopup = true;
    }

    private void OpenBulkAddMatchDialog()
    {
        _showBulkCreate = true;
        _phaseName = string.Empty;
        SetRoundCount(1);
        _isDoubleElimination = false;
        _playersPerMatch = 4;
        _chartCount = 3;
    }

    private void SearchForPlayer(string player)
    {
        _searchedPlayer = player;

        foreach (var node in NodeCollection)
        {
            var match = _matches[node.ID];
            node.Style.Fill = ColorOfMatch(match);
        }

        StateHasChanged();
    }

    private string ColorOfMatch(MatchView match) =>
        !string.IsNullOrWhiteSpace(_searchedPlayer) && match.Players.Any(p => p.Contains(_searchedPlayer)) ?
            Colors.Yellow.Darken1 :
            match.State switch

            {
                MatchState.NotStarted => Colors.Gray.Darken1,
                MatchState.CardDraw => Colors.Green.Darken1,
                MatchState.Ready => Colors.Green.Darken1,
                MatchState.InProgress=>Colors.Green.Darken1,
                MatchState.Finalizing=>Colors.Green.Darken1,
                MatchState.Completed=>Colors.Cyan.Default,
                _ => Colors.Gray.Darken1

            };
    private async Task CreateLink()
    {
        var link = new MatchLink(Guid.NewGuid(), _fromMatch, _toMatch, _winners, _linkPlayers, _skipCount);
        if (link.FromMatch == link.ToMatch)
        {
            return;
        }
        await Mediator.Send(new CreateMatchLinkCommand(TournamentId, link));
        _matchLinks.Add(link);
        _showMatchLinkDialog = false;
    }

    private async Task DeleteLink(MatchLink link)
    {
        await Mediator.Send(new DeleteMatchLinkCommand(link.Id));
        _matchLinks.Remove(link);
    }

    private void FindInvalidMatches()
    {

        _tooManyLinks.Clear();
        _notEnoughLinks.Clear();
        _otherProblems.Clear();
        var linkDict = _matchLinks
            .Where(l=>_matches[l.FromMatch].State is not MatchState.Completed)
            .GroupBy(l => l.ToMatch.ToString()).ToDictionary(g => g.Key, g => g.ToArray());

        foreach (var match in _matches.Values)
        {
            var progressingCount = linkDict.TryGetValue(match.MatchName, out var value)?value.Sum(l => l.PlayerCount):0;
            var existingCount = match.Players.Count(p => !p.ToString().StartsWith("Unknown "));
            if (progressingCount + existingCount < match.Players.Length)
            {
                _notEnoughLinks.Add(match.MatchName);
            }
            if (progressingCount + existingCount > match.Players.Length)
            {
                _tooManyLinks.Add(match.MatchName);
            }
        }
        var seedGroups = _matches.Values.SelectMany(m => m.Players.Where(p=>p.ToString().StartsWith("Seed ")).Select(p => (p, m)))
            .GroupBy(kv => kv.p).ToDictionary(g => g.Key, g => g.ToArray());
        foreach (var seedGroup in seedGroups
            .Where(g => g.Value.Count() > 1))
        {
            _otherProblems.Add(string.Join(", ", seedGroup.Value.Select(m => m.m.MatchName.ToString()) + " both have " + seedGroup.Key));
        }
        foreach (var player in _players.Values)
        {
            if (!seedGroups.ContainsKey("Seed " + player.Seed))
            {
                _otherProblems.Add($"{player.Name} Currently is missing a target Seed position ({player.Seed})");
            }
        }
        var playerSeeds = _players.Values.GroupBy(p => p.Seed).ToDictionary(g=>g.Key,g=>g.ToArray());
        foreach (var kv in playerSeeds)
        {
            if (kv.Value.Count() > 1)
            {
                _otherProblems.Add($"Seed {kv.Key} has more than 1 player: " + string.Join(", ", kv.Value.Select(p => p.Name.ToString())));
            }
            foreach (var seedName in seedGroups.Keys)
            {
                var seed = int.Parse(seedName.ToString().Split(" ").Last());
                if (!playerSeeds.ContainsKey(seed))
                {
                    _otherProblems.Add("There is no player with seed "+seed);
                }
            }
        }
        _linksChecked = true;
    }
    public void OpenAddRandomDialog()
    {
        _currentSettings = new();
        _showAddRandomDialog = true;
        _currentRandomName = string.Empty;
    }
    public void OpenAddMatchDialog()
    {
        _matchName = string.Empty;
        _showAddMatchDialog = true;
    }

    private void ViewMatch(Name matchName)
    {
        _currentMatch = matchName;
        _showMatchDialog = true;
    }

    private IDictionary<Name, int> _playerPlaces = new Dictionary<Name, int>();
    private void CalculateLeaderboard()
    {
        var place = _matches.Values.SelectMany(m => m.Players).Distinct().Count();
        var phases = _matches.Values.GroupBy(m => m.PhaseName).OrderBy(g => g.Min(m => m.MatchOrder));
        var matchLinks = _matchLinks.GroupBy(l => l.FromMatch).ToDictionary(g => g.Key, g => g.ToArray());
        foreach (var phase in phases)
            foreach (var round in phase.GroupBy(m => m.Round).OrderBy(g => g.Key))
            {
                var nonProgressing = new Dictionary<Name, int>();
                var matches = round.ToArray();
                if (matches.Any(m => m.MatchName.Contains("Loser")))
                {
                    matches = matches.Where(m => m.MatchName.Contains("Loser")).ToArray();
                }
                foreach (var match in matches)
                {
                    var links = matchLinks.TryGetValue(match.MatchName, out var l) ? l : Array.Empty<MatchLink>();
                    var players = links.SelectMany(link => link.IsWinners
                        ? match.FinalPlaces.Skip(link.Skip).Take(link.PlayerCount)
                        : match.FinalPlaces.Reverse().Skip(link.Skip).Take(link.PlayerCount)).Distinct();
                    foreach (var player in players)
                    {
                        nonProgressing.TryAdd(player, 0);
                        nonProgressing[player] += match.Points[player].Sum();
                    }
                }
                foreach (var pointGroup in nonProgressing.GroupBy(kv => kv.Value).OrderBy(g=>g.Key))
                {
                    var total = 0;
                    foreach (var player in pointGroup.Where(p=>!_playerPlaces.ContainsKey(p.Key)))
                    {
                        if (player.Key == "HDS")
                        {
                        //
                        }
                        _playerPlaces[player.Key] = place;
                        total++;
                    }
                    place -= total;
                }
            }
    }

    private IDictionary<string, MatchPlayer> _players = new Dictionary<string, MatchPlayer>();
    private int _round = 1;
    private bool IsPointsByPlaceValid => string.IsNullOrWhiteSpace(_pointsByPlace) || (_pointsByPlace.Split(",").Select(s => s.Trim()).All(s => int.TryParse(s, out var _))
    && _pointsByPlace.Split(",").Count()==_playersPerMatch);
    private async Task CreateMatch()
    {
        var players = Enumerable.Range(0, _playersPerMatch).Select(c => Name.From($"Unknown {c}")).ToArray();
        var places =
            string.IsNullOrWhiteSpace(_pointsByPlace)?null
            :_pointsByPlace.Split(",").Select(s => s.Trim())
            .Select(int.Parse).ToArray();
        await Mediator.Send(new UpdateMatchCommand(TournamentId, new MatchView(_matchName,
            _phaseName,
            _matches.Any()?_matches.TryGetValue(_matchName, out var existingMatch)?existingMatch.MatchOrder:_matches.Max(m=>m.Value.MatchOrder)+1:0,
            _chartCount,
            _randomSettings, MatchState.NotStarted,
            players, Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
            players,_round,"",places
            )));
        _showAddMatchDialog = false;
    }

    private void ProjectMatchOntoNode(MatchView match, Node node)
    {
        var players=string.Join("\n", match.Players.Select(p=>p.Contains("Unknown ")?"TBD":p.ToString()));
        if (node.Annotations.Any())
        {

            node.Annotations[0].Content = players;
        }
        else
        {
            node.Annotations = new DiagramObjectCollection<ShapeAnnotation>()
            {
                new ShapeAnnotation
                {
                    Content = players
                }
            };
        }
        node.Style.Fill = ColorOfMatch(match);
    }
    private void MatchUpdated(MatchUpdatedEvent e)
    {
        if (e.TournamentId != TournamentId)
        {
            return;
        }
        _matches[e.NewState.MatchName] = e.NewState;
        UpdateCurrentPhase();
        RecalculateStates();
        if (_spectatorMode)
        {
            ViewMatch(e.NewState.MatchName);
        }
        var node = NodeCollection.FirstOrDefault(n => n.ID == e.NewState.MatchName);
        if (node != null)
        {
            ProjectMatchOntoNode(e.NewState, node);

        }
        InvokeAsync(StateHasChanged);
    }

    private void UpdateCurrentPhase()
    {

        _currentPhase = _matches.GroupBy(m => m.Value.PhaseName, m => m.Value).
            OrderBy(g => g.Min(m => m.MatchOrder))
            .Where(g => g.Any(m => m.State < MatchState.Finalizing))
            .Select(g=>g.Key.ToString())
            .FirstOrDefault() ?? "None";
    }

    public async Task SaveRandomSettings()
    {
        if (!Name.TryParse(_currentRandomName, out var name))
        {
            return;
        }
        try
        {
            await Mediator.Send(new GetRandomChartsQuery(_currentSettings));
        }
        catch (Exception e)
        {
            Snackbar.Add(e.Message, Severity.Error);
            return;
        }
        await Mediator.Send(new SaveRandomSettingsCommand(TournamentId, name, _currentSettings));
        _chartPullSettings[name] = _currentSettings;
        _showAddRandomDialog = false;
    }

    private const int MatchHeight = 80;
    private string _showingPhase = "";
    private void RedrawTournament(string phaseName)
    {
        if (_showingPhase != phaseName)
        {
            NodeCollection.Clear();
            ConnectorCollection.Clear();
        }
        _showingPhase = phaseName;
        
        if (string.IsNullOrWhiteSpace(phaseName))
        {
            return;
        }
        var matches = _matches.Where(m => m.Value.PhaseName == phaseName).ToDictionary(m => m.Key, m => m.Value);
        if (!matches.Any())
        {
            return;
        }
        var x = 50;
        var rounds = matches.Values.GroupBy(m => m.PhaseName).OrderBy(g => g.Min(m => m.MatchOrder))
            .SelectMany(phase => phase.GroupBy(m => m.Round).OrderBy(g => g.Key).ToArray())
            .ToArray();

        var largestWinners = rounds.Max(g => g.Count(m => m.MatchName.Contains("Winner")));

        foreach (var round in rounds)
        {
            var winnersY = 50;
            var losersY = (largestWinners + 1) * (MatchHeight + 10) + 50;
            foreach (var match in round.OrderBy(m => m.MatchOrder))
            {
                var height = MatchHeight;
                if (match.Players.Count() > 4)
                {
                    height = MatchHeight + (match.Players.Count() - 4) * 15;
                }
                var node = new Node()
                    {
                        ID = match.MatchName,
                        Shape = _matchShape,
                        OffsetX = x,
                        OffsetY = match.MatchName.Contains("Loser") ? losersY : winnersY,
                        Height = height,
                        Width = 200
                    };
                ProjectMatchOntoNode(match, node);
                var existingNode = NodeCollection.FirstOrDefault(n => n.ID == node.ID);
                if (existingNode != null)
                {
                    NodeCollection.Remove(existingNode);
                }
                NodeCollection.Add(node);
                if (match.MatchName.Contains("Loser"))
                {
                    losersY += height + 10;
                }
                else
                {
                    winnersY += height + 10;
                }
            }
            x += 250;
        }
        foreach (var matchLink in _matchLinks
            .Where(ml=>matches.ContainsKey(ml.FromMatch) && matches.ContainsKey(ml.ToMatch))
            .Where(m => !(m.FromMatch.Contains("Winner") && m.ToMatch.Contains("Loser"))))
        {
            var connector = new Connector()
                {
                    ID = matchLink.Id.ToString(),
                    SourceID = matchLink.FromMatch,
                    TargetID = matchLink.ToMatch,
                    SourcePortID = rightPort.ID,
                    TargetDecorator = new DecoratorSettings() { Shape = DecoratorShape.Arrow, Style = new ShapeStyle() { Fill = "#024249", StrokeColor = "#024249" } },
                    Style = new ShapeStyle() { StrokeColor = "#6d6d6d", StrokeWidth = 2 },

                };

            connector.TargetPortID = leftPort.ID;
            if (_matches[matchLink.FromMatch].PhaseName==_matches[matchLink.ToMatch].PhaseName && _matches[matchLink.FromMatch].Round == _matches[matchLink.ToMatch].Round)
            {
                connector.SourcePortID = leftPort.ID;
            }
            var existing = ConnectorCollection.FirstOrDefault(c => c.ID == connector.ID);
            if (existing != null)
            {
                ConnectorCollection.Remove(existing);
            }
            ConnectorCollection.Add(connector);
        }

    }
    private static int NearestPowerOf2(int n)
    {
        var a = (int)(Math.Log(n) / Math.Log(2));

        if (Math.Abs(Math.Pow(2, a) - n) < .00000000000001)
            return n;

        return (int)Math.Pow(2, a + 1);
    }
    private (int Player1,int Player2)[] Seeding(int numPlayers){

        var rounds = Math.Log(numPlayers)/Math.Log(2)-1;
        var pls = new int[]{1,2};
        for(var i=0;i<rounds;i++){
            pls = NextLayer(pls);
        }
        return pls.Select((place, index) => (place,index))
            .GroupBy(g => (int)Math.Floor(g.index / 2.0))
            .Select(g => (g.MinBy(k => k.place).place,g.MaxBy(k => k.place).place))
            .ToArray();

        int[] NextLayer(int[] pls){
            var result=new List<int>();
            var length = pls.Length*2+1;
            foreach (var d in pls)
            {
                result.Add(d);
                result.Add(length-d);
            }
            return result.ToArray();
        }
    }

    private bool _showSkipSeedCheck = false;
    private async Task PopulateSeeds(bool skipCheck)
    {
        FindInvalidMatches();
        if (!skipCheck && _otherProblems.Any())
        {
            _showSkipSeedCheck = true;
            Snackbar.Add("Please resolve identified seeding problems before populating seeds", Severity.Error);
            return;
        }
        _showSkipSeedCheck = false;
        var seeds = _players.Values.GroupBy(p=>p.Seed).ToDictionary(g=>g.Key,g=>g.First());
        foreach (var match in _matches.Values)
        {
            var needsSaved = false;
            for (var i = 0; i < match.Players.Length; i++)
            {
                if (!match.Players[i].ToString().StartsWith("Seed "))
                {
                    continue;
                }
                var number = int.Parse(match.Players[i].ToString().Split(" ").Last());
                match.Players[i] = seeds[number].Name;
                needsSaved = true;
            }
            if (needsSaved)
            {
                await Mediator.Send(new UpdateMatchCommand(TournamentId, match));
            }
        }
        Snackbar.Add("Seeded Players Placed", Severity.Success);
    }
    private async Task BulkCreateHeadToHead()
    {
        var players = _h2hPlayerCount;
        var rootNode = new MatchNode();
        var nextFullBracket = NearestPowerOf2(players);
        for (var i = 0; i < nextFullBracket - 2; i++)
        {
            rootNode.AddNode();
        }
        var seeds = Seeding(nextFullBracket);
        var leafs = rootNode.Leaves().ToArray();
        for (var i = 0; i < leafs.Length; i++)
        {
            var leaf = leafs[i];
            leaf.Player1Seed = seeds[i].Player1;
            leaf.Player2Seed = seeds[i].Player2;
        }
        var names = rootNode.GetMatchNames().ToArray();
        var max = names.Max(e=>e.round);
        var rounds = rootNode.GetMatchNames().GroupBy(n => n.round)
            .ToDictionary(g => max-g.Key+1, g => g.ToArray());

        foreach (var round in rounds)
        {
            if (round.Value.Count() == 1)
            {
                round.Value.Single().match.Id = $"{_phaseName} Winners Finals";
                continue;
            }        
            var matchNumber = 1;
            foreach (var match in round.Value)
            {
                match.match.Id = $"{_phaseName} Round {round.Key} Winners Match {matchNumber}";
                matchNumber++;
            }
        }
        var matches = new List<MatchView>();
        var matchLinks = new List<MatchLink>();
        var totalOrder = _matches.Any() ? _matches.Values.Max(m => m.Round) : 1;
        var losers = new List<List<MatchNode>>();
        var ordering = 1;
        if (_isDoubleElimination)
        {
            foreach (var round in rounds.OrderBy(r => r.Key))
            {
                if (round.Key == 1)
                {
                    var firstRound = new List<MatchNode>();
                    var matchNum = 1;
                    foreach (var winnersPair in round.Value.Select((place, index) => (place, index))
                        .GroupBy(g => (int)Math.Floor(g.index / 2.0))
                        .OrderBy(g => g.Key))
                    {
                        var match1 = winnersPair.First().place.match;
                        var match2 = winnersPair.Last().place.match;
                        var nextMatch = new MatchNode();
                        nextMatch.Id = $"{_phaseName} Round {round.Key - 1} Losers Match {matchNum++}";
                        nextMatch.Left = match1;
                        nextMatch.Right = match2;
                        match1.LosersProgression = nextMatch;
                        match2.LosersProgression = nextMatch;
                        nextMatch.Round = round.Key;
                        firstRound.Add(nextMatch);
                    }
                    losers.Add(firstRound);
                    continue;
                }
                var lastRound = losers.Last();
                if (lastRound.Count > round.Value.Length)
                {
                    var midRound = new List<MatchNode>();

                    var matchNum = 1;
                    for (var i = 0; i < lastRound.Count / 2; i++)
                    {
                        var nextMatch = new MatchNode();
                        nextMatch.Id =  $"{_phaseName} Round {round.Key - 1}.5 Losers Match {matchNum++}";
                        nextMatch.Left = lastRound[i * 2];
                        nextMatch.Right = lastRound[i * 2 + 1];
                        lastRound[i * 2].NextMatch = nextMatch;
                        lastRound[i * 2 + 1].NextMatch = nextMatch;
                        nextMatch.Round = round.Key - 1;
                        midRound.Add(nextMatch);
                    }
                    losers.Add(midRound);
                    lastRound = midRound;
                }
                var losersRound = new List<MatchNode>();
                var ordered = round.Value.Select((m, i) => (m.match, i))
                    .OrderByDescending(k => k.i * ordering).Select(m => m.match).ToArray();
                ordering *= -1;
                var halfRoundMatchNum = 1;
                for (var i = 0; i < ordered.Length; i++)
                {
                    var winnersMatch = ordered[i];

                    var nextMatch = new MatchNode
                        {
                            Left = winnersMatch,
                            Right = lastRound[i]
                        };

                    nextMatch.Id =ordered.Length==1? $"{_phaseName} Losers Finals" :$"{_phaseName} Round {round.Key} Losers Match {halfRoundMatchNum++}";
                    nextMatch.Round = round.Key;
                    winnersMatch.LosersProgression = nextMatch;
                    lastRound[i].NextMatch = nextMatch;
                    losersRound.Add(nextMatch);
                }
                losers.Add(losersRound);
            }
        }
        rootNode.ResolveAll();
        if (_isDoubleElimination)
        {
            foreach (var lastMatch in losers.Last())
            {
                lastMatch.ResolveAll();
            }
        }
        foreach (var match in losers.SelectMany(l => l)
            .Where(m=>m.Player1Seed<=players && m.Player2Seed<=players))
        {
            matches.Add(new MatchView(match.Id,
                _phaseName, totalOrder,_chartCount,_roundSettings[match.Round-1],
                MatchState.NotStarted,new Name[]{ $"Unknown 1",$"Unknown 2"},Array.Empty<Guid>(),
                Array.Empty<Guid>(),
                Array.Empty<Guid>(),
                new Dictionary<string, PhoenixScore[]>(),
                new Dictionary<string, int[]>(),
                Array.Empty<Name>(),
                match.Round, "", null));
            if (match.NextMatch!=null)
            {
                matchLinks.Add(new MatchLink(Guid.NewGuid(), match.Id,
                    match.NextMatch.Id, true, 1,0));
            }
        }
        var seededPlayers = new HashSet<int>();

        var seedOffset = _lowestSeed;
        foreach (var round in rounds.OrderBy(r=>r.Key))
        {
            foreach (var match in round.Value.Where(m=>m.match.Player1Seed<=players && m.match.Player2Seed<=players))
            {
                var player1Name = "Unknown 1";
                var player2Name = "Unknown 2";
                if (!seededPlayers.Contains(match.match.Player1Seed))
                {
                    seededPlayers.Add(match.match.Player1Seed);
                    player1Name = $"Seed {seedOffset+match.match.Player1Seed}";
                }
                if (!seededPlayers.Contains(match.match.Player2Seed))
                {
                    seededPlayers.Add(match.match.Player2Seed);
                    player1Name = $"Seed {seedOffset+match.match.Player2Seed}";
                }
                matches.Add(new MatchView(match.match.Id,
                     _phaseName, totalOrder, _chartCount, _roundSettings[round.Key-1],
                    MatchState.NotStarted, new Name[] { player1Name, player2Name }, Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    Array.Empty<Guid>(),
                    new Dictionary<string, PhoenixScore[]>(),
                    new Dictionary<string, int[]>(),
                    Array.Empty<Name>(),
                    round.Key, "", null));
                if (match.match.NextMatch!=null)
                {

                    matchLinks.Add(new MatchLink(Guid.NewGuid(), match.match.Id,
                        match.match.NextMatch.Id, true, 1,0));
                }
                if (match.match.LosersProgression != null)
                {
                    var firstLosersMatch = match.match.LosersProgression.Player1Seed <= players && match.match.LosersProgression.Player2Seed <= players ?
                        match.match.LosersProgression :
                        match.match.LosersProgression?.NextMatch;
                    if (firstLosersMatch != null)
                    {
                        matchLinks.Add(new MatchLink(Guid.NewGuid(), match.match.Id,
                            firstLosersMatch.Id, false, 1,0));
                    }
                }
                totalOrder++;
            }
        }

        if (_isDoubleElimination)
        {
            var finalRound = matches.Max(m => m.Round) + 1;
            var lastWinners = matches.Where(m=>m.MatchName.Contains("Winner")).OrderByDescending(m => m.Round).ThenByDescending(m => m.MatchOrder).First();
            var lastLosers = matches.Where(m => m.MatchName.Contains("Loser")).OrderByDescending(m => m.Round).ThenByDescending(m => m.MatchOrder).First();
            matches.Add(new MatchView($"{_phaseName} Grand Finals",
                _phaseName,totalOrder,
                _chartCount, _roundSettings[finalRound-1],
                MatchState.NotStarted, new Name[] { "Unknown 1", "Unknown 2" },
                Array.Empty<Guid>(),
                Array.Empty<Guid>(),
                Array.Empty<Guid>(),
                new Dictionary<string, PhoenixScore[]>(),
                new Dictionary<string, int[]>(),
                Array.Empty<Name>(),
                finalRound, "", null));
            matchLinks.Add(new MatchLink(Guid.NewGuid(),lastWinners.MatchName, $"{_phaseName} Grand Finals", true, 1,0));
            matchLinks.Add(new MatchLink(Guid.NewGuid(), lastLosers.MatchName, $"{_phaseName} Grand Finals", true, 1, 0));
        }
        foreach (var match in matches)
        {
            await Mediator.Send(new UpdateMatchCommand(TournamentId, match));
        }
        foreach (var matchLink in matchLinks)
        {
            await Mediator.Send(new CreateMatchLinkCommand(TournamentId, matchLink));
        }

    }

    private sealed class MatchNode
    {
        public MatchNode? Left { get; set; }
        public MatchNode? Right { get; set; }
        public MatchNode? NextMatch { get; set; }
        public MatchNode? LosersProgression { get; set; }
        public string Id { get; set; } = string.Empty;
        public int Player1Seed { get; set; } = -1;
        public int Player2Seed { get; set; } = -1;
        public int Round { get; set; } = -1;

        public MatchNode()
        {

        }

        public MatchNode(MatchNode next)
        {
            NextMatch = next;
        }
        private IEnumerable<(int round, MatchNode match)> GetMatchNames(int depth)
        {

            if (Left != null)
            {
                foreach (var name in Left.GetMatchNames(depth+1))
                {
                    yield return name;
                }
            }
            yield return (depth,this);
            if (Right != null)
            {
                foreach (var name in Right.GetMatchNames(depth+1))
                {
                    yield return name;
                }
            }
        }
        public IEnumerable<(int round, MatchNode match)> GetMatchNames()
        {
            return GetMatchNames(1);
        }
        public void AddNode()
        {
            if (Left == null)
            {
                Left = new MatchNode(this);
                return;
            }
            if (Right == null)
            {
                Right = new MatchNode(this);
                return;
            }

            if (Left.Count() > Right.Count())
            {
                Right.AddNode();
                return;
            }
            Left.AddNode();
        }

        public int Count()
        {
            var count = 1;
            count += Left?.Count() ?? 0;
            count += Right?.Count() ?? 0;
            return count;
        }

        private bool _isResolved = false;
        public void Resolve()
        {
            if (_isResolved)
            {
                return;
            }
            _isResolved = true;
            if (NextMatch != null)
            {
                var progressingSeed = Player1Seed < Player2Seed ? Player1Seed : Player2Seed;
                if (NextMatch.Player1Seed == -1)
                {
                    NextMatch.Player1Seed = progressingSeed;
                }
                else if (NextMatch.Player2Seed == -1)
                {
                    NextMatch.Player2Seed = progressingSeed;
                }
            }
            if (LosersProgression != null)
            {
                var progressingSeed = Player1Seed > Player2Seed ? Player1Seed : Player2Seed;
                if (LosersProgression.Player1Seed == -1)
                {
                    LosersProgression.Player1Seed = progressingSeed;
                }
                else if(LosersProgression.Player2Seed==-1)
                {
                    LosersProgression.Player2Seed = progressingSeed;
                }
            }

        }

        public void ResolveAll()
        {
            Left?.ResolveAll();
            Right?.ResolveAll();
            Resolve();
        }
        public IEnumerable<MatchNode> Leaves()
        {

            if (Left == null && Right == null)
            {
                yield return this;
                yield break;
            }
            if (Left != null)
            {
                foreach (var leaf in Left.Leaves())
                {
                    yield return leaf;
                }
            }
            if (Right != null)
            {
                foreach (var leaf in Right.Leaves())
                {
                    yield return leaf;
                }
            }
        }
        public IEnumerable<MatchNode> All()
        {
            if (Left != null)
            {
                foreach (var node in Left.All())
                {
                    yield return node;
                }
            }
            yield return this;
            if (Right != null)
            {
                foreach (var node in Right.All())
                {
                    yield return node;
                }
            }
        }
        public int MaxDepth()
        {
            var maxDepth = 1;
            if (Left != null)
            {
                maxDepth = Left.MaxDepth() + 1;
            }
            if (Right != null)
            {
                var rightDepth = Right.MaxDepth() + 1;
                if (rightDepth > maxDepth)
                {
                    maxDepth = rightDepth;
                }
            }
            return maxDepth;
        }
    }

    protected override async Task OnInitializedAsync()
    {

        TournamentName = (await Mediator.Send(new GetAllTournamentsQuery()))
            .First(t => t.Id == TournamentId).Name;
        _user = CurrentUser.IsLoggedIn ? CurrentUser.User : null;
        _matches = (await Mediator.Send(new GetAllMatchesQuery(TournamentId))).ToDictionary(m => m.MatchName.ToString());
        _chartPullSettings = (await Mediator.Send(new GetAllRandomSettingsQuery(TournamentId))).ToDictionary(s => (string) s.name, s => s.settings);
        _matchLinks = (await Mediator.Send(new GetMatchLinksQuery(TournamentId))).ToList();
        _players = (await Mediator.Send(new GetMatchPlayersQuery(TournamentId))).ToDictionary(m => m.Name.ToString(), StringComparer.OrdinalIgnoreCase);
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).ToDictionary(c => c.Id);
        _songImages = _charts.Values.GroupBy(c => c.Song.Name.ToString()).ToDictionary(g => g.Key, g => g.Select(c => c.Song.ImagePath.ToString()).First(),StringComparer.OrdinalIgnoreCase);
        _userRoles = await Mediator.Send(new GetTournamentRolesQuery(TournamentId));
        _myRole = !CurrentUser.IsLoggedIn ? null : CurrentUser.IsLoggedInAsAdmin ? TournamentRole.HeadTournamentOrganizer : _userRoles.FirstOrDefault(e => e.UserId == _user?.Id)?.Role;


        
        UpdateCurrentPhase();
        RecalculateStates();
        MainLayout.MatchUpdated += (o, e) => MatchUpdated(e);
        if (_myRole == TournamentRole.HeadTournamentOrganizer)
        {
            try
            {
                CalculateLeaderboard();
            }
            catch (Exception)
            {
                //Nothing
            }
        }
        RedrawTournament(_currentPhase);
        StateHasChanged();
    }

    private IEnumerable<ChartStats> _chartStats = Array.Empty<ChartStats>();
    private IEnumerable<PlayerStats> _playerStats = Array.Empty<PlayerStats>();
    private IEnumerable<SongStats> _songStats = Array.Empty<SongStats>();
    private IDictionary<string, ICollection<PlayerChartScore>> _playerScores = new Dictionary<string, ICollection<PlayerChartScore>>();
    private IDictionary<Guid, IDictionary<string, PhoenixScore>> _chartLeaderboards = new Dictionary<Guid, IDictionary<string, PhoenixScore>>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private sealed record ChartStats(Guid ChartId, int MatchCount, int VetoCount, int ProtectCount, int TotalPlayCount, PhoenixScore AverageScore)
    {

    }

    private sealed record SongStats(Name SongName, int MatchCount, int VetoCount, int ProtectCount, int TotalPlayCount)
    {

    }
    private sealed record PlayerStats(Name Player, int MatchCount, int ChartsPlayed, PhoenixScore AverageScore)
    {

    }

    private sealed record PlayerChartScore(Guid ChartId, PhoenixScore Score)
    {

    }
    private void RecalculateStates()
    {
        var chartCounts = new Dictionary<Guid, int>();
        var chartVetoCounts = new Dictionary<Guid, int>();
        var chartProtectCounts = new Dictionary<Guid, int>();
        var chartPlayerCounts = new Dictionary<Guid, int>();
        var chartScoreTotal = new Dictionary<Guid, long>();
        var playerMatches = new Dictionary<string, int>();
        var playerChartCount = new Dictionary<string, int>();
        var playerScoreTotal = new Dictionary<string, long>();
        var playerScores = new Dictionary<string, ICollection<PlayerChartScore>>(StringComparer.OrdinalIgnoreCase);
        var chartLeaderboards = new Dictionary<Guid, IDictionary<string, PhoenixScore>>();

        foreach (var match in CompletedMatches)
        {
            foreach (var chartId in match.ActiveCharts.Concat(match.ProtectedCharts).Concat(match.VetoedCharts).Distinct())
            {
                    
                chartCounts.TryAdd(chartId, 0);
                chartPlayerCounts.TryAdd(chartId, 0);
                chartScoreTotal.TryAdd(chartId, 0);
                chartVetoCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartProtectCounts.TryAdd(chartId, 0);
                chartCounts.TryAdd(chartId, 0);
                chartVetoCounts.TryAdd(chartId, 0);
                chartLeaderboards.TryAdd(chartId, new Dictionary<string, PhoenixScore>(StringComparer.OrdinalIgnoreCase));
            }
            for (var i = 0; i < match.ActiveCharts.Length; i++)
            {
                var chartId = match.ActiveCharts[i];

                chartCounts[chartId]++;
                if (match.Scores.All(s => s.Value[i] <=1)) continue;
                chartPlayerCounts[chartId] += match.Scores.Count(s => s.Value[i]>1);
                chartScoreTotal[chartId] += match.Scores.Sum(kv => kv.Value[i]);
                foreach (var player in match.Players)
                {
                    if (match.Scores[player][i] <=1)
                    {
                        continue;
                    }
                    playerScores.TryAdd(player, new List<PlayerChartScore>());
                    playerScores[player].Add(new PlayerChartScore(chartId, match.Scores[player][i]));
                    if (!chartLeaderboards[chartId].ContainsKey(player) || match.Scores[player][i] > chartLeaderboards[chartId][player])
                    {
                        chartLeaderboards[chartId][player] = match.Scores[player][i];
                    }
                }
            
            }
            foreach (var chartId in match.ProtectedCharts)
            {
                chartProtectCounts[chartId]++;
            }
            foreach (var chartId in match.VetoedCharts)
            {
                chartCounts[chartId]++;
                chartVetoCounts[chartId]++;
            }
            foreach (var player in match.Players)
            {
                
                playerMatches.TryAdd(player, 0);
                playerMatches[player]++;
                playerChartCount.TryAdd(player, 0);
                playerChartCount[player] += match.Scores[player].Count(s => s >1);
                playerScoreTotal.TryAdd(player, 0);
                playerScoreTotal[player] += match.Scores[player].Sum(s => (int)s);
            }
        }
        _playerScores = playerScores;
        _playerStats = playerMatches.Keys.Select(player => new PlayerStats(player, playerMatches[player], playerChartCount[player],playerChartCount[player]>0? PhoenixScore.From((int)(playerScoreTotal[player] / playerChartCount[player])):0)).ToArray();
        _chartLeaderboards = chartLeaderboards;
        _chartStats= chartCounts.Keys.Select(chartId => new ChartStats(chartId, chartCounts[chartId], chartVetoCounts[chartId], chartProtectCounts[chartId], chartPlayerCounts[chartId], chartPlayerCounts[chartId] > 0 ? PhoenixScore.From((int)(chartScoreTotal[chartId] / chartPlayerCounts[chartId])) : 0)).ToArray();
        _songStats = _chartStats.GroupBy(c => _charts[c.ChartId].Song.Name.ToString()).Select(g => new SongStats(g.Key, g.Sum(c => c.MatchCount), g.Sum(c => c.VetoCount), g.Sum(c => c.ProtectCount), g.Sum(c => c.TotalPlayCount)));
    }
}
