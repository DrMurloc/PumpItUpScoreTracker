@page "/Eclipse/BracketPoC"
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Views
@using ScoreTracker.Web.Components
@using MediatR
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Events
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Web.Shared
@using System.Text.RegularExpressions

<PageTitle>Eclipse 2023 Brackets</PageTitle>
@if (IsLoggedInAsAdmin)
{
    <MudGrid>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddRandomDialog">Add Randomizer Settings</MudButton>
        </MudItem>
        <MudItem xs="6" sm="4" md="3">
            <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="OpenAddMatchDialog">Add Match</MudButton>
        </MudItem>
    </MudGrid>
    

    <MudDialog @bind-IsVisible="_showAddRandomDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_currentRandomName" Label="Settings Name"></MudTextField>
                </MudItem>
            </MudGrid>
            <RandomizerSettingsConfiguration Settings="_currentSettings"></RandomizerSettingsConfiguration>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="SaveRandomSettings">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddRandomDialog = false">@L["Close"]</MudButton>
        </DialogActions>

    </MudDialog>

    <MudDialog @bind-IsVisible="_showAddMatchDialog">
        <DialogContent>
            <MudGrid>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_playerCount" Label="Player Count"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudTextField T="string" @bind-Value="_matchName" Label="Match Name"></MudTextField>
                </MudItem>
                <MudItem xs="12">
                    <MudNumericField T="int" @bind-Value="_chartCount" Label="Chart Count"></MudNumericField>
                </MudItem>
                <MudItem xs="12">
                    <MudSelect T="string" @bind-Value="_phaseName" Label="Phase">
                        <MudSelectItem T="string" Value=@("Mids")>Mids</MudSelectItem>
                        <MudSelectItem T="string" Value=@("Uppers")>Uppers</MudSelectItem>
                        <MudSelectItem T="string" Value=@("Pros")>Pros</MudSelectItem>
                    </MudSelect>
                </MudItem>
                <MudItem xs="12">
                    <MudSelect @bind-Value="_randomSettings" Label="Random Settings">
                        @foreach (var key in _chartPullSettings.Keys.OrderBy(k=>k))
                        {
                            <MudSelectItem Value="@key">@key</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
            </MudGrid>
        </DialogContent>
        <DialogActions>
            <MudSpacer></MudSpacer>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateMatch">Save</MudButton>
            <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showAddMatchDialog = false">@L["Close"]</MudButton>
        </DialogActions>
    </MudDialog>

}
<br/>
<br/>
<MudGrid>
    <MudItem xs="12">
        <MudAutocomplete T="string"
                         Value="@_searchedPlayer"
                         ValueChanged="SearchForPlayer"
                         ResetValueOnEmptyText="true"
                         CoerceText="true"
                         Label=@($"Search For My Next Match")
                         AdornmentIcon="@Icons.Material.Filled.Search"
                         SearchFunc="@(s => Task.FromResult(Players.Where(o=>!string.IsNullOrWhiteSpace(s)&&o.Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

        </MudAutocomplete>
        </MudItem>
    @if (_nextMatch != null)
    {
        <MudItem xs="12"><MudText>Your next Match is @_nextMatch.MatchName</MudText></MudItem>
        <MudItem xs="12"><MudText>There are @_matchesLeft Matches until Then</MudText></MudItem>
        <MudItem xs="12"><MudText>This is expected to be @_expectedTime.ToString("dddd h:mm tt") (this is a very rough estimate)</MudText></MudItem>
    }
</MudGrid>
<br />
<br />
@foreach (var parameters in MatchSections())
{
    @if (parameters.matches.Any())
    {
        <MudTable T="MatchView" Items="parameters.matches">
            <ToolBarContent>
                <MudText Typo="Typo.h6">@parameters.header</MudText>
            </ToolBarContent>
            <HeaderContent>
                <MudTh>Match Name</MudTh>
                <MudTh>Status</MudTh>
                <MudTh>Phase</MudTh>
                <MudTh>Players</MudTh>
                @if (parameters.showWinner)
                {
                    <MudTh>Winner</MudTh>
                }
                <MudTh>View</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>@context.MatchName</MudTd>
                <MudTd>@context.State</MudTd>
                <MudTh>@context.PhaseName</MudTh>
                <MudTh>@(string.Join(", ",context.Players.Select(p=>p.ToString().StartsWith("Unknown ")?"TBD":p.ToString())))</MudTh>
                
                @if (parameters.showWinner)
                {
                    <MudTh>@context.FinalPlaces[0]</MudTh>
                }
                <MudTd><MudButton OnClick="() => ViewMatch(context.MatchName)" StartIcon="@Icons.Material.Filled.ViewDay" Color="Color.Primary" Variant="Variant.Outlined">View</MudButton></MudTd>
            </RowTemplate>
        </MudTable>
        <br/>
        <br/>
    }
}
@if (IsLoggedInAsAdmin)
{
    <MudButton OnClick="FindInvalidMatches" Color="Color.Primary" Variant="Variant.Filled">Check Matches</MudButton>
    @if (_linksChecked && !_tooManyLinks.Any() && !_notEnoughLinks.Any())
    {
        <MudText>You did it!</MudText>
    }
    
    @if (_tooManyLinks.Any())
    {
        <MudText>Too many: 
            @foreach (var match in _tooManyLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }

        </MudText>
    }
    @if (_notEnoughLinks.Any())
    {
        <MudText>
            Not enough:
            @foreach (var match in _notEnoughLinks)
            {
                <MudLink OnClick="()=>ViewMatch(match)">@match</MudLink>
            }
        </MudText>
    }

    <MudTable T="MatchLink" Items="_matchLinks">
        <ToolBarContent>
            <MudText Typo="Typo.h6">Links</MudText>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="()=>_showMatchLinkDialog=true">Create</MudButton>
        </ToolBarContent>
        <HeaderContent>
            <MudTh>From Match</MudTh>
            <MudTh>To Match</MudTh>
            <MudTh>Type</MudTh>
            <MudTh>Players</MudTh>
            <MudTh>Delete</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd>@context.FromMatch</MudTd>
            <MudTd>@context.ToMatch</MudTd>
            <MudTd>@(context.IsWinners?"Winners":"Losers")</MudTd>
            <MudTd>@context.PlayerCount</MudTd>
            <MudTd><MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Primary" OnClick="()=>DeleteLink(context)"></MudIconButton></MudTd>
        </RowTemplate>
    </MudTable>
}
<MudDialog @bind-IsVisible="_showMatchDialog">
    <DialogContent>
        @if (_currentMatch != null)
        {
            <MatchOverview MatchName="_currentMatch.Value"></MatchOverview>
        }
    </DialogContent>
    <DialogActions>
        @if (IsBracketAdmin && _currentMatch!=null)
        {
            <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.AddAlert" OnClick="()=>PingMatch(_currentMatch.Value)">Ping Match</MudButton>
        }
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
<MudDialog @bind-IsVisible="_showMatchLinkDialog">
    <DialogContent>
        <MudGrid>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_fromMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"From Match")
                                 SearchFunc="@(s => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudAutocomplete T="string"
                                 @bind-Value="@_toMatch"
                                 ResetValueOnEmptyText="true"
                                 CoerceText="true"
                                 Label=@($"To Match")
                                 SearchFunc="@(s => Task.FromResult(_matches.Keys.Where(k=>k.ToString().Contains(s,StringComparison.OrdinalIgnoreCase)).OrderBy(k => k.Equals(s, StringComparison.OrdinalIgnoreCase) ? 0 : 1).AsEnumerable()))">

                </MudAutocomplete>

            </MudItem>
            <MudItem xs="12">
                <MudCheckBox T="bool" @bind-Checked="_winners" Label="Winners"></MudCheckBox>
            </MudItem>
            <MudItem xs="12">
                <MudNumericField @bind-Value="_linkPlayers" Min="1" Max="100" Label="Players" HideSpinButtons="true"></MudNumericField>
            </MudItem>
        </MudGrid>
    </DialogContent>        <DialogActions>
        <MudSpacer></MudSpacer>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Save" OnClick="CreateLink">Save</MudButton>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="() => _showMatchLinkDialog = false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>

@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject ISnackbar Snackbar;
@code
{
    private IDictionary<string, RandomSettings> _chartPullSettings = new Dictionary<string, RandomSettings>(StringComparer.OrdinalIgnoreCase);
    private RandomSettings _currentSettings = new();
    private string _currentRandomName = string.Empty;
    private bool _showAddRandomDialog = false;
    private bool _showAddMatchDialog = false;
    private bool _showMatchDialog = false;
    private bool _showMatchLinkDialog = false;
    private User? _user;
    private int _playerCount = 2;
    private int _chartCount = 3;

    private MatchView? _nextMatch;
    private string _searchedPlayer;

    private string _randomSettings = string.Empty;
    private string _fromMatch = string.Empty;
    private string _toMatch = string.Empty;
    private int _linkPlayers = 1;
    private bool _winners = true;
    private string _matchName = string.Empty;
    private bool IsLoggedInAsAdmin => _user?.IsAdmin ?? false;
    private bool IsBracketAdmin => _user!=null && (_user.IsAdmin || MatchOverview.BracketAdmins.Contains(_user.Id));
    private Name? _currentMatch;
    private IEnumerable<MatchView> ActiveMatches => _matches.Values.Where(m => m.State is > MatchState.NotStarted and < MatchState.Completed)
        .OrderByDescending(m => m.State).ThenBy(m=>m.MatchOrder);

    private string _currentPhase = string.Empty;

    private async Task PingMatch(Name matchName)
    {
        await Mediator.Send(new PingMatchCommand(matchName));
    }

    private IEnumerable<MatchView> UpcomingMatches => _matches.Values.Where(m => m.State is MatchState.NotStarted).OrderBy(m=>m.MatchOrder);
    private IEnumerable<MatchView> CompletedMatches => _matches.Values.Where(m => m.State is MatchState.Completed).OrderBy(m=>m.MatchOrder);
    private IEnumerable<MatchView> ReadyToCardDrawMatches => UpcomingMatches.Where(m => m.PhaseName==_currentPhase && m.State is MatchState.NotStarted && !m.Players.Any(p => p.ToString().StartsWith("Unknown "))).OrderBy(m => m.MatchOrder);

    private IEnumerable<(string header, bool showWinner, IEnumerable<MatchView> matches)> MatchSections()
    {
        yield return ("Active Matches",false,ActiveMatches);
        yield return ("Ready To Card Draw",false,ReadyToCardDrawMatches);
        yield return ("Future Matches",false,UpcomingMatches);
        yield return ("Completed Matches",true,CompletedMatches);
    }
    private IDictionary<string, MatchView> _matches = new Dictionary<string, MatchView>();
    private ICollection<MatchLink> _matchLinks = new List<MatchLink>();
    private readonly ICollection<Name> _tooManyLinks = new List<Name>();
    private readonly ICollection<Name> _notEnoughLinks = new List<Name>();
    private string _phaseName = "Mids";
    private bool _linksChecked = false;
    private TimeSpan _expectedTimeToMatch = TimeSpan.Zero;
    private DateTime _expectedTime = DateTime.Now;
    private int _matchesLeft = 0;
    private void SearchForPlayer(string player)
    {
        _searchedPlayer = player;
        _nextMatch = UpcomingMatches.FirstOrDefault(m => m.Players.Contains(player));
        var fridayStart = new DateTime(2023, 12, 8, 16, 0, 0);
        var saturdayStart = new DateTime(2023, 12, 9, 10, 30, 0);
        var fridayCutoff = new DateTime(2023, 12, 8, 21, 30, 0);
        if (_nextMatch == null) return;
        
        _matchesLeft = _nextMatch.MatchOrder-UpcomingMatches.Min(m => m.MatchOrder);
        var playerCount = UpcomingMatches.Where(m => m.MatchOrder < _nextMatch.MatchOrder).Sum(m => m.Players.Length);
        var cabUseCount = playerCount / 2;
        var cabWaveCount = cabUseCount / 4;
        _expectedTimeToMatch = cabWaveCount * TimeSpan.FromMinutes(30);

        var now = DateTime.Now > fridayStart ? DateTime.Now : fridayStart;
        
        _expectedTime = now + _expectedTimeToMatch;
        if (_expectedTime <= fridayCutoff) return;

        if (now > fridayCutoff && now < saturdayStart)
        {
            _expectedTime = saturdayStart + _expectedTimeToMatch;
        }
        else if(now<fridayCutoff)
        {
            _expectedTime = saturdayStart + _expectedTimeToMatch - (fridayCutoff - now);
        } else if (now > saturdayStart)
        {
            _expectedTime = now + _expectedTimeToMatch;
        }
        
    }
    private async Task CreateLink()
    {
        var link = new MatchLink(_fromMatch, _toMatch, _winners, _linkPlayers);
        if (link.FromMatch == link.ToMatch)
        {
            return;
        }
        await Mediator.Send(new CreateMatchLinkCommand(link));
        foreach (var existingLink in _matchLinks.Where(ml => ml.FromMatch == link.FromMatch && ml.ToMatch == link.ToMatch))
        {
            _matchLinks.Remove(existingLink);
        }
        _matchLinks.Add(link);
        _showMatchLinkDialog = false;
    }

    private async Task DeleteLink(MatchLink link)
    {
        await Mediator.Send(new DeleteMatchLinkCommand(link.FromMatch, link.ToMatch));
        _matchLinks.Remove(link);
    }
    private void FindInvalidMatches()
    {

        _tooManyLinks.Clear();
        _notEnoughLinks.Clear();
        var linkDict = _matchLinks
            .Where(l=>_matches[l.FromMatch].State is not MatchState.Completed)
            .GroupBy(l => l.ToMatch.ToString()).ToDictionary(g => g.Key, g => g.ToArray());

        foreach (var match in _matches.Values)
        {
            var progressingCount = linkDict.TryGetValue(match.MatchName, out var value)?value.Sum(l => l.PlayerCount):0;
            var existingCount = match.Players.Count(p => !p.ToString().StartsWith("Unknown "));
            if (progressingCount + existingCount < match.Players.Length)
            {
                _notEnoughLinks.Add(match.MatchName);
            }
            if (progressingCount + existingCount > match.Players.Length)
            {
                _tooManyLinks.Add(match.MatchName);
            }
        }
        _linksChecked = true;
    }
    public void OpenAddRandomDialog()
    {
        _currentSettings = new();
        _showAddRandomDialog = true;
        _currentRandomName = string.Empty;
    }
    public void OpenAddMatchDialog()
    {
        _matchName = string.Empty;
        _showAddMatchDialog = true;
    }

    private void ViewMatch(Name matchName)
    {
        _currentMatch = matchName;
        _showMatchDialog = true;
    }

    private string[] Players = Array.Empty<string>();

    private async Task CreateMatch()
    {
        var players = Enumerable.Range(0, _playerCount).Select(c => Name.From($"Unknown {c}")).ToArray();
        await Mediator.Send(new UpdateMatchCommand(new MatchView(_matchName,
            _phaseName,
            _matches.Any()?_matches.TryGetValue(_matchName, out var existingMatch)?existingMatch.MatchOrder:_matches.Max(m=>m.Value.MatchOrder)+1:0,
            _chartCount,
            _randomSettings, MatchState.NotStarted,
            players, Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            Array.Empty<Guid>(),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<PhoenixScore>()),
            players.ToDictionary(p => p.ToString(), p => Array.Empty<int>()),
            players
            )));
        _showAddMatchDialog = false;
    }

    private void MatchUpdated(MatchUpdatedEvent e)
    {
        _matches[e.NewState.MatchName] = e.NewState;
        UpdateCurrentPhase();
        InvokeAsync(StateHasChanged);
    }

    private void UpdateCurrentPhase()
    {
        var remainingPhases = _matches.Values.Where(m => m.State is not MatchState.Completed)
            .Select(m => m.PhaseName.ToString()).Distinct().ToHashSet(StringComparer.OrdinalIgnoreCase);
        _currentPhase = "Pros";
        if (remainingPhases.Contains("Uppers"))
        {
            _currentPhase = "Uppers";
        }
        if (remainingPhases.Contains("Mids"))
        {
            _currentPhase = "Mids";
        }
    }

    public async Task SaveRandomSettings()
    {
        if (!Name.TryParse(_currentRandomName, out var name))
        {
            return;
        }
        try
        {
            await Mediator.Send(new GetRandomChartsQuery(_currentSettings));
        }
        catch (Exception e)
        {
            Snackbar.Add(e.Message, Severity.Error);
            return;
        }
        await Mediator.Send(new SaveRandomSettingsCommand(name, _currentSettings));
        _chartPullSettings[name] = _currentSettings;
        _showAddRandomDialog = false;
    }
    protected override async Task OnInitializedAsync()
    {
        _user = CurrentUser.IsLoggedIn ? CurrentUser.User : null;
        _matches = (await Mediator.Send(new GetAllMatchesQuery())).ToDictionary(m => m.MatchName.ToString());
        _chartPullSettings = (await Mediator.Send(new GetAllRandomSettingsQuery())).ToDictionary(s => (string) s.name, s => s.settings);
        _matchLinks = (await Mediator.Send(new GetMatchLinksQuery())).ToList();
        Players = (await Mediator.Send(new GetMatchPlayersQuery())).Select(m => m.Name.ToString()).ToArray();
        UpdateCurrentPhase();
        MainLayout.MatchUpdated += (o, e) => MatchUpdated(e);

    }

}
