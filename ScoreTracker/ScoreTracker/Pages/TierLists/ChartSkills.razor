@page "/ChartSkills"
@page "/PersonalizedTierList"
@page "/TierLists"
@using MediatR
@using Microsoft.Extensions.Caching.Memory
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Handlers
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.Models.Titles
@using ScoreTracker.Domain.Models.Titles.Interface
@using ScoreTracker.Domain.Models.Titles.Phoenix
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Web.Components
@using ChartType = ScoreTracker.Domain.Enums.ChartType
@using ScoreTracker.Domain.Records
@using ScoreTracker.PersonalProgress.Queries
@using ScoreTracker.Web.Services
@using ScoreTracker.Web.Services.Contracts
@using ScoreTracker.Web.Shared
@inject ChartVideoDisplayer VideoDisplayer
<PageTitle>Personalized Tier List</PageTitle>

<MudGrid>
    <MudItem xs="12">
        <MudText Typo="Typo.h3">@L["Tier Lists"]</MudText>
    </MudItem>

    <MudItem xs="12">
        <MudLink Href="/TierLists/Old">Go to Old Tier Lists Page</MudLink>
    </MudItem>

    @if (_isLoading)
    {
        <MudItem xs="12">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true"></MudProgressLinear>
        </MudItem>
    }
    <MudItem xs="12" sm="6">
        <MudSelect T="ChartType" Value="_chartType" ValueChanged="SetType" Label=@L["Chart Type"] Disabled="_isLoading">
            <MudSelectItem T="ChartType" Value="ChartType.Single">Singles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.Double">Doubles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.CoOp">CoOp</MudSelectItem>
        </MudSelect>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudNumericField T="int" Value="_level" Disabled="_isLoading" Min=@(_chartType==ChartType.CoOp?2:1) Max=@(_chartType==ChartType.CoOp?5:28) ValueChanged="SetLevel" Label=@(_chartType==ChartType.CoOp?L["Player Count"]:L["Difficulty Level"]) HideSpinButtons="true">
        </MudNumericField>
    </MudItem>

    <MudItem xs="12">

        <MudRadioGroup T="string" Disabled="_isLoading" Value="_tierListType" ValueChanged="SetTierListType">
            @foreach (var type in _tierListTypes)
            {
                <MudRadio Value=@type.Key Color="Color.Primary">@type.Value</MudRadio>
            }
        </MudRadioGroup>
    </MudItem>
    @if (_tierListType == "Score")
    {
        <MudItem xs="12" sm="4" md="3">

            <MudCheckBox T="bool" Value="!_groupByTierList" Disabled="_isLoading" ValueChanged="ToggleGrouping" Label=@L["Group By Scoring Difficulty"]></MudCheckBox>
        </MudItem>
    }
    @if (CurrentUser.IsLoggedIn)
    {
        @if (_chartType!=ChartType.CoOp && _tierListType!="Popularity" && (_tierListType != "Score" || _groupByTierList))
        {
            
            <MudItem xs="12" sm="4" md="3">
                <MudCheckBox T="bool" Value="_usePersonalizedData" Disabled="_isLoading" ValueChanged="u=>SetUsePersonalized(u)" Label=@L["Personalized"]></MudCheckBox>
            </MudItem>
        }
        <MudItem xs="12" sm="4" md="3">
            <MudCheckBox T="bool" @bind-Value="_hidePassed" Disabled="_isLoading" Label=@L["Hide Completed Charts"]></MudCheckBox>
        </MudItem>
        
        <MudItem xs="12" sm="4" md="3">
            <MudCheckBox T="bool" @bind-Value="_showTodo" Disabled="_isLoading" Label=@L["Show Only ToDo Charts"]></MudCheckBox>
        </MudItem>
    }
    <MudItem xs="12">
        <MudExpansionPanels>
            @if (CurrentUser.IsLoggedInAsAdmin)
            {
                <MudExpansionPanel Text="Admin Tools">
                    <MudGrid>
                        <MudItem xs="4">
                            <MudNumericField T="int" Value="_highlightedModifier" Disabled="_isLoading" ValueChanged="SetHighlighted" Label="HighlightedModifier"></MudNumericField>
                        </MudItem>
                        @foreach (var modifier in _modifiers)
                        {
                            <MudItem xs="4">
                                <MudNumericField T="double" Value="modifier.Value" Disabled="_isLoading" ValueChanged="v => SetCategory(modifier.Key, v)" Label="@modifier.Key"></MudNumericField>
                            </MudItem>
                        }
                    </MudGrid>
                </MudExpansionPanel>

            }
            <MudExpansionPanel Text=@L["Additional Filters"]>
                <MudGrid>
                    
                    <MudItem xs="12">
                        <MudCheckBox T="bool" Value="_textView" ValueChanged="SetTextView" Disabled="_isLoading" Label=@L["Text View"]></MudCheckBox>
                    </MudItem>
                    @foreach (var type in Enum.GetValues<SongType>())
                    {
                        <MudItem sm="6" md="3">
                            <MudCheckBox T="bool" Label="@type.ToString()" Disabled="_isLoading" Value="_filteredTypes.Contains(type)" ValueChanged="v => ToggleSongType(type, v)"></MudCheckBox>
                        </MudItem>
                    }
                    <MudItem xs="12" md="4">
                        <MudAutocomplete T="string" Label=@L["Song Name"] Disabled="_isLoading" AdornmentIcon="@Icons.Material.Filled.Search" @bind-Value="_songFilter" SearchFunc="(s,c)=>FilterSongName(s)" CoerceText="false" CoerceValue="true"></MudAutocomplete>
                    </MudItem>
                    <MudItem xs="12" md="4">
                        <MudSelect T="string" @bind-SelectedValues="_stepArtists" Disabled="_isLoading" Label=@L["Step Artist"] HelperText="Not All Step Artists Labeled Yet" MultiSelection="true" Clearable="true">
                            @foreach (var artist in _availableStepArtists)
                            {
                                <MudSelectItem T="string" Value="@artist">@artist</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                    <MudItem xs="12" md="4">
                        <MudSelect T="string" @bind-SelectedValues="_songArtists" Disabled="_isLoading" Label=@L["Song Artist"] MultiSelection="true" Clearable="true">
                            @foreach (var artist in _availableSongArtists)
                            {
                                <MudSelectItem T="string" Value="@artist">@artist</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                    @if (_lowestBpm != _highestBpm)
                    {

                        <MudItem xs="6">
                            <MudNumericField T="decimal?" Clearable="true" @bind-Value="_bpmMin" Disabled="_isLoading" Label=@L["Min BPM"] Min="_lowestBpm" Max="_highestBpm" HelperText="Not All BPMS Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                        <MudItem xs="6">
                            <MudNumericField T="decimal?" Clearable="true" @bind-Value="_bpmMax" Disabled="_isLoading" Label=@L["Max BPM"] Min="_lowestBpm" Max="_highestBpm" HelperText="Not All BPMS Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                    }
                    @if (_lowestNoteCount != _highestNoteCount)
                    {

                        <MudItem xs="6">
                            <MudNumericField T="int?" Clearable="true" @bind-Value="_noteCountMin" Label=@L["Min Note Count"] Min="_lowestNoteCount" Max="_highestNoteCount" HelperText="Not All Note Counts Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                        <MudItem xs="6">
                            <MudNumericField T="int?" Clearable="true" @bind-Value="_noteCountMax" Label=@L["Max Note Count"] Min="_lowestNoteCount" Max="_highestNoteCount" HelperText="Not All Note Counts Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                    }
                    @if (CurrentUser.IsLoggedIn)
                    {
                        <MudItem xs="6">
                            <MudSwitch T="bool" Value="_showAge" ValueChanged="c=>SetShowAge(c)" Disabled="_isLoading" Label=@L["Show Age"] Color="Color.Primary"></MudSwitch>
                        </MudItem>
                    }
                </MudGrid>
            </MudExpansionPanel>
        </MudExpansionPanels>
    </MudItem>
    @if (CurrentUser.IsLoggedIn)
    {

            <TitleProgressBar AverageRating="_averageRating" Titles="_titleProgress.Where(t => (t.Title is PhoenixDifficultyTitle pdt && pdt.Level == DifficultyFilter) || (ChartTypeFilter == ChartType.CoOp.ToString() && t.Title is PhoenixCoOpTitle))"></TitleProgressBar>


        @if (_unpassedTodos.Any())
        {
            <MudItem xs="12">
                <MudText Typo="Typo.subtitle1">
                    @L.GetString("Unpassed ToDos", _unpassedTodos.Count(), _level)
                </MudText>
            </MudItem>
        }
 
        <MudItem xs="12">
            @foreach (var lamp in _lamps)
            {
                <MudProgressLinear Min="0" Max="_charts.Count()" Style="margin-top:8px;" Color="lamp.Progress>=_charts.Count()?Color.Success:Color.Primary" Value="lamp.Progress">@lamp.Name</MudProgressLinear>
            }
        </MudItem>
    }

    @if (_isLoading)
    {
        <MudItem xs="12">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true"></MudProgressLinear>
        </MudItem>
    }
    @if (_finalEntries.Any() && _finalEntries.All(e=>_charts.ContainsKey(e.ChartId)))
    {
        @foreach (var group in _finalGroupings.Where(g=>g.Any(ShouldChartShow)))
        {
            <MudItem xs="12">
                <MudText Typo="Typo.h6">@group.Key.ToString()</MudText>
                @if (CurrentUser.IsLoggedIn)
                {
                    <MudText Typo="Typo.subtitle1">@_messages[group.Key]</MudText>
                }
            </MudItem>
            

            foreach (var chart in group.Where(ShouldChartShow).OrderBy(e => e.Order).Select(c => _charts[c.ChartId]))
            {
                
                @if (_textView)
                {
                    <MudItem xs="12" Style="padding-top:0px;padding-bottom:0px;">
                        
                        <MudText Color=@(_scores.ContainsKey(chart.Id) && _scores[chart.Id]>0 ? Color.Success : _todos.Contains(chart.Id)?Color.Info: Color.Default)>
                            @($"{chart.Song.Name} {chart.DifficultyString}") @(_scores.ContainsKey(chart.Id)&&_scores[chart.Id]>0?$"- {_scores[chart.Id].ToGradeString()}":"")
                        </MudText>
                    </MudItem>
                }
                else
                {
                    <MudItem xs="6" sm="3" md="2">

                        <MudCard Class="@CardClass(chart.Id)" Style="@CardStyle(chart.Id)">
                            <MudCardHeader Style=@($"background-image:url(\"{chart.Song.ImagePath}\");")>
                                
                                <DifficultyBubble Chart="chart"></DifficultyBubble>
                            </MudCardHeader>
                            @if ((_scores.TryGetValue(chart.Id, out var s) ? s : 0) > 0)
                            {
                                <MudCardContent>
                                    <ScoreBreakdown Score="_scores[chart.Id]" IsBroken="_isBroken[chart.Id]" OneLine="true" ShowScore="true" Plate="_plate[chart.Id]"></ScoreBreakdown>
                                    @if (_showAge)
                                    {
                                        <MudText>@(_ages[chart.Id].ToString("0")) @L["Days Old"]</MudText>
                                    }
                                </MudCardContent>
                            }
                            <MudCardActions>
                                @if (_topCharts.Contains(chart.Id))
                                {
                                    <MudTooltip Text=@($"Top 50 {chart.Type}s")>
                                        <MudIcon Icon="@PiuScoresIcons.Crown" Style="color:#00ffff"></MudIcon>
                                    </MudTooltip>
                                }
                                <MudSpacer>
                                </MudSpacer>
                                @if (_charTitles.TryGetValue(chart.Id, out var title))
                                {
                                    <MudTooltip Text=@($"{string.Join(',', title.Select(n => n.ToString()))}")>
                                        <MudIcon Color="Color.Warning" Icon="@Icons.Material.Filled.Star"></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_popularCharts.Contains(chart.Id) && _tierListType != "Popularity")
                                {
                                    <MudTooltip Text="This chart is extra popular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingUp></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_unPopularCharts.Contains(chart.Id) && _tierListType != "Popularity")
                                {

                                    <MudTooltip Text="This chart is extra unpopular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingDown></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_variance.TryGetValue(chart.Id, out var varianceLevel) && varianceLevel != "Normal")
                                {
                                    <MudTooltip Text=@($"{varianceLevel} Score Variance")>
                                        <MudIcon Icon=@Icons.Material.Filled.GraphicEq Style=@($"color:{(varianceLevel=="Very High"?MudBlazor.Colors.Red.Darken1:varianceLevel=="High"?MudBlazor.Colors.Orange.Darken1:varianceLevel=="Low"?MudBlazor.Colors.Green.Darken1:MudBlazor.Colors.Blue.Darken1)}")></MudIcon>
                                    </MudTooltip>
                                }
                                @if (CurrentUser.IsLoggedInAsAdmin)
                                {
                                    <MudIconButton Icon="@Icons.Material.Outlined.ListAlt" OnClick="() => ToggleToDo(chart.Id)" Color="_todos.Contains(chart.Id) ? Color.Primary : Color.Default"></MudIconButton>

                                }

                                <MudIconButton Icon="@Icons.Custom.Brands.YouTube" OnClick="@(() => VideoDisplayer.ShowVideo(chart.Id))"></MudIconButton>
                               
                            </MudCardActions>
                        </MudCard>
                    </MudItem>
                }
            }
        }
        @if (CurrentUser.IsLoggedInAsAdmin && _orderedSkills.Any())
        {
            
            <MudItem xs="12">
                <MudText Typo="Typo.h5">My Skills</MudText>
            </MudItem>
            @foreach (var skill in _orderedSkills.Where(s => MaxScore[s] > 0))
            {
                <MudItem xs="12">
                    <MudProgressLinear Color="Colors[skill]" Min="MinScore[skill]" Max="MaxScore[skill]" Value="MyScore[skill]">@skill.GetName()</MudProgressLinear>
                </MudItem>
            }
        }
    }


</MudGrid>

@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject NavigationManager NavManager;
@inject ITierListRepository TierLists;
@inject ITitleRepository Titles;
@inject IUiSettingsAccessor UiSettings;
@inject IAdminNotificationClient Notifications;
@inject ISnackbar Snackbar;
@inject IPhoenixRecordRepository Records;
@inject IPlayerStatsRepository PlayerStats;
@inject IMemoryCache Cache;
@code
{

    [Parameter]
    [SupplyParameterFromQuery(Name = "Difficulty")]
    public int? DifficultyFilter { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "ChartType")]
    public string? ChartTypeFilter { get; set; } = string.Empty;

    [Parameter]
    [SupplyParameterFromQuery(Name = "TierListType")]
    public string? TierListType { get; set; } = string.Empty;
    private DateTimeOffset _now = DateTimeOffset.Now;
    private IDictionary<Skill, List<Chart>> SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, List<Chart>> HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, int> MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IEnumerable<Skill> _orderedSkills = Array.Empty<Skill>();
    private IDictionary<Skill, double> _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
    private IDictionary<Skill, Color> Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);
    private IDictionary<Guid, double> _passScore = new Dictionary<Guid, double>();
    private IDictionary<Guid, PhoenixScore> _scores = new Dictionary<Guid, PhoenixScore>();
    private IDictionary<Guid, bool> _isBroken = new Dictionary<Guid, bool>();
    private IDictionary<Guid, PhoenixPlate?> _plate = new Dictionary<Guid, PhoenixPlate?>();
    private IDictionary<Guid, int> _ages = new Dictionary<Guid, int>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private ISet<Guid> _unPopularCharts = new HashSet<Guid>();
    private ISet<Guid> _popularCharts = new HashSet<Guid>();

    private async Task SetTextView(bool newSetting)
    {
        await UiSettings.SetSetting("TierLists__TextView", newSetting.ToString());
        _textView = newSetting;
    }
    private ISet<SongType> _filteredTypes = new HashSet<SongType>();
    private IEnumerable<string> _stepArtists = new HashSet<string>();
    private IEnumerable<string> _songArtists = new HashSet<string>();
    private IDictionary<Guid, IEnumerable<Name>> _charTitles = new Dictionary<Guid, IEnumerable<Name>>();
    private IEnumerable<PhoenixTitle> _titles = Array.Empty<PhoenixTitle>();
    private IEnumerable<Guid> _unpassedTodos => _finalEntries.Select(e => e.ChartId).Where(chartId => _isBroken.ContainsKey(chartId)&& _isBroken[chartId] && _todos.Contains(chartId));
    private Name[] _availableStepArtists = Array.Empty<Name>();
    private Name[] _availableSongArtists = Array.Empty<Name>();
    private int _lowestNoteCount = 0;
    private int _highestNoteCount = 0;
    private decimal _lowestBpm = 0;
    private decimal _highestBpm = 0;
    private ChartType _chartType = ChartType.Single;
    private bool _textView = false;
    private bool _isLoading = false;
    private bool _showTodo = false;
    private bool _showAge = false;
    private decimal? _bpmMin;
    private decimal? _bpmMax;
    private int? _noteCountMin;
    private int? _noteCountMax;
    private ISet<Guid> _todos = new HashSet<Guid>();

    private sealed record LampProgress(string Name, int Order, int Progress);

    private IEnumerable<LampProgress> _lamps = Array.Empty<LampProgress>();
    private IEnumerable<TitleProgress> _titleProgress = Array.Empty<TitleProgress>();
    private Task<IEnumerable<string>> FilterSongName(string search) => Task.FromResult(_finalEntries.Select(c => _charts[c.ChartId].Song.Name.ToString()).Distinct().Where(
        n => string.IsNullOrWhiteSpace(search)|| n.Contains(search, StringComparison.OrdinalIgnoreCase)).OrderBy(n => n == search ? 0 : 1).AsEnumerable());

    private IDictionary<Guid, string> _variance = new Dictionary<Guid, string>();
    private async Task CalculateVariance(ChartType chartType, DifficultyLevel level)
    {
        var scores = (await Records.GetAllPlayerScores(chartType, level)).ToArray();
        var players = (await PlayerStats.GetStats(scores.Select(s => s.userId).Distinct().ToArray(), CancellationToken.None))
            .Where(p => Math.Abs((_chartType == ChartType.Single ? p.SinglesCompetitiveLevel : p.DoublesCompetitiveLevel) - level) < 2.0).ToDictionary(p => p.UserId);

        var chartGroups = scores.GroupBy(r => r.record.ChartId).ToDictionary(g => g.Key, g => g.Where(k => players.ContainsKey(k.userId) && k.record is { Score: not null, IsBroken: false }).Select(k => k.record!.Score).ToArray());


        var chartStandards = chartGroups.Where(kv => kv.Value.Count() > 5)
            .Select(kv => (_charts[kv.Key], TierListSaga.StdDev(kv.Value.Select(s => (int)s!.Value), true)))
            .ToArray();

        if (!chartStandards.Any())
        {
            return;
        }
        var average = chartStandards.Average(c => c.Item2);
        var standardDev = TierListSaga.StdDev(chartStandards.Select(c => c.Item2), true);
        var results = chartStandards
            .Select(kv => (kv.Item1, (kv.Item2-average)/standardDev))
            .ToArray();

        _variance = results.ToDictionary(r => r.Item1.Id, r => r.Item2 <= -2.0 ? "Very Low" :
            r.Item2 <= -1.0 ? "Low" :
                r.Item2 >= 2.0 ? "Very High" :
                    r.Item2 >= 1.0 ? "High" : "Normal");

    }
    private void ToggleSongType(SongType s, bool v)
    {
        if (v)
        {
            _filteredTypes.Add(s);
        }
        else
        {
            _filteredTypes.Remove(s);
        }
    }

    private bool ShouldChartShow(SongTierListEntry entry)
    {
        if (_hidePassed && !_isBroken[entry.ChartId])
        {
            return false;
        }
        if (_showTodo && !_todos.Contains(entry.ChartId))
        {
            return false;
        }
        var chart = _charts[entry.ChartId];
        if (_filteredTypes.Any() && !_filteredTypes.Contains(chart.Song.Type))
        {
            return false;
        }
        if (!string.IsNullOrWhiteSpace(_songFilter) && !chart.Song.Name.ToString().Contains(_songFilter, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        if (_bpmMax != null && (chart.Song.Bpm == null || chart.Song.Bpm.Value.Max > _bpmMax))
        {
            return false;
        }
        if (_bpmMin != null && (chart.Song.Bpm == null || chart.Song.Bpm.Value.Min < _bpmMin))
        {
            return false;
        }
        if (_stepArtists.Any() && !_stepArtists.Contains(chart.StepArtist?.ToString() ?? "Unknown",StringComparer.OrdinalIgnoreCase))
        {
            return false;
        }
        if (_songArtists.Any() && !_songArtists.Contains(chart.Song.Artist.ToString(), StringComparer.OrdinalIgnoreCase))
        {
            return false;
        }
        if (_noteCountMin != null && (chart.NoteCount != null || _noteCountMin >= chart.NoteCount))
        {
            return false;
        }
        if (_noteCountMax != null && (chart.NoteCount != null || _noteCountMax <= chart.NoteCount))
        {
            return false;
        }
        return true;
    }
    private int _highlightedModifier = 10;
    private bool _hidePassed = false;
    private bool _showSettings = false;
    private int _level = 20;
    private string _tierListType = "Pass";
    private string _songFilter;
    private async Task SetShowAge(bool newSetting)
    {
        _showAge = newSetting;
        await UiSettings.SetSetting("TierLists__ShowAge", newSetting.ToString());
    }
    private bool _usePersonalizedData = true;
    private IEnumerable<IGrouping<string, SongTierListEntry>>
    _finalGroupings = Array.Empty<IGrouping<string, SongTierListEntry>>();
    private string ChartSearch(Chart chart)
    {
        var searchString = "Pump It Up " + chart.Song.Name + " " + chart.DifficultyString;
        return $"https://www.youtube.com/results?search_query={searchString.Replace("%", "Percent ").Replace(" ", "+")}";
    }

    private async Task SetUsePersonalized(bool newUse)
    {
        _usePersonalizedData = newUse;

        await SetTierListType(_tierListType);
    }
    private async Task SetTierListType(string type)
    {
        _tierListType = type;
        SetQueryString();
        if (_tierListType == "Pass")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 0 },
                {"Similar Players", 2},
                { "Popularity", 0 },
                { "Pass Count",2}
            };
            _groupByTierList = true;
        }
        if (_tierListType == "Score")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 1 },
                { "Scores", 2 },
                { "Skill", 0 },
                {"Similar Players",1},
                { "Popularity", 0 },
                { "Pass Count",0}
            };
        }
        if (_tierListType == "Popularity")
        {
            _groupByTierList = true;
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 0 },
                { "Popularity", 2 },
                { "Pass Count",0},
                {"Similar Players",0}
            };
        }
        if (!_usePersonalizedData)
        {
            _modifiers["Skill"] = 0;
            _modifiers["Similar Players"] = 0;
        }
        await Recalculate();
    }

    private async Task ToggleGrouping(bool groupByLevel)
    {
        _groupByTierList = !groupByLevel;
        await Recalculate();
    }

    private void SetQueryString()
    {

        NavManager.NavigateTo(NavManager.GetUriWithQueryParameters(new Dictionary<string, object?>
        {
            { "Difficulty", _level },
            { "ChartType", _chartType.ToString() },
            {"TierListType",_tierListType}
        }));
    }
    private string CategoryColor(TierListCategory category) => category switch
    {
        TierListCategory.Overrated=>"#00FFFF",
        TierListCategory.VeryEasy=>"#00FFBB",
        TierListCategory.Easy=>"#00FF55",
        TierListCategory.Medium=>"#00FF00",
        TierListCategory.Hard=>"#55BB00",
        TierListCategory.VeryHard=>"#BB5500",
        TierListCategory.Underrated=>"#FF0000",
        TierListCategory.Unrecorded=>"#888888"
    };
    public async Task ToggleToDo(Guid chartId)
    {
        if (!_todos.Contains(chartId))
        {
            await Mediator.Send(new SaveChartToListCommand(ChartListType.ToDo, chartId));
            Snackbar.Add("Added to ToDo List!", Severity.Success);
            _todos.Add(chartId);
        }
        else
        {
            await Mediator.Send(new RemoveChartFromListCommand(ChartListType.ToDo, chartId));
            Snackbar.Add("Removed from ToDo List!", Severity.Success);
            _todos.Remove(chartId);
        }
        StateHasChanged();
    }
    private string CardClass(Guid chartId) =>
        _isBroken.TryGetValue(chartId,out var broken)&&!broken? "chart-card border-solid border-2" : "chart-card border-dashed border-2";

    private string CardStyle(Guid chartId) =>
        _isBroken.TryGetValue(chartId, out var broken) && !broken ? $@"border-color:{MudBlazor.Colors.Green.Darken1}" : "";
    private async Task SetHighlighted(int newModifier)
    {
        _highlightedModifier = newModifier;
        await Recalculate();
    }

    private async Task SetCategory(string category, double modifier)
    {
        _modifiers[category] = modifier;
        await Recalculate();
    }

    private bool _groupByTierList = true;

    private async Task<IEnumerable<SongTierListEntry>> BuildSkillTierList()
    {

        SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        _orderedSkills = Array.Empty<Skill>();
        _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);
        _passScore = new Dictionary<Guid, double>();
        _scores = new Dictionary<Guid, PhoenixScore>();
        _isBroken = new Dictionary<Guid, bool>();

        var skills = (await Mediator.Send(new GetChartSkillsQuery())).Where(c => _charts.ContainsKey(c.ChartId)).ToArray();

        var myScores = (await Mediator.Send(new GetPhoenixRecordsQuery(CurrentUser.User.Id)))
            .Where(s => _charts.ContainsKey(s.ChartId))
            .ToDictionary(g => g.ChartId);

        _scores = _charts.ToDictionary(c => c.Key, c => myScores.TryGetValue(c.Key, out var s) ? s.Score ?? PhoenixScore.Min : PhoenixScore.Min);
        _isBroken = _charts.ToDictionary(c => c.Key, c => !myScores.TryGetValue(c.Key, out var b) || b.IsBroken);
        _plate = _charts.ToDictionary(c => c.Key, c => myScores.TryGetValue(c.Key, out var s) ? s.Plate : null);
        _ages = _charts.ToDictionary(c => c.Key, c => myScores.TryGetValue(c.Key, out var s) ? (int)(_now - s.RecordedDate).TotalDays : 0);
        foreach (var skillChart in skills)
        {
            if (!myScores.TryGetValue(skillChart.ChartId, out var score)||score.Score==null)
            {
                foreach (var skill in skillChart.ContainsSkills.Concat(skillChart.HighlightsSkill).Distinct())
                {
                    MissingScores[skill]++;
                }
                continue;
            }
            foreach (var skill in skillChart.ContainsSkills)
            {
                SkillCharts[skill].Add(_charts[skillChart.ChartId]);
                MinScore[skill] += PhoenixLetterGrade.AA.GetMinimumScore();
                MaxScore[skill] += 1000000;
                MyScore[skill] += score.Score!.Value;
            }
            foreach (var skill in skillChart.HighlightsSkill)
            {
                HighlightedCharts[skill].Add(_charts[skillChart.ChartId]);
                MaxScore[skill] += _highlightedModifier * 1000000;
                MinScore[skill] += _highlightedModifier * PhoenixLetterGrade.AA.GetMinimumScore();
                MyScore[skill] += _highlightedModifier * (int)score.Score!.Value;
            }
        }

        _orderedSkills = Enum.GetValues<Skill>().Where(s => MaxScore[s] > 0).OrderBy(s => MyScore[s] / (double)MaxScore[s]).ToArray();

        var average = _orderedSkills.Any()? _orderedSkills.Average(s => MyScore[s] / (double)MaxScore[s]):0;
        var standardDiv = StdDev(_orderedSkills.Select(s => MyScore[s] / (double)MaxScore[s]), true);
        _skillWeights = _orderedSkills.ToDictionary(s => s, s => ((MyScore[s] / (double)MaxScore[s]) - average) / standardDiv);
        foreach (var skill in Enum.GetValues<Skill>().Where(s => !_skillWeights.ContainsKey(s)))
        {
            _skillWeights[skill] = 0;
        }
        _passScore = skills.ToDictionary(sc => sc.ChartId, sc => sc.ContainsSkills.Sum(s => _skillWeights[s]) + sc.HighlightsSkill.Sum(s => _highlightedModifier * _skillWeights[s]) / (sc.ContainsSkills.Count() + (double)_highlightedModifier * sc.HighlightsSkill.Count()));

        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => MaxScore[s] == 0 ? Color.Error : (MyScore[s] / (double)MaxScore[s]) > average ? Color.Success : Color.Warning);
        var standardDeviationCompare =
            StdDev(_passScore.Select(s => s.Value), true);
        if (!_passScore.Any())
        {
            return Array.Empty<SongTierListEntry>();
        }
        var averageCompare = _passScore.Average(s => s.Value);
        var mediumMinCompare = averageCompare - standardDeviationCompare / 2;
        var easyMinCompare = averageCompare + standardDeviationCompare / 2;
        var veryEasyMinCompare = averageCompare + standardDeviationCompare;
        var oneLevelOverratedCompare = averageCompare + standardDeviationCompare * 1.5;
        var hardMinCompare = averageCompare - standardDeviationCompare;
        var veryHardMinCompare = averageCompare - standardDeviationCompare * 1.5;
        return _passScore.Select(s => new SongTierListEntry("Skill", s.Key, s.Value > oneLevelOverratedCompare ? TierListCategory.Overrated
            : s.Value > veryEasyMinCompare ? TierListCategory.VeryEasy :
                s.Value > easyMinCompare ? TierListCategory.Easy :
                    s.Value > mediumMinCompare ? TierListCategory.Medium :
                        s.Value > hardMinCompare ? TierListCategory.Hard :
                            s.Value > veryHardMinCompare ? TierListCategory.VeryHard :
                                TierListCategory.Underrated, -1 * (int)s.Value * 100)).ToArray();
    }

    private IEnumerable<SongTierListEntry> _finalEntries = Array.Empty<SongTierListEntry>();
    private IDictionary<string, string> _messages = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => "");
    private IDictionary<string, double> _modifiers = new Dictionary<string, double>()
    {
        { "Official Scores", 0 },
        { "Scores", 1 },
        { "Skill", 2 },
        { "Popularity", .5 },
        { "Pass Count",2},
        {"Similar Players",1}
    };


    private int GetScore(TierListCategory category) => (int)category - 3;
    private int _averageRating = 1;
    private async Task<IEnumerable<SongTierListEntry>> GetSimilarPlayers(ChartType type, int level)
    {

        var myLevel = await Titles.GetCurrentTitleLevel(CurrentUser.User.Id, CancellationToken.None);
        var lowLevel = await TierLists.GetUsersOnLevel(myLevel - 1, CancellationToken.None);
        var onMyLevel = await TierLists.GetUsersOnLevel(myLevel - 1, CancellationToken.None);
        var highLevel = await TierLists.GetUsersOnLevel(myLevel - +1, CancellationToken.None);
        var userIds = (lowLevel)
            .Concat(onMyLevel)
            .Concat(highLevel)
            .Where(u => u != CurrentUser.User.Id);
        var userTiersLists = new Dictionary<Guid, IEnumerable<SongTierListEntry>>();
        var myTierList = (await Mediator.Send(new GetMyRelativeTierListQuery(type, level)))
            .ToDictionary(r => r.ChartId);
        foreach (var userId in userIds)
        {
            userTiersLists[userId] = await Mediator.Send(new GetMyRelativeTierListQuery(type, level, userId));
        }
        var userTotals = userTiersLists.ToDictionary(kv => kv.Key, kv => kv.Value.Sum(e => myTierList.ContainsKey(e.ChartId) && myTierList[e.ChartId].Category != TierListCategory.Unrecorded && e.Category != TierListCategory.Unrecorded ?
            (int)TierListCategory.Unrecorded - (int)Math.Abs(e.Category - myTierList[e.ChartId].Category)
            : 0));

        var chartWeights = new Dictionary<Guid, int>();

        foreach (var kv in userTiersLists)
            foreach (var entry in kv.Value.Where(e => e.Category != TierListCategory.Unrecorded))
            {
                if (!chartWeights.ContainsKey(entry.ChartId))
                {
                    chartWeights[entry.ChartId] = 0;
                }
                chartWeights[entry.ChartId] += (TierListCategory.Unrecorded - entry.Category) * userTotals[kv.Key];
            }
        return TierListSaga.ProcessIntoTierList("Similar Players", chartWeights);
        

    }

    private ISet<Guid> _topCharts = new HashSet<Guid>();
    private async Task Recalculate()
    {
        _isLoading = true;
        await UiSettings.SetSetting("TierLists__Level", _level.ToString());
        await UiSettings.SetSetting("TierLists__ChartType", _chartType.ToString());
        await UiSettings.SetSetting("TierLists__ListType", _tierListType);
        await UiSettings.SetSetting("TierLists__UsePersonalized", _usePersonalizedData.ToString());
        await UiSettings.SetSetting("TierLists__GroupByTierList", _groupByTierList.ToString());
        await UiSettings.SetSetting("TierLists__HideCompleted", _hidePassed.ToString());
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix, _level, _chartType))).ToDictionary(c => c.Id);
        var titles = _titles.Where(t => t is ISpecificChartTitle).ToArray();
        _charTitles = _charts.Values.SelectMany(c => titles.Select(t => (c,t,((ISpecificChartTitle)t).AppliesToChart(c))))
            .Where(v => v.Item3).GroupBy(v=>v.c.Id).ToDictionary(g =>g.Key,g=> g.Select(v => v.t.Name).ToArray().AsEnumerable());
        
        var popularity = (await Mediator.Send(new GetTierListQuery("Popularity"))).ToDictionary(s => s.ChartId);
        _popularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Overrated).Select(kv => kv.Key).ToHashSet();
        _unPopularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Underrated).Select(kv => kv.Key).ToHashSet();
        
        
        

        var cacheKey = $"{nameof(ChartSkills)}__TierList__{_tierListType}__{_chartType}__{_level}";
        if (_usePersonalizedData && CurrentUser.IsLoggedIn)
        {
            cacheKey += $"__{CurrentUser.User.Id}";
        }
        _finalEntries = await Cache.GetOrCreateAsync(cacheKey, async o =>
        {
            o.AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(6);
            o.SlidingExpiration = TimeSpan.FromHours(1);

            var officialScores = (await Mediator.Send(new GetTierListQuery("Official Scores"))).ToDictionary(s => s.ChartId);
            var similarPlayers = new Dictionary<Guid, SongTierListEntry>();
            var scores = (await Mediator.Send(new GetTierListQuery("Scores"))).ToDictionary(s => s.ChartId); 
            var baseEntries =
                CurrentUser.IsLoggedIn ?
                    (await BuildSkillTierList()).ToDictionary(e => e.ChartId)
                    : scores.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
            var title = (await Mediator.Send(new GetTierListQuery("Pass Count"))).ToDictionary(s => s.ChartId);
            if (CurrentUser.IsLoggedIn && _usePersonalizedData)
            {
                similarPlayers = CurrentUser.IsLoggedIn ? (await GetSimilarPlayers(_chartType, _level))
                    .ToDictionary(e => e.ChartId) : _charts.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Similar Players", kv.Key, TierListCategory.Unrecorded, 0));

            }

            var result = new List<SongTierListEntry>();
            foreach (var chartId in _charts.Keys)
            {
                var count = 0.0;
                var currentTotal = 0.0;
                foreach (var listItem in new[] { (officialScores, "Official Scores"), (scores, "Scores"), (popularity, "Popularity"), (baseEntries, "Skill"), (title, "Pass Count"), (similarPlayers,"Similar Players") })
                {
                    if (!listItem.Item1.ContainsKey(chartId) || listItem.Item1[chartId].Category == TierListCategory.Unrecorded)
                    {
                        continue;
                    }
                    count += _modifiers[listItem.Item2];
                    currentTotal += _modifiers[listItem.Item2] * (double)GetScore(listItem.Item1[chartId].Category);
                }
                var final = currentTotal / (double)count;
                result.Add(new SongTierListEntry("Final", chartId, final < -2.5 ? TierListCategory.Overrated :
                    final < -1.5 ? TierListCategory.VeryEasy :
                        final < -.5 ? TierListCategory.Easy :
                            final <= .5 ? TierListCategory.Medium :
                                final <= 1.5 ? TierListCategory.Hard :
                                    final <= 2.5 ? TierListCategory.VeryHard :
                                        TierListCategory.Underrated, (int)(final * 100.0)));

            }
            return result;
        }) ?? throw new Exception("Tier list could not be retrieved from cache");


        if (_groupByTierList)
        {
            _finalGroupings = _finalEntries.GroupBy(e => e.Category.ToString()).OrderBy(g => Enum.Parse<TierListCategory>(g.Key))
                .ToArray();
        }
        else
        {
            _finalGroupings = _finalEntries.GroupBy(e => _charts[e.ChartId].ScoringLevel?.ToString("0.0") ?? "Not Enough Data")
                .OrderBy(g => double.TryParse(g.Key,out var d)?d:10000).ToArray();
        }
        _messages = _finalGroupings.ToDictionary(kv => kv.Key, kv => "");
        foreach (var group in _finalGroupings)
        {
            var clearRate = 0.0;
            if (group.Any(e => (_isBroken.TryGetValue(e.ChartId,out var s) && !s)))
            {
                clearRate = group.Count(e => _isBroken.TryGetValue(e.ChartId, out var s) && !s) / (double)group.Count();
            }
            var scoredCharts = group.Where(e => _scores.TryGetValue(e.ChartId, out var score) && score>0).ToArray();
            if (!scoredCharts.Any())
            {
                _messages[group.Key] = $"{clearRate * 100.0:0.00}% Cleared";
                continue;
            }
            var minScore = (PhoenixScore)scoredCharts.Min(e => (int)_scores[e.ChartId]);
            var avgScore = (PhoenixScore)(int)scoredCharts.Average(e => _scores[e.ChartId]);
            var maxScore = (PhoenixScore)scoredCharts.Max(e => (int)_scores[e.ChartId]);
            _messages[group.Key] = $"{clearRate * 100.0:0.00}% Cleared, {minScore} ({minScore.LetterGrade.GetName()}) - {maxScore} ({maxScore.LetterGrade.GetName()}), {avgScore} ({avgScore.LetterGrade.GetName()}) Average";
        }
        var charts = _finalEntries.Select(e => _charts[e.ChartId]).ToArray();
        _lowestBpm = charts.Any(c => c.Song.Bpm != null) ? charts.Where(c => c.Song.Bpm != null).Min(c => c.Song.Bpm!.Value.Min) : 0;
        _bpmMin = null;
        _highestBpm = charts.Any(c => c.Song.Bpm != null) ? charts.Where(c => c.Song.Bpm != null).Max(c => c.Song.Bpm!.Value.Max) : 0;
        _bpmMax = null;
        _lowestNoteCount = charts.Any(c => c.NoteCount != null) ? charts.Where(c => c.NoteCount != null).Min(c => c.NoteCount!.Value) : 0;
        _noteCountMin = null;
        _highestNoteCount = charts.Any(c => c.NoteCount != null) ? charts.Where(c => c.NoteCount != null).Max(c => c.NoteCount!.Value) : 0;
        _noteCountMax = null;
        _availableStepArtists = charts.Select(c => c.StepArtist ?? "Unknown").Distinct().OrderBy(s=>s).ToArray();
        _availableSongArtists = charts.Select(c => c.Song.Artist).Distinct().OrderBy(s=>s).ToArray();
        _stepArtists = new HashSet<string>();
        _songArtists = new HashSet<string>();

        var baseRating = DifficultyLevel.From(_level).BaseRating;
        if (_chartType == ChartType.CoOp)
        {
            baseRating = 2000;
        }
        _averageRating = _scores.Any(kv => !_isBroken[kv.Key] && kv.Value > 0) ? (int)_scores.Where(kv => !_isBroken[kv.Key] && kv.Value > 0).Average(s => s.Value.LetterGrade.GetModifier() * baseRating) : baseRating;
        await CalculateVariance(_chartType, _level);

        var lamps = new List<LampProgress>();
        lamps.Add(new LampProgress("Pass",0,_charts.Count(kv=>_isBroken.TryGetValue(kv.Key,out var b)&&!b)));
        var order = 1;
        for (var grade = PhoenixLetterGrade.AA; grade <= PhoenixLetterGrade.SSSPlus; grade++)
        {
            lamps.Add(new LampProgress(grade.GetName(), order++,
                _charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s.LetterGrade >= grade)));
        }
        lamps.Add(new LampProgress("PG", order, _charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s == PhoenixScore.Max)));
        _lamps = lamps;
        _isLoading = false;
    }
    private async Task SetType(ChartType newType)
    {
        _chartType = newType;
        if (_chartType == ChartType.CoOp && _level is < 2 or > 4)
        {
            _level = 2;
        }
        if (_chartType == ChartType.CoOp && _usePersonalizedData)
        {
            _usePersonalizedData = false;
            _modifiers["Skill"] = 0;
            _modifiers["Similar Players"] = 0;
        }
        SetQueryString();
        await Recalculate();
    }

    private async Task SetLevel(int level)
    {
        _level = level;

        SetQueryString();
        await Recalculate();
    }
    protected override async Task OnInitializedAsync()
    {
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).
          ToDictionary(c => c.Id);
        _titles = PhoenixTitleList.BuildList();
        _chartType = ChartType.Double;
        _level = 18;
        _tierListTypes=new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "Pass", L["Stage Break"] },
            { "Score", L["Score"] },
            { "Popularity", L["Popularity"] }
        };

        if (CurrentUser.IsLoggedIn)
        {

            _topCharts = (await Mediator.Send(new GetTop50CompetitiveQuery(CurrentUser.User.Id, ChartType.Double)))
                .Concat(await Mediator.Send(new GetTop50CompetitiveQuery(CurrentUser.User.Id, ChartType.Single)))
                .Select(c => c.ChartId).Distinct().ToHashSet();
            var stats = await Mediator.Send(new GetPlayerStatsQuery(CurrentUser.User.Id));
            if (stats.DoublesCompetitiveLevel > 1)
            {
                
                _level = (int)Math.Round(stats.DoublesCompetitiveLevel);
            }
            if (stats.SinglesCompetitiveLevel > 1 && stats.SinglesCompetitiveLevel > stats.DoublesCompetitiveLevel)
            {
                _chartType = ChartType.Single;
                _level = (int)Math.Round(stats.SinglesCompetitiveLevel);
            }
            _todos = (await Mediator.Send(new GetSavedChartsQuery())).Where(c => c.ListType == ChartListType.ToDo).Select(c => c.ChartId).Distinct().ToHashSet();
        }
        _showAge = bool.TryParse(await UiSettings.GetSetting("TierLists__ShowAge"), out var res) && res;
        _level = int.TryParse(await UiSettings.GetSetting("TierLists__Level"), out var l) ? l : 18;
        _chartType = Enum.TryParse<ChartType>(await UiSettings.GetSetting("TierLists__ChartType"), out var cType) ? cType : ChartType.Double;
        _tierListType = await UiSettings.GetSetting("TierLists__ListType") ?? "Pass";
        _usePersonalizedData = (await UiSettings.GetSetting("TierLists__UsePersonalized") ?? true.ToString()) == true.ToString();
        _groupByTierList = (await UiSettings.GetSetting("TierLists__GroupByTierList") ?? true.ToString()) == true.ToString();
        _textView = (await UiSettings.GetSetting("TierLists__TextView") ?? false.ToString()) == true.ToString();
        if (DifficultyFilter is >= 1 and <= 28)
        {
            _level = DifficultyFilter.Value;
        }
        _titleProgress = (await Mediator.Send(new GetTitleProgressQuery(MixEnum.Phoenix))).ToArray();
        if (Enum.TryParse<ChartType>(ChartTypeFilter, out var chartType))
        {
            _chartType = chartType;
        }
        if (TierListType!=null && _tierListTypes.ContainsKey(TierListType))
        {
            await SetTierListType(TierListType);
        }
        else
        {
            await SetTierListType(_tierListType);
        }
    }

    private IDictionary<string, string> _tierListTypes = new Dictionary<string, string>();
    public static double StdDev(IEnumerable<double> values,
        bool as_sample)
    {
        // Get the mean.
        double mean = values.Sum() / values.Count();

        // Get the sum of the squares of the differences
        // between the values and the mean.
        var squares_query =
            from double value in values
            select (value - mean) * (value - mean);
        double sum_of_squares = squares_query.Sum();

        if (as_sample)
        {
            return Math.Sqrt(sum_of_squares / (values.Count() - 1));
        }
        else
        {
            return Math.Sqrt(sum_of_squares / values.Count());
        }
    }
}
