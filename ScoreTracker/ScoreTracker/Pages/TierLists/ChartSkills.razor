@page "/ChartSkills"
@page "/PersonalizedTierList"
@using MediatR
@using ScoreTracker.Application.Handlers
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Web.Components
@using ChartType = ScoreTracker.Domain.Enums.ChartType
@using ScoreTracker.Domain.Records

<PageTitle>Personalized Tier List</PageTitle>

<MudGrid>
    <MudItem xs="12">
        <MudText Typo="Typo.h3">@L["Tier Lists"] (Beta)</MudText>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudSelect T="ChartType" Value="_chartType" ValueChanged="SetType" Label="Chart Type">
            <MudSelectItem T="ChartType" Value="ChartType.Single">Singles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.Double">Doubles</MudSelectItem>
        </MudSelect>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudNumericField T="int" Value="_level" ValueChanged="SetLevel" Label="Difficulty" HideSpinButtons="true">
        </MudNumericField>
    </MudItem>
    @if (CurrentUser.IsLoggedInAsAdmin)
    {

        <MudItem xs="4">
            <MudNumericField T="int" Value="_highlightedModifier" ValueChanged="SetHighlighted" Label="HighlightedModifier"></MudNumericField>
        </MudItem>
        @foreach (var modifier in _modifiers)
        {
            <MudItem xs="4">
                <MudNumericField T="double" Value="modifier.Value" ValueChanged="v => SetCategory(modifier.Key, v)" Label="@modifier.Key"></MudNumericField>
            </MudItem>
        }
        
        <MudItem xs="12"></MudItem>
    }
    <MudItem xs="12" sm="4" md="3">

        <MudRadioGroup T="string" Value="_tierListType" ValueChanged="SetTierListType">
            <MudRadio Value="@("Pass")" Color="Color.Primary">Pass</MudRadio>
            <MudRadio Value="@("Score")" Color="Color.Primary">Score</MudRadio>
            <MudRadio Value="@("Fun")" Color="Color.Primary">Fun</MudRadio>
        </MudRadioGroup>
    </MudItem>
    @if (_tierListType == "Score")
    {
        <MudItem xs="12" sm="4" md="3">
            
            <MudCheckBox T="bool" Value="!_groupByTierList" ValueChanged="ToggleGrouping" Label="Group By Scoring Difficulty"></MudCheckBox>
        </MudItem>
    }
    @if (CurrentUser.IsLoggedIn)
    {
        <MudItem xs="12" sm="4" md="3">
            <MudCheckBox T="bool" Value="_usePersonalizedData" ValueChanged="u=>SetUsePersonalized(u)" Label="Personalized"></MudCheckBox>
        </MudItem>
        <MudItem xs="12" sm="4" md="3">
            <MudCheckBox T="bool" @bind-Checked="_showPassed" Label="Show Passed Charts"></MudCheckBox>
        </MudItem>
        <MudItem xs="12" sm="4" md="3">
            <MudCheckBox T="bool" @bind-Checked="_textView" Label="Text View"></MudCheckBox>
        </MudItem>
    }
    @if (_finalEntries.Any() && _finalEntries.All(e=>_charts.ContainsKey(e.ChartId)))
    {
        @foreach (var group in _finalGroupings.Where(g=>g.Any(c=>_showPassed ||_scores[c.ChartId]==0)))
        {
            <MudItem xs="12">
                <MudText Typo="Typo.h6">@group.Key.ToString()</MudText>
                @if (CurrentUser.IsLoggedIn)
                {
                    <MudText Typo="Typo.subtitle1">@_messages[group.Key]</MudText>
                }
            </MudItem>
            

            foreach (var chart in group.Where(c=>_showPassed || _scores[c.ChartId]==0).OrderBy(e => e.Order).Select(c => _charts[c.ChartId]))
            {
                
                @if (_textView)
                {
                    <MudItem xs="12" Style="padding-top:0px;padding-bottom:0px;">
                        
                        <MudText Color=@(_scores.ContainsKey(chart.Id) && _scores[chart.Id]>0 ? Color.Success : Color.Default)>
                            @($"{chart.Song.Name} {chart.DifficultyString}") @(_scores.ContainsKey(chart.Id)&&_scores[chart.Id]>0?$"- {_scores[chart.Id].ToGradeString()}":"")
                        </MudText>
                    </MudItem>
                }
                else
                {
                    <MudItem xs="6" sm="3" md="2">

                        <MudCard Class="@CardClass(chart.Id)" Style="@CardStyle(chart.Id)">
                            <MudCardMedia Height="100" Image="@chart.Song.ImagePath.ToString()"/>
                            @if ((_scores.TryGetValue(chart.Id, out var s) ? s : 0) > 0)
                            {
                                <MudCardContent>
                                    
                                    <MudText>@_scores[chart.Id] (@_scores[chart.Id].LetterGrade.GetName())</MudText>
                                    
                                </MudCardContent>
                            }
                            <MudCardActions>
                                <DifficultyBubble Chart="chart"></DifficultyBubble>
                                <MudSpacer>
                                </MudSpacer>
                                
                                @if (_popularCharts.Contains(chart.Id) && _tierListType!="Fun")
                                {
                                    <MudTooltip Text="This chart is extra popular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingUp></MudIcon>
                                    </MudTooltip>
                                }
                                @if(_unPopularCharts.Contains(chart.Id) && _tierListType!="Fun")
                                {
                                        
                                    <MudTooltip Text="This chart is extra unpopular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingDown></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_chartVideos.ContainsKey(chart.Id))
                                {
                                    <MudIconButton Icon="@Icons.Custom.Brands.YouTube" OnClick="@(() => ShowVideo(chart))"></MudIconButton>

                                }
                                else
                                {
                                    <MudIconButton Icon="@Icons.Material.Filled.Search" Href="@ChartSearch(chart)" Target="_blank"></MudIconButton>
                                }
                            </MudCardActions>
                        </MudCard>
                    </MudItem>
                }
            }
        }
        @if (CurrentUser.IsLoggedIn && _orderedSkills.Any())
        {
            
            <MudItem xs="12">
                <MudText Typo="Typo.h5">My Skills</MudText>
            </MudItem>
            @foreach (var skill in _orderedSkills.Where(s => MaxScore[s] > 0))
            {
                <MudItem xs="12">
                    <MudProgressLinear Color="Colors[skill]" Min="MinScore[skill]" Max="MaxScore[skill]" Value="MyScore[skill]">@skill.GetName()</MudProgressLinear>
                </MudItem>
            }
        }
    }
</MudGrid>
@if (_finalEntries.Any() && _finalEntries.All(e => _charts.ContainsKey(e.ChartId)))
{
    
    <MudTable T="SongTierListEntry" Items=@(_finalEntries)>
        <HeaderContent>
            <MudTh>
                <MudTableSortLabel T="SongTierListEntry" SortBy="e => _charts[e.ChartId].Song.Name">Song</MudTableSortLabel>
            </MudTh>
            <MudTh>Chart</MudTh>
            <MudTh>
                <MudTableSortLabel T="SongTierListEntry" SortBy="e => e.Order">Final Ranking</MudTableSortLabel>
            </MudTh>
            @foreach (var key in _categoryLists.Keys.OrderBy(k => k))
            {
                <MudTh>
                    <MudTableSortLabel T="SongTierListEntry" SortBy="e => _categoryLists[key].TryGetValue(e.ChartId, out var z) ? z.Order : 0">@key</MudTableSortLabel>
                </MudTh>
            }
        </HeaderContent>
        <RowTemplate>
            <MudTd>
                <MudImage Src="@_charts[context.ChartId].Song.ImagePath.ToString()" Height="35" Elevation="25" ObjectFit="ObjectFit.ScaleDown"/>
            </MudTd>
            <MudTd>
                <DifficultyBubble Chart="_charts[context.ChartId]"></DifficultyBubble>
            </MudTd>
            <MudTd>
                <MudTooltip Text="@context.Order.ToString()">
                    <MudText Style=@($"color:{CategoryColor(context.Category)}")>
                        @context.Category.ToString() (@((@context.Order / 100.0).ToString("0.00")))
                    </MudText>
                </MudTooltip>
            </MudTd>
            @foreach (var list in _categoryLists.OrderBy(k => k.Key))
            {
                <MudTd>
                    @if (list.Value.ContainsKey(context.ChartId))
                    {

                        <MudTooltip Text="@list.Value[context.ChartId].Order.ToString()">
                            <MudText Style=@($"color:{CategoryColor(list.Value[context.ChartId].Category)}")>
                                @list.Value[context.ChartId].Category
                            </MudText>
                        </MudTooltip>
                    }
                </MudTd>
            }
        </RowTemplate>

        <PagerContent>
            <MudTablePager></MudTablePager>
        </PagerContent>
    </MudTable>
}
<MudDialog @bind-IsVisible="_showVideoDialog">
    <DialogContent>
        <iframe class="video"
                id="chartVideoFrame"
                src="@(_currentVideo + "?autoplay=1")"
                allow="autoplay; encrypted-media"
                allowfullscreen></iframe>
    </DialogContent>

    <DialogActions>
        <MudSpacer></MudSpacer>
        <MudTooltip Text=@L["Report Video Tooltip"]>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Report" OnClick="NotifyBadVideo">@L["Report Video"]</MudButton>
        </MudTooltip>
        <MudButton Variant="Variant.Text" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Close" OnClick="()=>_showVideoDialog=false">@L["Close"]</MudButton>
    </DialogActions>
</MudDialog>
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject NavigationManager NavManager;
@inject ITierListRepository TierLists;
@inject ITitleRepository Titles;
@inject IAdminNotificationClient Notifications;
@inject ISnackbar Snackbar;
@code
{
    private IDictionary<Skill, List<Chart>> SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, List<Chart>> HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
    private IDictionary<Skill, int> MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IEnumerable<Skill> _orderedSkills = Array.Empty<Skill>();
    private IDictionary<Skill, double> _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
    private IDictionary<Skill, Color> Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);

    private IDictionary<Guid, double> _passScore = new Dictionary<Guid, double>();
    private IDictionary<Guid, PhoenixScore> _scores = new Dictionary<Guid, PhoenixScore>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private ISet<Guid> _unPopularCharts = new HashSet<Guid>();
    private ISet<Guid> _popularCharts = new HashSet<Guid>();
    private ChartType _chartType = ChartType.Single;
    private bool _textView = false;
    private bool _isLoading = false;
    private int _highlightedModifier = 10;
    private bool _showPassed = true;
    private int _level = 20;
    private string _tierListType = "Pass";
    private bool _usePersonalizedData = true;
    private IEnumerable<IGrouping<string, SongTierListEntry>>
    _finalGroupings = Array.Empty<IGrouping<string, SongTierListEntry>>();
    private string ChartSearch(Chart chart)
    {
        var searchString = "Pump It Up " + chart.Song.Name + " " + chart.DifficultyString;
        return $"https://www.youtube.com/results?search_query={searchString.Replace("%", "Percent ").Replace(" ", "+")}";
    }

    private async Task SetUsePersonalized(bool newUse)
    {
        _usePersonalizedData = newUse;
        await SetTierListType(_tierListType);
    }
    private async Task SetTierListType(string type)
    {
        _tierListType = type;
        if (_tierListType == "Pass")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", .5 },
                { "Skill", 2 },
                {"Similar Players", 2},
                { "Popularity", .5 },
                { "Pass Count",2}
            };
            _groupByTierList = true;
        }
        if (_tierListType == "Score")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", .5 },
                { "Scores", 2 },
                { "Skill", 2 },
                {"Similar Players",1.5},
                { "Popularity", .5 },
                { "Pass Count",.5}
            };
        }
        if (_tierListType == "Fun")
        {
            _groupByTierList = true;
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", .5 },
                { "Skill", 0 },
                { "Popularity", 2 },
                { "Pass Count",.5},
                {"Similar Players",.5}
            };
        }
        if (!_usePersonalizedData)
        {
            _modifiers["Skill"] = 0;
            _modifiers["Similar Players"] = 0;
        }
        await Recalculate();
    }

    private async Task ToggleGrouping(bool groupByLevel)
    {
        _groupByTierList = !groupByLevel;
        await Recalculate();
    }
    private string CategoryColor(TierListCategory category) => category switch
    {
        TierListCategory.Overrated=>"#00FFFF",
        TierListCategory.VeryEasy=>"#00FFBB",
        TierListCategory.Easy=>"#00FF55",
        TierListCategory.Medium=>"#00FF00",
        TierListCategory.Hard=>"#55BB00",
        TierListCategory.VeryHard=>"#BB5500",
        TierListCategory.Underrated=>"#FF0000",
        TierListCategory.Unrecorded=>"#888888"
    };
    private string CardClass(Guid chartId) =>
        _scores.TryGetValue(chartId,out  var score) && score>0? "border-solid border-2" : "border-dashed border-2";

    private string CardStyle(Guid chartId) =>
        _scores.TryGetValue(chartId, out var score) && score > 0 ? $@"border-color:{MudBlazor.Colors.Green.Darken1}" : "";
    private async Task SetHighlighted(int newModifier)
    {
        _highlightedModifier = newModifier;
        await Recalculate();
    }

    private async Task SetCategory(string category, double modifier)
    {
        _modifiers[category] = modifier;
        await Recalculate();
    }
    private async Task NotifyBadVideo()
    {
        await Notifications.NotifyAdmin($"The video for{_currentVideoDescription} was reported by {(CurrentUser.IsLoggedIn ? CurrentUser.User.Name : "Unknown")}", CancellationToken.None);
        Snackbar.Add("Notification was sent", Severity.Success);
    }

    private string _currentVideoDescription = string.Empty;
    private bool _groupByTierList = true;
    private bool _showVideoDialog = false;
    private string _currentVideo = string.Empty;
    private IDictionary<Guid, string> _chartVideos = new Dictionary<Guid, string>();
    private void ShowVideo(Chart chart)
    {
        _showVideoDialog = true;
        _currentVideo = _chartVideos[chart.Id];
        _currentVideoDescription = $"{chart.Song.Name} - {chart.DifficultyString}";
        StateHasChanged();
    }

    private async Task<IEnumerable<SongTierListEntry>> BuildSkillTierList()
    {

        SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        HighlightedCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());
        MinScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MaxScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MissingScores = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        MyScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
        _orderedSkills = Array.Empty<Skill>();
        _skillWeights = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => Color.Primary);
        _passScore = new Dictionary<Guid, double>();
        _scores = new Dictionary<Guid, PhoenixScore>();


        var skills = (await Mediator.Send(new GetChartSkillsQuery())).Where(c => _charts.ContainsKey(c.ChartId)).ToArray();

        var myScores = (await Mediator.Send(new GetPhoenixRecordsQuery(CurrentUser.User.Id)))
            .Where(s => _charts.ContainsKey(s.ChartId))
            .ToDictionary(g => g.ChartId);

        _scores = _charts.ToDictionary(c => c.Key, c => myScores.TryGetValue(c.Key, out var s) ? s.Score ?? PhoenixScore.Min : PhoenixScore.Min);
        foreach (var skillChart in skills)
        {
            if (!myScores.TryGetValue(skillChart.ChartId, out var score)||score.Score==null)
            {
                foreach (var skill in skillChart.ContainsSkills.Concat(skillChart.HighlightsSkill).Distinct())
                {
                    MissingScores[skill]++;
                }
                continue;
            }
            foreach (var skill in skillChart.ContainsSkills)
            {
                SkillCharts[skill].Add(_charts[skillChart.ChartId]);
                MinScore[skill] += PhoenixLetterGrade.AA.GetMinimumScore();
                MaxScore[skill] += 1000000;
                MyScore[skill] += score.Score!.Value;
            }
            foreach (var skill in skillChart.HighlightsSkill)
            {
                HighlightedCharts[skill].Add(_charts[skillChart.ChartId]);
                MaxScore[skill] += _highlightedModifier * 1000000;
                MinScore[skill] += _highlightedModifier * PhoenixLetterGrade.AA.GetMinimumScore();
                MyScore[skill] += _highlightedModifier * (int)score.Score!.Value;
            }
        }

        _orderedSkills = Enum.GetValues<Skill>().Where(s => MaxScore[s] > 0).OrderBy(s => MyScore[s] / (double)MaxScore[s]).ToArray();

        var average = _orderedSkills.Any()? _orderedSkills.Average(s => MyScore[s] / (double)MaxScore[s]):0;
        var standardDiv = StdDev(_orderedSkills.Select(s => MyScore[s] / (double)MaxScore[s]), true);
        _skillWeights = _orderedSkills.ToDictionary(s => s, s => ((MyScore[s] / (double)MaxScore[s]) - average) / standardDiv);
        foreach (var skill in Enum.GetValues<Skill>().Where(s => !_skillWeights.ContainsKey(s)))
        {
            _skillWeights[skill] = 0;
        }
        _passScore = skills.ToDictionary(sc => sc.ChartId, sc => sc.ContainsSkills.Sum(s => _skillWeights[s]) + sc.HighlightsSkill.Sum(s => _highlightedModifier * _skillWeights[s]) / (sc.ContainsSkills.Count() + (double)_highlightedModifier * sc.HighlightsSkill.Count()));

        Colors = Enum.GetValues<Skill>().ToDictionary(s => s, s => MaxScore[s] == 0 ? Color.Error : (MyScore[s] / (double)MaxScore[s]) > average ? Color.Success : Color.Warning);
        var standardDeviationCompare =
            StdDev(_passScore.Select(s => s.Value), true);
        if (!_passScore.Any())
        {
            return Array.Empty<SongTierListEntry>();
        }
        var averageCompare = _passScore.Average(s => s.Value);
        var mediumMinCompare = averageCompare - standardDeviationCompare / 2;
        var easyMinCompare = averageCompare + standardDeviationCompare / 2;
        var veryEasyMinCompare = averageCompare + standardDeviationCompare;
        var oneLevelOverratedCompare = averageCompare + standardDeviationCompare * 1.5;
        var hardMinCompare = averageCompare - standardDeviationCompare;
        var veryHardMinCompare = averageCompare - standardDeviationCompare * 1.5;
        return _passScore.Select(s => new SongTierListEntry("Skill", s.Key, s.Value > oneLevelOverratedCompare ? TierListCategory.Overrated
            : s.Value > veryEasyMinCompare ? TierListCategory.VeryEasy :
                s.Value > easyMinCompare ? TierListCategory.Easy :
                    s.Value > mediumMinCompare ? TierListCategory.Medium :
                        s.Value > hardMinCompare ? TierListCategory.Hard :
                            s.Value > veryHardMinCompare ? TierListCategory.VeryHard :
                                TierListCategory.Underrated, -1 * (int)s.Value * 100)).ToArray();
    }

    private IEnumerable<SongTierListEntry> _finalEntries = Array.Empty<SongTierListEntry>();
    private IDictionary<string, string> _messages = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => "");
    private IDictionary<string, double> _modifiers = new Dictionary<string, double>()
    {
        { "Official Scores", 0 },
        { "Scores", 1 },
        { "Skill", 2 },
        { "Popularity", .5 },
        { "Pass Count",2},
        {"Similar Players",1}
    };

    private IDictionary<string, IDictionary<Guid, SongTierListEntry>> _categoryLists = new Dictionary<string, IDictionary<Guid, SongTierListEntry>>();
    private int GetScore(TierListCategory category) => (int)category - 3;

    private async Task<IEnumerable<SongTierListEntry>> GetSimilarPlayers(ChartType type, int level)
    {

        var myLevel = await Titles.GetCurrentTitleLevel(CurrentUser.User.Id, CancellationToken.None);

        var userIds = (await TierLists.GetUsersOnLevel(myLevel - 1, CancellationToken.None))
            .Concat(await TierLists.GetUsersOnLevel(myLevel, CancellationToken.None))
            .Concat(await TierLists.GetUsersOnLevel(myLevel + 1, CancellationToken.None))
            .Where(u => u != CurrentUser.User.Id);
        var userTiersLists = new Dictionary<Guid, IEnumerable<SongTierListEntry>>();
        var myTierList = (await Mediator.Send(new GetMyRelativeTierListQuery(type, level)))
            .ToDictionary(r => r.ChartId);
        foreach (var userId in userIds)
        {
            userTiersLists[userId] = await Mediator.Send(new GetMyRelativeTierListQuery(type, level, userId));
        }
        var userTotals = userTiersLists.ToDictionary(kv => kv.Key, kv => kv.Value.Sum(e => myTierList.ContainsKey(e.ChartId) && myTierList[e.ChartId].Category != TierListCategory.Unrecorded && e.Category != TierListCategory.Unrecorded ?
            (int)TierListCategory.Unrecorded - (int)Math.Abs(e.Category - myTierList[e.ChartId].Category)
            : 0));

        var chartWeights = new Dictionary<Guid, int>();

        foreach (var kv in userTiersLists)
            foreach (var entry in kv.Value.Where(e => e.Category != TierListCategory.Unrecorded))
            {
                if (!chartWeights.ContainsKey(entry.ChartId))
                {
                    chartWeights[entry.ChartId] = 0;
                }
                chartWeights[entry.ChartId] += (TierListCategory.Unrecorded - entry.Category) * userTotals[kv.Key];
            }
        return ProcessIntoTierList("Similar Players", chartWeights);
        

    }

    private IEnumerable<SongTierListEntry> ProcessIntoTierList(string tierListName, IDictionary<Guid, int> chartWeights)
    {
        var standardDeviationCompare =
            TierListSaga.StdDev(chartWeights.Select(s => s.Value), false);
        var averageCompare = chartWeights.Average(kv => kv.Value);
        var mediumMinCompare = averageCompare - standardDeviationCompare / 2;
        var easyMinCompare = averageCompare + standardDeviationCompare / 2;
        var veryEasyMinCompare = averageCompare + standardDeviationCompare;
        var oneLevelOverratedCompare = averageCompare + standardDeviationCompare * 1.5;
        var hardMinCompare = averageCompare - standardDeviationCompare;
        var veryHardMinCompare = averageCompare - standardDeviationCompare * 1.5;
        var result = new List<SongTierListEntry>();
        var order = 0;
        foreach (var chart in chartWeights.OrderBy(kv => kv.Value))
        {
            var score = chart.Value;
            var myCategory = TierListCategory.Overrated;
            if (score == 0)
                myCategory = TierListCategory.Unrecorded;
            else if (score < veryHardMinCompare)
                myCategory = TierListCategory.Underrated;
            else if (score < hardMinCompare)
                myCategory = TierListCategory.VeryHard;
            else if (score < mediumMinCompare)
                myCategory = TierListCategory.Hard;
            else if (score < easyMinCompare)
                myCategory = TierListCategory.Medium;
            else if (score < veryEasyMinCompare)
                myCategory = TierListCategory.Easy;
            else if (score < oneLevelOverratedCompare)
                myCategory = TierListCategory.VeryEasy;
            else
                myCategory = TierListCategory.Overrated;
            result.Add(new SongTierListEntry(tierListName, chart.Key, myCategory, order++));
        }
        return result;
    }
    private async Task Recalculate()
    {
        _isLoading = true;

        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix, _level, _chartType))).ToDictionary(c => c.Id);
        var officialScores = (await Mediator.Send(new GetTierListQuery("Official Scores"))).ToDictionary(s => s.ChartId);
        var scores = (await Mediator.Send(new GetTierListQuery("Scores"))).ToDictionary(s => s.ChartId); 
        var popularity = (await Mediator.Send(new GetTierListQuery("Popularity"))).ToDictionary(s => s.ChartId);
        _popularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Overrated).Select(kv => kv.Key).ToHashSet();
        _unPopularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Underrated).Select(kv => kv.Key).ToHashSet();
        var result = new List<SongTierListEntry>();
        var baseEntries =
            CurrentUser.IsLoggedIn ?
                (await BuildSkillTierList()).ToDictionary(e => e.ChartId)
                : scores.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
        var title = (await Mediator.Send(new GetTierListQuery("Pass Count"))).ToDictionary(s => s.ChartId);
        var similarPlayers = CurrentUser.IsLoggedIn ? (await GetSimilarPlayers(_chartType, _level))
            .ToDictionary(e => e.ChartId) : _charts.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Similar Players", kv.Key, TierListCategory.Unrecorded, 0));
        _categoryLists = new Dictionary<string, IDictionary<Guid, SongTierListEntry>>()
        {
            { "Skill", baseEntries },
            { "Official Scores", officialScores },
            { "Scores", scores },
            { "Popularity", popularity },
            {"Pass Count",title},
            {"Similar Players",similarPlayers}
        };

        foreach (var chartId in _charts.Keys)
        {
            var count = 0.0;
            var currentTotal = 0.0;
            foreach (var listItem in new[] { (officialScores, "Official Scores"), (scores, "Scores"), (popularity, "Popularity"), (baseEntries, "Skill"), (title, "Pass Count"),(similarPlayers,"Similar Players") })
            {
                if (!listItem.Item1.ContainsKey(chartId)||listItem.Item1[chartId].Category == TierListCategory.Unrecorded)
                {
                    continue;
                }
                count += _modifiers[listItem.Item2];
                currentTotal += _modifiers[listItem.Item2] * (double)GetScore(listItem.Item1[chartId].Category);
            }
            var final = currentTotal / (double)count;
            result.Add(new SongTierListEntry("Final", chartId, final < -2.5 ? TierListCategory.Overrated :
                final<-1.5?TierListCategory.VeryEasy:
                final<-.5?TierListCategory.Easy:
                final<=.5?TierListCategory.Medium:
                final<=1.5?TierListCategory.Hard:
                final<=2.5?TierListCategory.VeryHard:
                TierListCategory.Underrated,(int)(final*100.0)));

        }
        _finalEntries = result;
        if (_groupByTierList)
        {
            _finalGroupings = _finalEntries.GroupBy(e => e.Category.ToString()).OrderBy(g => Enum.Parse<TierListCategory>(g.Key))
                .ToArray();
        }
        else
        {
            _finalGroupings = _finalEntries.GroupBy(e => _charts[e.ChartId].ScoringLevel?.ToString("0.0") ?? "Not Enough Data")
                .OrderBy(g => g.Key).ToArray();
        }
        _messages = _finalGroupings.ToDictionary(kv => kv.Key, kv => "");
        foreach (var group in _finalGroupings)
        {
            if (!group.Any(e => (_scores.TryGetValue(e.ChartId,out var s)?s:0)>0))
            {
                _messages[group.Key] = "0% Cleared";
                continue;
            }
            var clearRate = group.Count(e => _scores[e.ChartId] > 0) / (double)group.Count();
            var minScore =(PhoenixScore)group.Where(e => _scores[e.ChartId] > 0).Min(e =>(int) _scores[e.ChartId]);
            var avgScore = (PhoenixScore)(int)group.Where(e => _scores[e.ChartId] > 0).Average(e => _scores[e.ChartId]);
            var maxScore = (PhoenixScore) group.Where(e => _scores[e.ChartId]>0).Max(e => (int)_scores[e.ChartId]);
            _messages[group.Key] = $"{clearRate * 100.0:0.00}% Cleared, {minScore} ({minScore.LetterGrade.GetName()}) - {maxScore} ({maxScore.LetterGrade.GetName()}), {avgScore} ({avgScore.LetterGrade.GetName()}) Average";
        }
        _isLoading = false;
    }
    private async Task SetType(ChartType newType)
    {
        _chartType = newType;
        await Recalculate();
    }

    private async Task SetLevel(int level)
    {
        _level = level;
        await Recalculate();
    }
    protected override async Task OnInitializedAsync()
    {
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).
        ToDictionary(c => c.Id);
        _chartVideos = (await Mediator.Send(new GetChartVideosQuery())).ToDictionary(cv => cv.ChartId, cv => cv.VideoUrl.ToString());
        _chartType = ChartType.Double;
        _level = 18;
        if (CurrentUser.IsLoggedIn)
        {
            var stats = await Mediator.Send(new GetPlayerStatsQuery(CurrentUser.User.Id));
            if (stats.DoublesCompetitiveLevel > 1)
            {
                _level = (int)Math.Round(stats.DoublesCompetitiveLevel);
            }
            if (stats.SinglesCompetitiveLevel > 1 && stats.SinglesCompetitiveLevel > stats.DoublesCompetitiveLevel)
            {
                _chartType = ChartType.Single;
                _level = (int)Math.Round(stats.SinglesCompetitiveLevel);
            }
        }
        await Recalculate();
    }

    public static double StdDev(IEnumerable<double> values,
        bool as_sample)
    {
        // Get the mean.
        double mean = values.Sum() / values.Count();

        // Get the sum of the squares of the differences
        // between the values and the mean.
        var squares_query =
            from double value in values
            select (value - mean) * (value - mean);
        double sum_of_squares = squares_query.Sum();

        if (as_sample)
        {
            return Math.Sqrt(sum_of_squares / (values.Count() - 1));
        }
        else
        {
            return Math.Sqrt(sum_of_squares / values.Count());
        }
    }
}
