@page "/ChartSkills"
@page "/PersonalizedTierList"
@page "/TierLists"
@using MediatR
@using Microsoft.Extensions.Caching.Memory
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Handlers
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.Models.Titles
@using ScoreTracker.Domain.Models.Titles.Interface
@using ScoreTracker.Domain.Models.Titles.Phoenix
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Web.Components
@using ChartType = ScoreTracker.Domain.Enums.ChartType
@using ScoreTracker.Domain.Records
@using ScoreTracker.PersonalProgress.Queries
@using ScoreTracker.Web.Services
@using ScoreTracker.Web.Services.Contracts
@using ScoreTracker.Web.Shared
@using Syncfusion.Blazor.Data
@inject ChartVideoDisplayer VideoDisplayer
<PageTitle>Personalized Tier List</PageTitle>

<MudGrid>
    <MudItem xs="12">
        <MudText Typo="Typo.h3">@L["Tier Lists"]</MudText>
    </MudItem>

    <MudItem xs="12">
        <MudLink Href="/TierLists/Old">Go to Old Tier Lists Page</MudLink>
    </MudItem>

    @if (_isLoading)
    {
        <MudItem xs="12">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true"></MudProgressLinear>
        </MudItem>
    }
    <MudItem xs="12" sm="6">
        <MudSelect T="ChartType" Value="_chartType" ValueChanged="SetType" Label=@L["Chart Type"] Disabled="_isLoading">
            <MudSelectItem T="ChartType" Value="ChartType.Single">Singles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.Double">Doubles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.CoOp">CoOp</MudSelectItem>
        </MudSelect>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudNumericField T="int" Value="_level" Disabled="_isLoading" Min=@(_chartType==ChartType.CoOp?2:1) Max=@(_chartType==ChartType.CoOp?5:28) ValueChanged="SetLevel" Label=@(_chartType==ChartType.CoOp?L["Player Count"]:L["Difficulty Level"]) HideSpinButtons="true">
        </MudNumericField>
    </MudItem>



    @if (CurrentUser.IsLoggedIn)
    {

            <TitleProgressBar AverageRating="_averageRating" Titles="_titleProgress.Where(t => (t.Title is PhoenixDifficultyTitle pdt && pdt.Level == DifficultyFilter) || (ChartTypeFilter == ChartType.CoOp.ToString() && t.Title is PhoenixCoOpTitle))"></TitleProgressBar>


        @if (_unpassedTodos.Any())
        {
            <MudItem xs="12">
                <MudText Typo="Typo.subtitle1">
                    @L.GetString("Unpassed ToDos", _unpassedTodos.Count(), _level)
                </MudText>
            </MudItem>
        }
 
        <MudItem xs="12">
            @foreach (var lamp in _lamps)
            {
                <MudProgressLinear Min="0" Max="_charts.Count()" Style="margin-top:8px;" Color="lamp.Progress>=_charts.Count()?Color.Success:Color.Primary" Value="lamp.Progress">@lamp.Name</MudProgressLinear>
            }
        </MudItem>
    }
    <MudItem xs="12" sm="6">
        <MudSelect T="string" Label=@L["Difficulty Categorization"] Disabled="_isLoading" Value="_tierListType" ValueChanged="SetTierListType">
            @foreach (var type in _tierListTypes)
            {
                if (type.Key == "Chabala" && !_chabalaLinks.ContainsKey((_chartType,_level)))
                {
                    continue;
                }
                <MudSelectItem Value=@type.Key>@type.Value</MudSelectItem>
            }
        </MudSelect>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudSelect T="string" Label="Group By" Disabled="_isLoading" Value="_groupBy" ValueChanged="ChangeGrouping">
            <MudSelectItem T="string" Value=@("Difficulty")>@L["Difficulty Level"]</MudSelectItem>
            <MudSelectItem T="string" Value=@("Scoring Level")>@L["Scoring Level"]</MudSelectItem>
            @if (_chabalaLinks.ContainsKey((_chartType,_level)))
            {
                
                <MudSelectItem T="string" Value=@("Skill")>@L["Skill"]</MudSelectItem>
            }
            @if (CurrentUser.IsLoggedIn)
            {
                
                <MudSelectItem T="string" Value=@("Age")>@L["Age"]</MudSelectItem>
                <MudSelectItem T="string" Value=@("Score")>@L["Score"]</MudSelectItem>
                <MudSelectItem T="string" Value=@("Score Ranking")>@L["Score Ranking (Beta)"]</MudSelectItem>
            }
        </MudSelect>
    </MudItem>

    @if (CurrentUser.IsLoggedIn)
    {
        @if (_chartType != ChartType.CoOp && _tierListType != "Popularity" && _tierListType !="Chabala")
        {

            <MudItem xs="12" sm="4" md="3">
                <MudCheckBox T="bool" Value="_usePersonalizedData" Disabled="_isLoading" ValueChanged="u=>SetUsePersonalized(u)" Label=@L["Personalized Difficulty"]></MudCheckBox>
            </MudItem>
        }
        <MudItem xs="12" sm="4" md="3">
            <MudCheckBox T="bool" @bind-Value="_hidePassed" Disabled="_isLoading" Label=@L["Hide Completed Charts"]></MudCheckBox>
        </MudItem>

        <MudItem xs="12" sm="4" md="3">
            <MudCheckBox T="bool" @bind-Value="_showTodo" Disabled="_isLoading" Label=@L["Show Only ToDo Charts"]></MudCheckBox>
        </MudItem>
    }
    <MudItem xs="12">
        <MudExpansionPanels>
            @if (CurrentUser.IsLoggedInAsAdmin)
            {
                <MudExpansionPanel Text="Admin Tools">
                    <MudGrid>
                        <MudItem xs="4">
                            <MudNumericField T="int" Value="_highlightedModifier" Disabled="_isLoading" ValueChanged="SetHighlighted" Label="HighlightedModifier"></MudNumericField>
                        </MudItem>
                        @foreach (var modifier in _modifiers)
                        {
                            <MudItem xs="4">
                                <MudNumericField T="double" Value="modifier.Value" Disabled="_isLoading" ValueChanged="v => SetCategory(modifier.Key, v)" Label="@modifier.Key"></MudNumericField>
                            </MudItem>
                        }
                    </MudGrid>
                </MudExpansionPanel>

            }
            <MudExpansionPanel Text=@L["Additional Filters"]>
                <MudGrid>

                    <MudItem xs="12">
                        <MudCheckBox T="bool" Value="_textView" ValueChanged="SetTextView" Disabled="_isLoading" Label=@L["Text View"]></MudCheckBox>
                    </MudItem>
                    @foreach (var type in Enum.GetValues<SongType>())
                    {
                        <MudItem sm="6" md="3">
                            <MudCheckBox T="bool" Label="@type.ToString()" Disabled="_isLoading" Value="_filteredTypes.Contains(type)" ValueChanged="v => ToggleSongType(type, v)"></MudCheckBox>
                        </MudItem>
                    }
                    <MudItem xs="12" md="4">
                        <MudAutocomplete T="string" Label=@L["Song Name"] Disabled="_isLoading" AdornmentIcon="@Icons.Material.Filled.Search" @bind-Value="_songFilter" SearchFunc="(s,c)=>FilterSongName(s)" CoerceText="false" CoerceValue="true"></MudAutocomplete>
                    </MudItem>
                    <MudItem xs="12" md="4">
                        <MudSelect T="string" @bind-SelectedValues="_stepArtists" Disabled="_isLoading" Label=@L["Step Artist"] HelperText="Not All Step Artists Labeled Yet" MultiSelection="true" Clearable="true">
                            @foreach (var artist in _availableStepArtists)
                            {
                                <MudSelectItem T="string" Value="@artist">@artist</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                    <MudItem xs="12" md="4">
                        <MudSelect T="string" @bind-SelectedValues="_songArtists" Disabled="_isLoading" Label=@L["Song Artist"] MultiSelection="true" Clearable="true">
                            @foreach (var artist in _availableSongArtists)
                            {
                                <MudSelectItem T="string" Value="@artist">@artist</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>
                    @if (_lowestBpm != _highestBpm)
                    {

                        <MudItem xs="6">
                            <MudNumericField T="decimal?" Clearable="true" @bind-Value="_bpmMin" Disabled="_isLoading" Label=@L["Min BPM"] Min="_lowestBpm" Max="_highestBpm" HelperText="Not All BPMS Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                        <MudItem xs="6">
                            <MudNumericField T="decimal?" Clearable="true" @bind-Value="_bpmMax" Disabled="_isLoading" Label=@L["Max BPM"] Min="_lowestBpm" Max="_highestBpm" HelperText="Not All BPMS Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                    }
                    @if (_lowestNoteCount != _highestNoteCount)
                    {

                        <MudItem xs="6">
                            <MudNumericField T="int?" Clearable="true" @bind-Value="_noteCountMin" Label=@L["Min Note Count"] Min="_lowestNoteCount" Max="_highestNoteCount" HelperText="Not All Note Counts Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                        <MudItem xs="6">
                            <MudNumericField T="int?" Clearable="true" @bind-Value="_noteCountMax" Label=@L["Max Note Count"] Min="_lowestNoteCount" Max="_highestNoteCount" HelperText="Not All Note Counts Labeled Yet" HideSpinButtons="true"></MudNumericField>
                        </MudItem>
                    }
                    @if (CurrentUser.IsLoggedIn)
                    {
                        <MudItem xs="6">
                            <MudSwitch T="bool" Value="_showAge" ValueChanged="c=>SetShowAge(c)" Disabled="_isLoading" Label=@L["Show Age"] Color="Color.Primary"></MudSwitch>
                        </MudItem>
                    }
                </MudGrid>
            </MudExpansionPanel>
        </MudExpansionPanels>
    </MudItem>
    @if (_isLoading)
    {
        <MudItem xs="12">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true"></MudProgressLinear>
        </MudItem>
    }
    @if (_tierListType == "Chabala" && _chabalaLinks.ContainsKey((_chartType,_level)))
    {
        <MudItem xs="12">
            <MudLink Href="@_chabalaLinks[(_chartType,_level)]" Target="_blank">Original Chabala Tier List</MudLink>
        </MudItem>
    }
    @if (_groupBy == "Score Ranking")
    {
        <MudItem xs="12">
            
            <MudText>Score Ranking: What percent of players of comparable (+/- .5 competitive level) your score is on a chart.</MudText>
            </MudItem>
    }
    @if (_finalEntries.Any() && _finalEntries.All(e=>_charts.ContainsKey(e.ChartId)))
    {
        @foreach (var group in _finalGroupings.Where(g=>g.Any(ShouldChartShow)))
        {
            <MudItem xs="12">
                <MudText Typo="Typo.h6">@group.Key.ToString()</MudText>
                @if (_textView)
                {
                    @if (_clearRate.TryGetValue(group.Key, out var cr) && cr>0)
                    {
                        
                        <MudText>@($"{_clearRate[group.Key]*100:N1}")% Cleared, @_minScores[group.Key] (@_minScores[group.Key].LetterGrade.GetName()) - @_maxScores[group.Key] (@_maxScores[group.Key].LetterGrade.GetName()), @_averageScores[group.Key] (@_averageScores[group.Key].LetterGrade.GetName()) Average</MudText>
                    }
                    else
                    {
                        <MudText>0% Cleared</MudText>
                    }
                }
            </MudItem>
            if (!_textView)
            {
                if (_clearRate.TryGetValue(group.Key, out var cr) && cr > 0)
                {
                    if (_groupBy != "Age" && _groupBy != "Score" &&  _groupBy!="Score Ranking")
                    {

                    <MudItem xs="12" sm="6">
                        <MudProgressLinear Max="1" Min="0" Value="_clearRate[group.Key]" Color="_clearRate[group.Key]>=100.0?Color.Success:Color.Primary">
                            @($"{_clearRate[group.Key]*100.0:N1}%")
                        </MudProgressLinear>
                        </MudItem>
                        <MudItem xs="0" sm="6"></MudItem>
                    }
                    <MudItem xs="12">
                        <ScoreBreakdown Score="_minScores[group.Key]"></ScoreBreakdown> -> <ScoreBreakdown Score="_maxScores[group.Key]"></ScoreBreakdown>, <ScoreBreakdown Score="_averageScores[group.Key]"></ScoreBreakdown> Average
                    </MudItem>
                }
                else
                {

                    if (_groupBy != "Age" && _groupBy != "Score" && _groupBy !="Score Ranking")
                    {
                        <MudItem xs="12" sm="6">
                            <MudProgressLinear Max="1" Min="0" Value="_clearRate[group.Key]" Color="Color.Primary">
                                0%
                            </MudProgressLinear>
                        </MudItem>
                        <MudItem xs="0" sm="6"></MudItem>
                    }
                }
            }

            foreach (var chart in group.Where(ShouldChartShow).Select(c => _charts[c.ChartId]))
            {
                
                @if (_textView)
                {
                    <MudItem xs="12" Style="padding-top:0px;padding-bottom:0px;">
                        
                        <MudText Color=@(_scores.ContainsKey(chart.Id) && _scores[chart.Id].Score>0 ? Color.Success : _todos.Contains(chart.Id)?Color.Info: Color.Default)>
                            @($"{chart.Song.Name} {chart.DifficultyString}") @(_scores.ContainsKey(chart.Id)&&_scores[chart.Id].Score>0?$"- {_scores[chart.Id].Score!.Value.ToGradeString()}":"")
                        </MudText>
                    </MudItem>
                }
                else
                {
                    <MudItem xs="6" sm="3" md="2">

                        <MudCard Class="@CardClass(chart.Id)" Style="@CardStyle(chart.Id)">
                            <MudCardHeader Style=@($"background-image:url(\"{chart.Song.ImagePath}\");")>
                                
                                <DifficultyBubble Chart="chart"></DifficultyBubble>
                            </MudCardHeader>
                            @if ((_scores.TryGetValue(chart.Id, out var sz) ? sz.Score : 0) > 0 || chart.Skills.Any()||_groupBy!="Difficulty")
                            {
                                <MudCardContent>
                                    @if (_groupBy != "Difficulty")
                                    {
                                        <MudText>
                                            @if (_tierListType == "Popularity")
                                            {
                                                
                                                <MudText Style=@($"color:{TierListColor(_chartDifficulties[chart.Id])}")>@_popularityNames[_chartDifficulties[chart.Id]]</MudText>
                                            } else if (_chartDifficulties[chart.Id] == TierListCategory.Unrecorded && _tierListType == "Chabala")
                                            {

                                                <MudText Style=@($"color:{TierListColor(_chartDifficulties[chart.Id])}")>Subjective</MudText>
                                            }
                                            else
                                            {

                                                <MudText Style=@($"color:{TierListColor(_chartDifficulties[chart.Id])}")>@_chartDifficulties[chart.Id]</MudText>
                                            }
                                        </MudText>
                                    }
                                    @if (_groupBy != "Skill")
                                    {
                                        
                                        @foreach (var skill in chart.Skills)
                                        {
                                            <MudChip T="string" Size="Size.Small" Style=@($"background-color:{skill.GetColor()}")>@skill.GetName()</MudChip>

                                        }
                                    }
                                    @if ((_scores.TryGetValue(chart.Id, out var s) ? s.Score : 0) > 0){
                                        
                                        <br/>
                                        <ScoreBreakdown Score="_scores[chart.Id].Score!.Value" IsBroken="_scores[chart.Id].IsBroken" OneLine="true" ShowScore="true" Plate="_scores[chart.Id].Plate"></ScoreBreakdown>
                                        @if (_groupBy == "Score Ranking" && _scoreRankings.TryGetValue(chart.Id, out var rating))
                                        {
                                            <MudText Style=@($"color:{RankingColor(rating)}")>@((rating*100.0).ToString("N1"))%</MudText>
                                        }
                                        @if (_showAge)
                                        {
                                            <MudText>@(_ages[chart.Id].ToString("0")) @L["Days Old"]</MudText>
                                    }
                                    }
                                </MudCardContent>
                            }
                            <MudCardActions>
                                @if (_topCharts.Contains(chart.Id))
                                {
                                    <MudTooltip Text=@($"Top 50 {chart.Type}s")>
                                        <MudIcon Icon="@PiuScoresIcons.Crown" Style="color:#00ffff"></MudIcon>
                                    </MudTooltip>
                                }
                                <MudSpacer>
                                </MudSpacer>
                                @if (_charTitles.TryGetValue(chart.Id, out var title))
                                {
                                    <MudTooltip Text=@($"{string.Join(',', title.Select(n => n.ToString()))}")>
                                        <MudIcon Color="Color.Warning" Icon="@Icons.Material.Filled.Star"></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_popularCharts.Contains(chart.Id) && _tierListType != "Popularity")
                                {
                                    <MudTooltip Text="This chart is extra popular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingUp></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_unPopularCharts.Contains(chart.Id) && _tierListType != "Popularity")
                                {

                                    <MudTooltip Text="This chart is extra unpopular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingDown></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_variance.TryGetValue(chart.Id, out var varianceLevel) && varianceLevel != "Normal")
                                {
                                    <MudTooltip Text=@($"{varianceLevel} Score Variance")>
                                        <MudIcon Icon=@Icons.Material.Filled.GraphicEq Style=@($"color:{(varianceLevel=="Very High"?MudBlazor.Colors.Red.Darken1:varianceLevel=="High"?MudBlazor.Colors.Orange.Darken1:varianceLevel=="Low"?MudBlazor.Colors.Green.Darken1:MudBlazor.Colors.Blue.Darken1)}")></MudIcon>
                                    </MudTooltip>
                                }
                                @if (CurrentUser.IsLoggedIn)
                                {
                                    <MudIconButton Icon="@Icons.Material.Outlined.ListAlt" OnClick="() => ToggleToDo(chart.Id)" Color="_todos.Contains(chart.Id) ? Color.Primary : Color.Default"></MudIconButton>

                                }

                                <MudIconButton Icon="@Icons.Custom.Brands.YouTube" OnClick="@(() => VideoDisplayer.ShowVideo(chart.Id))"></MudIconButton>
                               
                            </MudCardActions>
                        </MudCard>
                    </MudItem>
                }
            }
        }

    }
    @if (!_isLoading && _averageSkillScore.Any(kv=>kv.Value>0))
    {
        <MudItem xs="12">
            <MudText Typo="Typo.h5">Skill Scores</MudText>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Speed Score Averages"
                       Options="_avgSpeedChartOptions"
                       Height="400"
                       @ref=_skillChart>

                <ApexPointSeries TItem="SkillEntry"
                                 Items="_averageSkillScore.Keys.Where(s=>s.IsCategory(SkillCategory.Speed) && _skillProgress.ContainsKey(s)).Select(s=>new SkillEntry(s,_skillProgress[s]))"
                                 Name="Speed Score Average"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />

            </ApexChart>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Skill Score Averages"
                       Options="_avgScoreChartOptions"
                       Height="400"
                       @ref=_speedSkillChart
            >

                <ApexPointSeries TItem="SkillEntry"
                                 Items="_averageSkillScore.Keys.Where(s=>!s.IsCategory(SkillCategory.Speed) && _skillProgress.ContainsKey(s)).Select(s=>new SkillEntry(s,_skillProgress[s]))"
                                 Name="Skill Score Average"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />

            </ApexChart>
        </MudItem>

        <MudItem xs="12">
            <MudText Typo="Typo.h5">Skill Passes</MudText>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Speed Passes"
                       Options="_avgSpeedChartPassOptions"
                       Height="400"
                       @ref=_skillChart>

                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillPassCount.Where(kv=>kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Passes"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />
                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillMaxCount.Where(kv=>kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Charts in Folder"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />


            </ApexChart>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Skill Passes"
                       Options="_avgSkillChartPassOptions"
                       Height="400"
                       @ref=_skillChart>

                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillPassCount.Where(kv=>!kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Passes"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />
                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillMaxCount.Where(kv=>!kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Charts in Folder"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />


            </ApexChart>
        </MudItem>
    }
</MudGrid>
<style>
.apexcharts-text {
        fill: #FFA726;
        font-weight:bold;
        padding-left:10px;
}
</style>
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject NavigationManager NavManager;
@inject ITierListRepository TierLists;
@inject ITitleRepository Titles;
@inject IUiSettingsAccessor UiSettings;
@inject IAdminNotificationClient Notifications;
@inject ISnackbar Snackbar;
@inject IPhoenixRecordRepository Records;
@inject IPlayerStatsRepository PlayerStats;
@inject IMemoryCache Cache;
@code
{

    private readonly ApexChartOptions<SkillEntry> _avgSpeedChartPassOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {

  return val.toFixed(0);
      }"
            }
            }}.ToList()
    };
    private readonly ApexChartOptions<SkillEntry> _avgSkillChartPassOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {

  return val.toFixed(0);
      }"
            }
        }}.ToList()
    };
    private readonly ApexChartOptions<SkillEntry> _avgSpeedChartOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Max=7,
            TickAmount = 7,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {


  if(index==0){
    return 'PG'
  }
  if(index==1){
    return 'SSS';
  }
  if(index==2){
    return 'SS';
  }
  if(index==3){
    return 'S';
  }
  if(index==4){
    return 'AAA';
  }
  if(index==5){
    return 'AA';
  }
  if(index==6){
    return 'A';
  }

  return '';
      }"
            }
        }}.ToList(),

    };
    private readonly ApexChartOptions<SkillEntry> _avgScoreChartOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Max=7,
            TickAmount = 7,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {

  if(index==0){
    return 'PG'
  }
  if(index==1){
    return 'SSS';
  }
  if(index==2){
    return 'SS';
  }
  if(index==3){
    return 'S';
  }
  if(index==4){
    return 'AAA';
  }
  if(index==5){
    return 'AA';
  }
  if(index==6){
    return 'A';
  }

  return '';
      }"
            }
        }}.ToList(),

    };
    
    private ApexChart<SkillEntry>? _speedSkillChart;
    
    private ApexChart<SkillEntry>? _skillChart;
    private ApexChart<SkillEntry>? _speedSkillPassChart;

    private ApexChart<SkillEntry>? _skillPassChart;
    [Parameter]
    [SupplyParameterFromQuery(Name = "Difficulty")]
    public int? DifficultyFilter { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "ChartType")]
    public string? ChartTypeFilter { get; set; } = string.Empty;

    [Parameter]
    [SupplyParameterFromQuery(Name = "TierListType")]
    public string? TierListType { get; set; } = string.Empty;
    private DateTimeOffset _now = DateTimeOffset.Now;
    private IDictionary<Skill, List<Chart>> SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());

    private IDictionary<Skill, PhoenixScore> _averageSkillScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => PhoenixScore.Min);
    private IDictionary<Skill, double> _skillProgress = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
    private IDictionary<Skill, int> _skillPassCount = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> _skillMaxCount = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);

    private IDictionary<Guid, RecordedPhoenixScore> _scores = new Dictionary<Guid, RecordedPhoenixScore>();
    private IDictionary<Guid, RecordedPhoenixScore> _folderScores = new Dictionary<Guid, RecordedPhoenixScore>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private ISet<Guid> _unPopularCharts = new HashSet<Guid>();
    private ISet<Guid> _popularCharts = new HashSet<Guid>();

    private sealed record SkillEntry(Skill Skill, double Metric, string Category="None");
    private async Task SetTextView(bool newSetting)
    {
        await UiSettings.SetSetting("TierLists__TextView", newSetting.ToString());
        _textView = newSetting;
    }
    private ISet<SongType> _filteredTypes = new HashSet<SongType>();
    private IEnumerable<string> _stepArtists = new HashSet<string>();
    private IDictionary<Guid, int> _ages = new Dictionary<Guid, int>(); 
    private IEnumerable<string> _songArtists = new HashSet<string>();
    private IDictionary<Guid, IEnumerable<Name>> _charTitles = new Dictionary<Guid, IEnumerable<Name>>();
    private IEnumerable<PhoenixTitle> _titles = Array.Empty<PhoenixTitle>();
    private IEnumerable<Guid> _unpassedTodos => _finalEntries.Select(e => e.ChartId).Where(chartId => _scores.ContainsKey(chartId)&& _scores[chartId].IsBroken && _todos.Contains(chartId));
    private IDictionary<Guid, TierListCategory> _chartDifficulties = new Dictionary<Guid, TierListCategory>();
    private Name[] _availableStepArtists = Array.Empty<Name>();
    private Name[] _availableSongArtists = Array.Empty<Name>();
    private int _lowestNoteCount = 0;
    private int _highestNoteCount = 0;
    private decimal _lowestBpm = 0;
    private decimal _highestBpm = 0;
    private ChartType _chartType = ChartType.Single;
    private bool _textView = false;
    private bool _isLoading = false;
    private bool _showTodo = false;
    private bool _showAge = false;
    private decimal? _bpmMin;
    private decimal? _bpmMax;
    private int? _noteCountMin;
    private int? _noteCountMax;
    private ISet<Guid> _todos = new HashSet<Guid>();

    private sealed record LampProgress(string Name, int Order, int Progress);

    private IEnumerable<LampProgress> _lamps = Array.Empty<LampProgress>();
    private IEnumerable<TitleProgress> _titleProgress = Array.Empty<TitleProgress>();
    private Task<IEnumerable<string>> FilterSongName(string search) => Task.FromResult(_finalEntries.Select(c => _charts[c.ChartId].Song.Name.ToString()).Distinct().Where(
        n => string.IsNullOrWhiteSpace(search)|| n.Contains(search, StringComparison.OrdinalIgnoreCase)).OrderBy(n => n == search ? 0 : 1).AsEnumerable());
    private string TierListColor(TierListCategory category) => category switch{
        TierListCategory.Overrated=>Colors.Cyan.Darken1,
        TierListCategory.VeryEasy=>Colors.Green.Darken1,
        TierListCategory.Easy=>Colors.LightGreen.Darken1,
        TierListCategory.Medium=>Colors.Yellow.Darken1,
        TierListCategory.Hard=>Colors.Orange.Darken1,
        TierListCategory.VeryHard=>Colors.Red.Darken1,
        TierListCategory.Underrated=>Colors.Purple.Darken1,
        TierListCategory.Unrecorded=>Colors.Gray.Darken1,
    };
    private IDictionary<Guid, string> _variance = new Dictionary<Guid, string>();
    private async Task CalculateVariance(ChartType chartType, DifficultyLevel level)
    {
        var scores = (await Records.GetAllPlayerScores(chartType, level)).ToArray();
        var players = (await PlayerStats.GetStats(scores.Select(s => s.userId).Distinct().ToArray(), CancellationToken.None))
            .Where(p => Math.Abs((_chartType == ChartType.Single ? p.SinglesCompetitiveLevel : p.DoublesCompetitiveLevel) - level) < 2.0).ToDictionary(p => p.UserId);

        var chartGroups = scores.GroupBy(r => r.record.ChartId).ToDictionary(g => g.Key, g => g.Where(k => players.ContainsKey(k.userId) && k.record is { Score: not null, IsBroken: false }).Select(k => k.record!.Score).ToArray());


        var chartStandards = chartGroups.Where(kv => kv.Value.Count() > 5)
            .Select(kv => (_charts[kv.Key], TierListSaga.StdDev(kv.Value.Select(s => (int)s!.Value), true)))
            .ToArray();

        if (!chartStandards.Any())
        {
            return;
        }
        var average = chartStandards.Average(c => c.Item2);
        var standardDev = TierListSaga.StdDev(chartStandards.Select(c => c.Item2), true);
        var results = chartStandards
            .Select(kv => (kv.Item1, (kv.Item2-average)/standardDev))
            .ToArray();

        _variance = results.ToDictionary(r => r.Item1.Id, r => r.Item2 <= -2.0 ? "Very Low" :
            r.Item2 <= -1.0 ? "Low" :
                r.Item2 >= 2.0 ? "Very High" :
                    r.Item2 >= 1.0 ? "High" : "Normal");

    }
    private void ToggleSongType(SongType s, bool v)
    {
        if (v)
        {
            _filteredTypes.Add(s);
        }
        else
        {
            _filteredTypes.Remove(s);
        }
    }

    private string RankingColor(double ranking) =>
        ranking <= .1 ? "#BDBDBD" :
            ranking <= .25 ? "#FAFAFA" :
                ranking <= .5 ? "#76FF03" :
                    ranking <= .75 ? "#1565C0" :
                        ranking <= .9 ? "#7E57C2" :
                            ranking <= .99 ? "#EC407A" :
                                "#FB8C00";
    private bool ShouldChartShow(SongTierListEntry entry)
    {
        if (_hidePassed && _scores.TryGetValue(entry.ChartId, out var s) && !s.IsBroken)
        {
            return false;
        }
        if (_showTodo && !_todos.Contains(entry.ChartId))
        {
            return false;
        }
        var chart = _charts[entry.ChartId];
        if (_filteredTypes.Any() && !_filteredTypes.Contains(chart.Song.Type))
        {
            return false;
        }
        if (!string.IsNullOrWhiteSpace(_songFilter) && !chart.Song.Name.ToString().Contains(_songFilter, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        if (_bpmMax != null && (chart.Song.Bpm == null || chart.Song.Bpm.Value.Max > _bpmMax))
        {
            return false;
        }
        if (_bpmMin != null && (chart.Song.Bpm == null || chart.Song.Bpm.Value.Min < _bpmMin))
        {
            return false;
        }
        if (_stepArtists.Any() && !_stepArtists.Contains(chart.StepArtist?.ToString() ?? "Unknown",StringComparer.OrdinalIgnoreCase))
        {
            return false;
        }
        if (_songArtists.Any() && !_songArtists.Contains(chart.Song.Artist.ToString(), StringComparer.OrdinalIgnoreCase))
        {
            return false;
        }
        if (_noteCountMin != null && (chart.NoteCount != null || _noteCountMin >= chart.NoteCount))
        {
            return false;
        }
        if (_noteCountMax != null && (chart.NoteCount != null || _noteCountMax <= chart.NoteCount))
        {
            return false;
        }
        return true;
    }
    private int _highlightedModifier = 10;
    private bool _hidePassed = false;
    private bool _showSettings = false;
    private string _groupBy = "Tier List";
    private int _level = 20;
    private IDictionary<Guid, double> _scoreRankings = new Dictionary<Guid, double>();
    private string _tierListType = "Pass";
    private string _songFilter;
    private async Task SetShowAge(bool newSetting)
    {
        _showAge = newSetting;
        await UiSettings.SetSetting("TierLists__ShowAge", newSetting.ToString());
    }
    private bool _usePersonalizedData = true;
    private IEnumerable<IGrouping<string, SongTierListEntry>>
    _finalGroupings = Array.Empty<IGrouping<string, SongTierListEntry>>();
    private string ChartSearch(Chart chart)
    {
        var searchString = "Pump It Up " + chart.Song.Name + " " + chart.DifficultyString;
        return $"https://www.youtube.com/results?search_query={searchString.Replace("%", "Percent ").Replace(" ", "+")}";
    }

    private async Task SetUsePersonalized(bool newUse)
    {
        _usePersonalizedData = newUse;

        await SetTierListType(_tierListType);
    }
    private async Task SetTierListType(string type)
    {
        _tierListType = type;
        SetQueryString();
        if (_tierListType == "Chabala")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 0 },
                {"Similar Players", 0},
                { "Popularity", 0 },
                { "Pass Count",0},
                {"Chabala",1}
            };
        }
        if (_tierListType == "Pass")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 2 },
                {"Similar Players", 1},
                { "Popularity", 0 },
                { "Pass Count",2},
                {"Chabala",0}
            };

        }
        if (_tierListType == "Score")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 1 },
                { "Scores", 2 },
                { "Skill", 2 },
                {"Similar Players",1},
                { "Popularity", 0 },
                { "Pass Count",0},
                {"Chabala",0}
            };
        }
        if (_tierListType == "Popularity")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 0 },
                { "Popularity", 1 },
                { "Pass Count",0},
                {"Similar Players",0},
                {"Chabala",0}
            };
        }
        if (!_usePersonalizedData)
        {
            _modifiers["Skill"] = 0;
            _modifiers["Similar Players"] = 0;
        }
        await Recalculate();
    }

    private async Task ChangeGrouping(string newGrouping)
    {
        _groupBy = newGrouping;
        await Recalculate();
    }

    private void SetQueryString()
    {

        NavManager.NavigateTo(NavManager.GetUriWithQueryParameters(new Dictionary<string, object?>
        {
            { "Difficulty", _level },
            { "ChartType", _chartType.ToString() },
            {"TierListType",_tierListType}
        }));
    }
    private string CategoryColor(TierListCategory category) => category switch
    {
        TierListCategory.Overrated=>"#00FFFF",
        TierListCategory.VeryEasy=>"#00FFBB",
        TierListCategory.Easy=>"#00FF55",
        TierListCategory.Medium=>"#00FF00",
        TierListCategory.Hard=>"#55BB00",
        TierListCategory.VeryHard=>"#BB5500",
        TierListCategory.Underrated=>"#FF0000",
        TierListCategory.Unrecorded=>"#888888"
    };
    public async Task ToggleToDo(Guid chartId)
    {
        if (!_todos.Contains(chartId))
        {
            await Mediator.Send(new SaveChartToListCommand(ChartListType.ToDo, chartId));
            Snackbar.Add("Added to ToDo List!", Severity.Success);
            _todos.Add(chartId);
        }
        else
        {
            await Mediator.Send(new RemoveChartFromListCommand(ChartListType.ToDo, chartId));
            Snackbar.Add("Removed from ToDo List!", Severity.Success);
            _todos.Remove(chartId);
        }
        StateHasChanged();
    }
    private string CardClass(Guid chartId) =>
        _scores.TryGetValue(chartId,out var broken)&&!broken.IsBroken? "chart-card border-solid border-2" : "chart-card border-dashed border-2";

    private string CardStyle(Guid chartId) =>
        _scores.TryGetValue(chartId, out var broken) && !broken.IsBroken ? $@"border-color:{MudBlazor.Colors.Green.Darken1}" : "";
    private async Task SetHighlighted(int newModifier)
    {
        _highlightedModifier = newModifier;
        await Recalculate();
    }

    private async Task SetCategory(string category, double modifier)
    {
        _modifiers[category] = modifier;
        await Recalculate();
    }

    private static readonly PhoenixLetterGrade[] _validLetterGrades = new[]
    {
        PhoenixLetterGrade.A,
        PhoenixLetterGrade.AA,
        PhoenixLetterGrade.AAA,
        PhoenixLetterGrade.S,
        PhoenixLetterGrade.SS,
        PhoenixLetterGrade.SSS
    };

    private async Task<IEnumerable<SongTierListEntry>> BuildSkillTierList()
    {

        @if (!_charts.Any(kv => kv.Value.Skills.Any()))
        {
            _averageSkillScore.Clear();
            return _charts.Select(kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
        }
        SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());

        SkillCharts = _charts.Values.SelectMany(c => c.Skills.Select(s => (c,s))).GroupBy(g => g.s).ToDictionary(g => g.Key, g => g.Select(kv => kv.c).ToList());
        _averageSkillScore = SkillCharts.ToDictionary(kv => kv.Key, kv =>
            kv.Value.Any(c => _scores.TryGetValue(c.Id, out var s) && s is { Score: not null,IsBroken: false }) ?
                (PhoenixScore)(int)kv.Value.Where(c => _scores.TryGetValue(c.Id, out var s) && s.Score != null && !s.IsBroken)
                    .Average(c => _scores[c.Id].Score!.Value)
                : PhoenixScore.Min);

        _skillMaxCount = SkillCharts.ToDictionary(kv => kv.Key, kv => kv.Value.Count());
        _skillPassCount = SkillCharts.ToDictionary(kv => kv.Key, kv => kv.Value.Count(c => _scores.TryGetValue(c.Id, out var s) && !s.IsBroken));

        foreach (var kv in _averageSkillScore)
        {
            if (kv.Value == PhoenixScore.Max)
            {
                _skillProgress[kv.Key] = _validLetterGrades.Length;
                continue;
            }
            if (kv.Value < _validLetterGrades.Min().GetMinimumScore())
            {
                _skillProgress[kv.Key] = 0;
                continue;
            }
            var lowGrade = _validLetterGrades.Reverse().First(g => g.GetMinimumScore() <= kv.Value);
            var lowIndex = _validLetterGrades.IndexOf(lowGrade);
            var highScore = lowIndex == _validLetterGrades.Length-1 ? PhoenixScore.Max : _validLetterGrades[lowIndex + 1].GetMinimumScore();
            _skillProgress[kv.Key] = 1.0+ (double)lowIndex + (kv.Value - lowGrade.GetMinimumScore()) / (double)(highScore - lowGrade.GetMinimumScore());
        }
        var avgEstimates = _charts.Values.Where(c => c.Skills.Any(s => _averageSkillScore[s] > 0)).ToDictionary(c => c.Id, c =>
            c.Skills.Where(s => _averageSkillScore[s] > 0).Average(s => _averageSkillScore[s]));

        if (_speedSkillChart != null)
        {
            await _speedSkillChart.UpdateSeriesAsync(true);
            await _speedSkillChart.UpdateOptionsAsync(true, true, true);
        }
        if (_skillChart != null)
        {
            await _skillChart.UpdateSeriesAsync(true);
            await _skillChart.UpdateOptionsAsync(true, true, true);
        }

        if (_skillMaxCount.Any(kv => kv.Key.IsCategory(SkillCategory.Speed)))
        {
            
            _avgSpeedChartPassOptions.Yaxis.First().Max = _skillMaxCount.Where(kv => kv.Key.IsCategory(SkillCategory.Speed)).Max(kv => kv.Value);

        }
        if (_skillMaxCount.Any(kv => !kv.Key.IsCategory(SkillCategory.Speed)))
        {

            _avgSkillChartPassOptions.Yaxis.First().Max = _skillMaxCount.Where(kv => !kv.Key.IsCategory(SkillCategory.Speed)).Max(kv => kv.Value);
        }
        if (_skillPassChart != null)
        {
            await _skillPassChart.UpdateSeriesAsync(true);
            await _skillPassChart.UpdateOptionsAsync(true, true, true);
        }
        if (_speedSkillPassChart != null)
        {
            await _speedSkillPassChart.UpdateSeriesAsync(true);
            await _speedSkillPassChart.UpdateOptionsAsync(true,true,true);
        }
        if (_charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s is {Score:not null, IsBroken:false})<10 || 
            _averageSkillScore.Count(kv=>kv.Value>0)<3)
        {
            return _charts.Select(kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
            
        }
        return TierListSaga.ProcessIntoTierList("Skill", avgEstimates)
            .Concat(_charts.Values.Where(c => !c.Skills.Any(s => _averageSkillScore[s] > 0)).Select(s => new SongTierListEntry("Skill", s.Id, TierListCategory.Unrecorded, 9999)))
            .ToArray();

    }

    private IEnumerable<SongTierListEntry> _finalEntries = Array.Empty<SongTierListEntry>();
    private IDictionary<string, double> _clearRate = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => 0.0);
    private IDictionary<string, PhoenixScore> _minScores = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => PhoenixScore.Min);
    private IDictionary<string, PhoenixScore> _averageScores = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => PhoenixScore.Min);
    private IDictionary<string, PhoenixScore> _maxScores = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => PhoenixScore.Min);
    private IDictionary<string, double> _modifiers = new Dictionary<string, double>()
    {
        { "Official Scores", 0 },
        { "Scores", 1 },
        { "Skill", 2 },
        { "Popularity", .5 },
        { "Pass Count",2},
        {"Similar Players",1},
        {"Chabala",0}
    };


    private int GetScore(TierListCategory category) => (int)category - 3;
    private int _averageRating = 1;
    private async Task<IEnumerable<SongTierListEntry>> GetSimilarPlayers(ChartType type, int level)
    {

        var myLevel = await Titles.GetCurrentTitleLevel(CurrentUser.User.Id, CancellationToken.None);
        var lowLevel = await TierLists.GetUsersOnLevel(myLevel - 1, CancellationToken.None);
        var onMyLevel = await TierLists.GetUsersOnLevel(myLevel - 1, CancellationToken.None);
        var highLevel = await TierLists.GetUsersOnLevel(myLevel - +1, CancellationToken.None);
        var userIds = (lowLevel)
            .Concat(onMyLevel)
            .Concat(highLevel)
            .Where(u => u != CurrentUser.User.Id);
        var userTiersLists = new Dictionary<Guid, IEnumerable<SongTierListEntry>>();
        var myTierList = (await Mediator.Send(new GetMyRelativeTierListQuery(type, level)))
            .ToDictionary(r => r.ChartId);
        foreach (var userId in userIds)
        {
            userTiersLists[userId] = await Mediator.Send(new GetMyRelativeTierListQuery(type, level, userId));
        }
        var userTotals = userTiersLists.ToDictionary(kv => kv.Key, kv => kv.Value.Sum(e => myTierList.ContainsKey(e.ChartId) && myTierList[e.ChartId].Category != TierListCategory.Unrecorded && e.Category != TierListCategory.Unrecorded ?
            (int)TierListCategory.Unrecorded - (int)Math.Abs(e.Category - myTierList[e.ChartId].Category)
            : 0));

        var chartWeights = new Dictionary<Guid, int>();

        foreach (var kv in userTiersLists)
            foreach (var entry in kv.Value.Where(e => e.Category != TierListCategory.Unrecorded))
            {
                if (!chartWeights.ContainsKey(entry.ChartId))
                {
                    chartWeights[entry.ChartId] = 0;
                }
                chartWeights[entry.ChartId] += (TierListCategory.Unrecorded - entry.Category) * userTotals[kv.Key];
            }
        return TierListSaga.ProcessIntoTierList("Similar Players", chartWeights);
        

    }

    private ISet<Guid> _topCharts = new HashSet<Guid>();
    private static readonly IDictionary<TierListCategory, string> _scoreNames = new Dictionary<TierListCategory, string>()
    {
        { TierListCategory.Overrated, "Amazing" },
        { TierListCategory.VeryEasy, "Very Good" },
        { TierListCategory.Easy, "Good" },
        { TierListCategory.Medium, "Average" },
        { TierListCategory.Hard, "Low" },
        { TierListCategory.VeryHard, "Very Low" },
        { TierListCategory.Underrated, "Why Don't You Get Up and Dance, Man?" },
        { TierListCategory.Unrecorded, "Not Recorded" }
    };
    private static readonly IDictionary<TierListCategory, string> _ageNames = new Dictionary<TierListCategory, string>()
    {
        { TierListCategory.Overrated, "Ancient" },
        { TierListCategory.VeryEasy, "Very Old" },
        { TierListCategory.Easy, "Old" },
        { TierListCategory.Medium, "Average" },
        { TierListCategory.Hard, "New" },
        { TierListCategory.VeryHard, "Very New" },
        { TierListCategory.Underrated, "Most Recent" },
        { TierListCategory.Unrecorded, "Not Recorded" }
    };
    private static readonly IDictionary<TierListCategory, string> _popularityNames = new Dictionary<TierListCategory, string>()
    {
        { TierListCategory.Unrecorded, "Unknown" },
        { TierListCategory.Overrated, "Ultra Popular" },
        { TierListCategory.VeryEasy, "Very Popular" },
        { TierListCategory.Easy, "Popular" },
        { TierListCategory.Medium, "Average" },
        { TierListCategory.Hard, "Unpopular" },
        { TierListCategory.VeryHard, "Very Unpopular" },
        { TierListCategory.Underrated, "Ultra Unpopular" }
    };

    private IDictionary<string, IDictionary<TierListCategory, string>> _tierListCategoryNames = new Dictionary<string, IDictionary<TierListCategory, string>>()
    {
        { "Popularity", _popularityNames },
        { "Score", _scoreNames },
        { "Age", _ageNames }

    };
    private async Task Recalculate()
    {
        _isLoading = true;
        await UiSettings.SetSetting("TierLists__Level", _level.ToString());
        await UiSettings.SetSetting("TierLists__ChartType", _chartType.ToString());
        await UiSettings.SetSetting("TierLists__ListType", _tierListType);
        await UiSettings.SetSetting("TierLists__UsePersonalized", _usePersonalizedData.ToString());
        await UiSettings.SetSetting("TierLists__GroupBy", _groupBy);
        await UiSettings.SetSetting("TierLists__HideCompleted", _hidePassed.ToString());
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix, _level, _chartType))).ToDictionary(c => c.Id);
        _folderScores = _scores.Where(kv => _charts.ContainsKey(kv.Key)).ToDictionary(kv => kv.Key, kv => kv.Value);
        var titles = _titles.Where(t => t is ISpecificChartTitle).ToArray();
        _charTitles = _charts.Values.SelectMany(c => titles.Select(t => (c,t,((ISpecificChartTitle)t).AppliesToChart(c))))
            .Where(v => v.Item3).GroupBy(v=>v.c.Id).ToDictionary(g =>g.Key,g=> g.Select(v => v.t.Name).ToArray().AsEnumerable());
        
        var popularity = (await Mediator.Send(new GetTierListQuery("Popularity"))).ToDictionary(s => s.ChartId);
        _popularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Overrated).Select(kv => kv.Key).ToHashSet();
        _unPopularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Underrated).Select(kv => kv.Key).ToHashSet();
        
        
        

        var cacheKey = $"{nameof(ChartSkills)}__TierList__{_tierListType}__{_chartType}__{_level}";
        if (_usePersonalizedData && CurrentUser.IsLoggedIn)
        {
            cacheKey += $"__{CurrentUser.User.Id}";
        }

        var skillTierList = new Dictionary<Guid, SongTierListEntry>();
        if (CurrentUser.IsLoggedIn)
        {
            //This also builds the skill breakdowns at bottom of page
            skillTierList =   (await BuildSkillTierList()).ToDictionary(e => e.ChartId);
        }
        
        _finalEntries = await Cache.GetOrCreateAsync(cacheKey, async o =>
        {
            o.AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(6);
            o.SlidingExpiration = TimeSpan.FromHours(1);
            var scores = (await Mediator.Send(new GetTierListQuery("Scores"))).ToDictionary(s => s.ChartId); 
            var baseEntries =
                CurrentUser.IsLoggedIn ? skillTierList
                    : scores.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
            var officialScores = (await Mediator.Send(new GetTierListQuery("Official Scores"))).ToDictionary(s => s.ChartId);
            var chabala = (await Mediator.Send(new GetTierListQuery("Chabala"))).ToDictionary(s => s.ChartId);
            var similarPlayers = new Dictionary<Guid, SongTierListEntry>();
        var title = (await Mediator.Send(new GetTierListQuery("Pass Count"))).ToDictionary(s => s.ChartId);
            if (CurrentUser.IsLoggedIn && _usePersonalizedData)
            {
                similarPlayers = CurrentUser.IsLoggedIn ? (await GetSimilarPlayers(_chartType, _level))
                    .ToDictionary(e => e.ChartId) : _charts.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Similar Players", kv.Key, TierListCategory.Unrecorded, 0));

            }

            var result = new List<SongTierListEntry>();
            foreach (var chartId in _charts.Keys)
            {
                var count = 0.0;
                var currentTotal = 0.0;
                foreach (var listItem in new[] { (officialScores, "Official Scores"),(chabala,"Chabala"), (scores, "Scores"), (popularity, "Popularity"), (baseEntries, "Skill"), (title, "Pass Count"), (similarPlayers,"Similar Players") })
                {
                    if (!listItem.Item1.ContainsKey(chartId) || listItem.Item1[chartId].Category == TierListCategory.Unrecorded)
                    {
                        continue;
                    }
                    count += _modifiers[listItem.Item2];
                    currentTotal += _modifiers[listItem.Item2] * (double)GetScore(listItem.Item1[chartId].Category);
                }
                if (count < .0001)
                {
                    result.Add(new SongTierListEntry("Final", chartId, TierListCategory.Unrecorded, 999999));
                    continue;
                }
                var final = currentTotal / (double)count;
                result.Add(new SongTierListEntry("Final", chartId, final < -2.5 ? TierListCategory.Overrated :
                    final < -1.5 ? TierListCategory.VeryEasy :
                        final < -.5 ? TierListCategory.Easy :
                            final <= .5 ? TierListCategory.Medium :
                                final <= 1.5 ? TierListCategory.Hard :
                                    final <= 2.5 ? TierListCategory.VeryHard :
                                        TierListCategory.Underrated, (int)(final * 100.0)));

            }
            return result;
        }) ?? throw new Exception("Tier list could not be retrieved from cache");
        _chartDifficulties = _finalEntries.ToDictionary(e => e.ChartId, e => e.Category);

        if (_groupBy=="Difficulty")
        {
            _finalGroupings = _finalEntries
                .OrderBy(e=>e.Order)
                .GroupBy(e =>
                    _tierListCategoryNames.TryGetValue(_groupBy,out var names)?names[e.Category]:
                    _tierListType=="Popularity"?_popularityNames[e.Category]:
                        _tierListType=="Chabala"&&e.Category==TierListCategory.Unrecorded?"Subjective":
                    e.Category.ToString()).OrderBy(g => g.First().Category)
                .ToArray();
        } else if (_groupBy == "Skill")
        {
            _finalGroupings = _finalEntries
                .OrderBy(e=>_chartDifficulties[e.ChartId])
                .ThenBy(e=>e.Order)
                .GroupBy(e => _charts[e.ChartId].Skills.Any() ? string.Join(' ', _charts[e.ChartId].Skills.OrderBy(s => s).Select(s => s.GetName())) : "Not Rated")
                .OrderBy(g => _charts[g.First().ChartId].Skills.Any()?(int) _charts[g.First().ChartId].Skills.Min():999999)
                .ToArray();
        } else if (_groupBy == "Score")
        {
            var tierList = TierListSaga.ProcessIntoTierList("Score", _folderScores.Where(kv => kv.Value.Score != null).ToDictionary(kv => kv.Key, kv => (int)kv.Value.Score!.Value))
                .ToDictionary(kv => kv.ChartId);
            _finalGroupings = _finalEntries.OrderBy(e => _scores.TryGetValue(e.ChartId, out var s) ? s.Score ?? PhoenixScore.Min : PhoenixScore.Max)
                .GroupBy(e => _scores.ContainsKey(e.ChartId) ? _scoreNames[tierList[e.ChartId].Category] : _scoreNames[TierListCategory.Unrecorded])
                .ToArray();
        }
        else if (_groupBy == "Age")
        {
            if (_folderScores.Values.Select(s => s.RecordedDate).Distinct().Count() < 5)
            {
                _finalGroupings = _finalEntries.GroupBy(kv => _ageNames[TierListCategory.Unrecorded])
                    .ToArray();
            }
            else
            {
                
                var now = DateTimeOffset.Now;
                var tierList = TierListSaga.ProcessIntoTierList("Score", _folderScores.Where(kv => kv.Value.Score != null).ToDictionary(kv => kv.Key, kv => (now - kv.Value.RecordedDate).TotalDays))
                    .ToDictionary(kv => kv.ChartId);
                _finalGroupings = _finalEntries.OrderByDescending(e => _scores.TryGetValue(e.ChartId, out var s) ? (now - s.RecordedDate).TotalDays : -1)
                    .GroupBy(e => _scores.ContainsKey(e.ChartId) ? _ageNames[tierList[e.ChartId].Category] : _ageNames[TierListCategory.Unrecorded])
                    .ToArray();
            }
        }
        else if (_groupBy == "Score Ranking")
        {
            _scoreRankings = await Mediator.Send(new GetPlayerScoreQualityQuery(_level, _chartType));
            _finalGroupings = _finalEntries
                .OrderBy(e => _scoreRankings.TryGetValue(e.ChartId, out var r) ? r : 99999)
                .GroupBy(e => _scoreRankings.TryGetValue(e.ChartId, out var r) ?
                    (r <= 0.01 ?
                        "Last Place" :
                        r <= 0.10 ?
                            "0 -> 10%" :
                            r <= 0.25 ?
                                "10% -> 25%" :
                                r <= .5 ?
                                    "25% -> 50%" :
                                    r <= .75 ?
                                        "50% -> 75%" :
                                        r <= .9 ?
                                            "75% -> 90%" :
                                            r>.99?
                                                "The Best":
                                            "90% -> 99.9%"
                        )
                    : "Not Recorded")
                .ToArray();
        }
        else
        {
            _finalGroupings = _finalEntries
                .OrderBy(e => _chartDifficulties[e.ChartId])
                .ThenBy(e => e.Order).GroupBy(e => _charts[e.ChartId].ScoringLevel?.ToString("0.0") ?? "Not Enough Data")
                .OrderBy(g => double.TryParse(g.Key,out var d)?d:10000).ToArray();
        }
        foreach (var group in _finalGroupings)
        {
            var clearRate = 0.0;
            if (group.Any(e => (_scores.TryGetValue(e.ChartId,out var s) && !s.IsBroken)))
            {
                clearRate = group.Count(e => _scores.TryGetValue(e.ChartId, out var s) && !s.IsBroken) / (double)group.Count();
            }
            var scoredCharts = group.Where(e => _scores.TryGetValue(e.ChartId, out var score) && score.Score>0).ToArray();
            if (!scoredCharts.Any())
            {
                _clearRate[group.Key] = 0.0;

                continue;
            }
            _clearRate[group.Key] = clearRate;
            _minScores[group.Key]= (PhoenixScore)scoredCharts.Min(e => (int)_scores[e.ChartId].Score!);
            _averageScores[group.Key]= (PhoenixScore)(int)scoredCharts.Average(e => _scores[e.ChartId].Score!);
            _maxScores[group.Key] = (PhoenixScore)scoredCharts.Max(e => (int)_scores[e.ChartId].Score!);

        }
        var charts = _finalEntries.Select(e => _charts[e.ChartId]).ToArray();
        _lowestBpm = charts.Any(c => c.Song.Bpm != null) ? charts.Where(c => c.Song.Bpm != null).Min(c => c.Song.Bpm!.Value.Min) : 0;
        _bpmMin = null;
        _highestBpm = charts.Any(c => c.Song.Bpm != null) ? charts.Where(c => c.Song.Bpm != null).Max(c => c.Song.Bpm!.Value.Max) : 0;
        _bpmMax = null;
        _lowestNoteCount = charts.Any(c => c.NoteCount != null) ? charts.Where(c => c.NoteCount != null).Min(c => c.NoteCount!.Value) : 0;
        _noteCountMin = null;
        _highestNoteCount = charts.Any(c => c.NoteCount != null) ? charts.Where(c => c.NoteCount != null).Max(c => c.NoteCount!.Value) : 0;
        _noteCountMax = null;
        _availableStepArtists = charts.Select(c => c.StepArtist ?? "Unknown").Distinct().OrderBy(s=>s).ToArray();
        _availableSongArtists = charts.Select(c => c.Song.Artist).Distinct().OrderBy(s=>s).ToArray();
        _stepArtists = new HashSet<string>();
        _songArtists = new HashSet<string>();

        var baseRating = DifficultyLevel.From(_level).BaseRating;
        if (_chartType == ChartType.CoOp)
        {
            baseRating = 2000;
        }
        _averageRating = _folderScores.Any(kv => !_scores[kv.Key].IsBroken && kv.Value.Score > 0) ? (int)_folderScores.Where(kv => !_scores[kv.Key].IsBroken && kv.Value.Score > 0).Average(s => s.Value.Score!.Value.LetterGrade.GetModifier() * baseRating) : baseRating;
        await CalculateVariance(_chartType, _level);

        var lamps = new List<LampProgress>();
        lamps.Add(new LampProgress("Pass",0,_charts.Count(kv=>_scores.TryGetValue(kv.Key,out var b)&&!b.IsBroken)));
        var order = 1;
        for (var grade = PhoenixLetterGrade.AA; grade <= PhoenixLetterGrade.SSSPlus; grade++)
        {
            lamps.Add(new LampProgress(grade.GetName(), order++,
                _charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s.Score?.LetterGrade >= grade)));
        }
        lamps.Add(new LampProgress("PG", order, _charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s.Score == PhoenixScore.Max)));
        _lamps = lamps;
        _isLoading = false;
    }
    private async Task SetType(ChartType newType)
    {
        _chartType = newType;
        if (_chartType == ChartType.CoOp && _level is < 2 or > 4)
        {
            _level = 2;
        }
        if (_chartType == ChartType.CoOp && _usePersonalizedData)
        {
            _usePersonalizedData = false;
            _modifiers["Skill"] = 0;
            _modifiers["Similar Players"] = 0;
        }
        SetQueryString();
        await Recalculate();
    }

    private async Task SetLevel(int level)
    {
        _level = level;
        if (_tierListType == "Chabala" && !_chabalaLinks.ContainsKey((_chartType,level)))
        {
            _tierListType = "Difficulty";
        }
        if (_groupBy == "Skill" && !_chabalaLinks.ContainsKey((_chartType,level)))
        {
            _groupBy = "Difficulty";
        }
        SetQueryString();
        await Recalculate();
    }

    private IDictionary<(ChartType,DifficultyLevel), string> _chabalaLinks = new Dictionary<(ChartType, DifficultyLevel), string>()
    {
        { (ChartType.Single,19), "https://drive.google.com/file/d/1A5D6tlFVU2HMwzNO34TQLOx1ie78XwTx/view?usp=drive_link" },
        { (ChartType.Single,20), "https://drive.google.com/file/d/1dOxTW1wkdozZMmlOO2yUMy2JggA6Mhej/view?usp=drive_link" },
        { (ChartType.Single,21), "https://drive.google.com/file/d/1oQh8ZlPhpP0F8Mcn2QV8rjpB7GZEebUU/view?usp=drive_link" },
        { (ChartType.Single,22), "https://drive.google.com/file/d/1oZm4kS26TTvdeyVnIwpktldOeQ188lFQ/view?usp=drive_link" },
        { (ChartType.Single,23), "https://drive.google.com/file/d/160VfJaXtXW6OxgD0Y-pN-rnvOWf-of97/view?usp=drive_link" },
        { (ChartType.Single,24), "https://drive.google.com/file/d/1t21N5FfWfPICeT0GopdCNaXjHqzAILUY/view?usp=drive_link" },
        { (ChartType.Single,25), "https://drive.google.com/file/d/13rPx7mrdhg37iNSdmQMc07CsRb7kkgBP/view?usp=drive_link" },
        { (ChartType.Single,26), "https://drive.google.com/file/d/13rPx7mrdhg37iNSdmQMc07CsRb7kkgBP/view?usp=drive_link" },
        { (ChartType.Double,19), "https://drive.google.com/file/d/1uDXcbC7dCmTDh6r3i72AmW7f1qraJgCu/view?usp=drive_link" },
        { (ChartType.Double,20), "https://drive.google.com/file/d/1uDXcbC7dCmTDh6r3i72AmW7f1qraJgCu/view?usp=drive_link" },
        { (ChartType.Double,21), "https://drive.google.com/file/d/1zuguWTvp3NgyyKpTPHwuSTmGtxRmm8rN/view?usp=drive_link" },
        { (ChartType.Double,22), "https://drive.google.com/file/d/1Mj8JCVx3K6xwz_3D9SDjLQyFuCPiVKcG/view?usp=drive_link" },
        { (ChartType.Double,23), "https://drive.google.com/file/d/1m00Ng0-5m4FLrMKlTqiKjWbQiC_Gglhk/view?usp=drive_link" },
        { (ChartType.Double,24), "https://drive.google.com/file/d/1t21N5FfWfPICeT0GopdCNaXjHqzAILUY/view?usp=drive_link" },
        { (ChartType.Double,25), "https://drive.google.com/file/d/13rPx7mrdhg37iNSdmQMc07CsRb7kkgBP/view?usp=drive_link" },
        { (ChartType.Double,26), "https://drive.google.com/file/d/1zCQO8gKKvrZiCw9TfjFy7JTtog_U9uve/view?usp=drive_link" },
        { (ChartType.Double,27), "https://drive.google.com/file/d/1zCQO8gKKvrZiCw9TfjFy7JTtog_U9uve/view?usp=drive_link" },
        { (ChartType.Double,28), "https://drive.google.com/file/d/1zCQO8gKKvrZiCw9TfjFy7JTtog_U9uve/view?usp=drive_link" },
    };
    protected override async Task OnInitializedAsync()
    {
        if (CurrentUser.IsLoggedIn)
        {
            
            _scores = (await Mediator.Send(new GetPhoenixRecordsQuery(CurrentUser.User.Id)))
                .ToDictionary(c => c.ChartId);
            _ages = _scores.ToDictionary(c => c.Key, c => (int)(_now - c.Value.RecordedDate).TotalDays); 
        }
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).
          ToDictionary(c => c.Id);
        _titles = PhoenixTitleList.BuildList();
        _chartType = ChartType.Double;
        _level = 18;
        _tierListTypes=new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "Pass", L["Pass (Data Backed)"] },
            { "Score", L["Score (Data Backed)"] },
            { "Popularity", L["Popularity (PIIU Game Leaderboard)"] },
            {"Chabala","Chabala"}
        };

        if (CurrentUser.IsLoggedIn)
        {

            _topCharts = (await Mediator.Send(new GetTop50CompetitiveQuery(CurrentUser.User.Id, ChartType.Double)))
                .Concat(await Mediator.Send(new GetTop50CompetitiveQuery(CurrentUser.User.Id, ChartType.Single)))
                .Select(c => c.ChartId).Distinct().ToHashSet();
            var stats = await Mediator.Send(new GetPlayerStatsQuery(CurrentUser.User.Id));
            if (stats.DoublesCompetitiveLevel > 1)
            {
                
                _level = (int)Math.Round(stats.DoublesCompetitiveLevel);
            }
            if (stats.SinglesCompetitiveLevel > 1 && stats.SinglesCompetitiveLevel > stats.DoublesCompetitiveLevel)
            {
                _chartType = ChartType.Single;
                _level = (int)Math.Round(stats.SinglesCompetitiveLevel);
            }
            _todos = (await Mediator.Send(new GetSavedChartsQuery())).Where(c => c.ListType == ChartListType.ToDo).Select(c => c.ChartId).Distinct().ToHashSet();
        }
        _showAge = bool.TryParse(await UiSettings.GetSetting("TierLists__ShowAge"), out var res) && res;
        _level = int.TryParse(await UiSettings.GetSetting("TierLists__Level"), out var l) ? l : 18;
        _chartType = Enum.TryParse<ChartType>(await UiSettings.GetSetting("TierLists__ChartType"), out var cType) ? cType : ChartType.Double;
        _tierListType = await UiSettings.GetSetting("TierLists__ListType") ?? "Pass";
        _usePersonalizedData = (await UiSettings.GetSetting("TierLists__UsePersonalized") ?? true.ToString()) == true.ToString();
        _groupBy = await UiSettings.GetSetting("TierLists__GroupBy") ?? "Difficulty";
        _textView = (await UiSettings.GetSetting("TierLists__TextView") ?? false.ToString()) == true.ToString();
        if (DifficultyFilter is >= 1 and <= 28)
        {
            _level = DifficultyFilter.Value;
        }
        _titleProgress = (await Mediator.Send(new GetTitleProgressQuery(MixEnum.Phoenix))).ToArray();
        if (Enum.TryParse<ChartType>(ChartTypeFilter, out var chartType))
        {
            _chartType = chartType;
        }
        if (TierListType!=null && _tierListTypes.ContainsKey(TierListType))
        {
            await SetTierListType(TierListType);
        }
        else
        {
            await SetTierListType(_tierListType);
        }
    }

    private IDictionary<string, string> _tierListTypes = new Dictionary<string, string>();
    public static double StdDev(IEnumerable<double> values,
        bool as_sample)
    {
        // Get the mean.
        double mean = values.Sum() / values.Count();

        // Get the sum of the squares of the differences
        // between the values and the mean.
        var squares_query =
            from double value in values
            select (value - mean) * (value - mean);
        double sum_of_squares = squares_query.Sum();

        if (as_sample)
        {
            return Math.Sqrt(sum_of_squares / (values.Count() - 1));
        }
        else
        {
            return Math.Sqrt(sum_of_squares / values.Count());
        }
    }
}
