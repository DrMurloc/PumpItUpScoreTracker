@page "/ChartSkills"
@page "/PersonalizedTierList"
@page "/TierLists"
@using MediatR
@using Microsoft.Extensions.Caching.Memory
@using ScoreTracker.Application.Commands
@using ScoreTracker.Application.Handlers
@using ScoreTracker.Application.Queries
@using ScoreTracker.Domain.SecondaryPorts
@using ScoreTracker.Domain.Enums
@using ScoreTracker.Domain.Models
@using ScoreTracker.Domain.Models.Titles
@using ScoreTracker.Domain.Models.Titles.Interface
@using ScoreTracker.Domain.Models.Titles.Phoenix
@using ScoreTracker.Domain.ValueTypes
@using ScoreTracker.Web.Components
@using ChartType = ScoreTracker.Domain.Enums.ChartType
@using ScoreTracker.Domain.Records
@using ScoreTracker.PersonalProgress.Queries
@using ScoreTracker.Web.Services
@using ScoreTracker.Web.Services.Contracts
@using ScoreTracker.Web.Shared
@using System.Text.Json
@using System.ComponentModel
@using System.Drawing
@using Discord
@using Microsoft.OpenApi
@inject ChartVideoDisplayer VideoDisplayer
<PageTitle>PIU Tier List</PageTitle>
<HeadContent>
    <meta name="description" content="PIU Charts organized by difficulty with optional personalization based on individual skill."/>
    <meta property="og:title" content="PIU Tier List">
    <meta property="og:description" content="PIU Charts organized by difficulty with optional personalization based on individual skill." >
</HeadContent>
<MudGrid>
    <MudItem xs="12">
        <MudText Typo="Typo.h3">@L["Tier Lists"]</MudText>
    </MudItem>

    <MudItem xs="12">
        <MudLink Href="/TierLists/Old">Go to Old Tier Lists Page</MudLink>
    </MudItem>

    <MudItem xs="12" sm="6">
        <MudSelect T="ChartType" Value="_chartType" ValueChanged="SetType" Label=@L["Chart Type"] Disabled="_isLoading">
            <MudSelectItem T="ChartType" Value="ChartType.Single">Singles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.Double">Doubles</MudSelectItem>
            <MudSelectItem T="ChartType" Value="ChartType.CoOp">CoOp</MudSelectItem>
        </MudSelect>
    </MudItem>
    <MudItem xs="12" sm="6">
        <MudNumericField T="int" Value="_level" Disabled="_isLoading" Min=@(_chartType==ChartType.CoOp?2:1) Max=@(_chartType==ChartType.CoOp?5:DifficultyLevel.Max) ValueChanged="SetLevel" Label=@(_chartType==ChartType.CoOp?L["Player Count"]:L["Difficulty Level"]) HideSpinButtons="true">
        </MudNumericField>
    </MudItem>



    @if (CurrentUser.IsLoggedIn)
    {

            <TitleProgressBar AverageRating="_averageRating" Titles="_titleProgress.Where(t => (t.Title is PhoenixDifficultyTitle pdt && pdt.Level == DifficultyFilter) || (ChartTypeFilter == ChartType.CoOp.ToString() && t.Title is PhoenixCoOpTitle))"></TitleProgressBar>


        @if (_unpassedTodos.Any())
        {
            <MudItem xs="12">
                <MudText Typo="Typo.subtitle1">
                    @L.GetString("Unpassed ToDos", _unpassedTodos.Count(), _level)
                </MudText>
            </MudItem>
        }
 
        <MudItem xs="12">
            @foreach (var lamp in _lamps)
            {
                <MudProgressLinear Min="0" Max="_charts.Count()" Style="margin-top:8px;" Color="lamp.Progress>=_charts.Count()?Color.Success:Color.Primary" Value="lamp.Progress">@lamp.Name</MudProgressLinear>
            }
        </MudItem>
        @if (_competitivePlayerCount > 0 && _finalEntries.Where(e => _scoreRankings.ContainsKey(e.ChartId)).Any())
        {
            var rating = _finalEntries.Where(e => _scoreRankings.ContainsKey(e.ChartId)).Average(e => _scoreRankings[e.ChartId].Ranking);
            <MudItem xs="12">
                <MudText>
                    Averaging better than <div style=@($"display:inline;{RankingColors.ColorStyle(rating)}")>@((100.0*rating).ToString("N2"))%</div> of @_competitivePlayerCount similar players in this folder.
                </MudText>
            </MudItem>
        }
    }
    <MudItem xs="12" sm="6">
        <MudSelect T="string" Label=@L["Difficulty Categorization"] Disabled="_isLoading" Value="_tierListType" ValueChanged="SetTierListType">
            @foreach (var type in _tierListTypes)
            {
                if (type.Key == "Chabala" && !_chabalaLinks.ContainsKey((_chartType,_level)))
                {
                    continue;
                }
                <MudSelectItem Value=@type.Key>@type.Value</MudSelectItem>
            }
        </MudSelect>
    </MudItem>
<MudItem xs="12" sm="6">
    <MudSelect T="string" Label="Group By" Disabled="_isLoading" Value="_groupBy" ValueChanged="ChangeGrouping">
        <MudSelectItem T="string" Value=@("Difficulty")>@L["Difficulty Level"]</MudSelectItem>
        <MudSelectItem T="string" Value=@("Scoring Level")>@L["Scoring Level"]</MudSelectItem>
        @if (_chabalaLinks.ContainsKey((_chartType,_level)))
        {
                
            <MudSelectItem T="string" Value=@("Skill")>@L["Skill"]</MudSelectItem>
        }
        @if (CurrentUser.IsLoggedIn)
        {
                
            <MudSelectItem T="string" Value=@("Age")>@L["Age"]</MudSelectItem>
            <MudSelectItem T="string" Value=@("Score")>@L["Score"]</MudSelectItem>
            <MudSelectItem T="string" Value=@("Score Ranking")>@L["Score Ranking"]</MudSelectItem>
        }
    </MudSelect>
</MudItem>


    <MudItem xs="6" sm="3">
        <MudMenu Label=@L["Settings"] StartIcon="@Icons.Material.Filled.Settings" Variant="Variant.Outlined" Color="Color.Primary">
            <MudMenuItem OnClick="()=>SetTextView(!_textView)">
                @if (_textView)
                {
                    <MudIcon Color="Color.Success" Icon="@Icons.Material.Filled.Check" Size="Size.Small"></MudIcon>
                }
                @L["Text View"]
            </MudMenuItem>
            <MudMenuItem OnClick="ToggleShowSkills">
                @if (_settings.ShowSkills)
                {
                    <MudIcon Color="Color.Success" Icon="@Icons.Material.Filled.Check" Size="Size.Small"></MudIcon>
                }
                @L["Show Skills"]
            </MudMenuItem>
            <MudMenuItem OnClick="ToggleShowDifficulty">
                @if (_settings.ShowDifficulty)
                {
                    <MudIcon Color="Color.Success" Icon="@Icons.Material.Filled.Check" Size="Size.Small"></MudIcon>
                }
                @L["Show Difficulty"]
            </MudMenuItem>
            <MudMenuItem OnClick="ToggleShowName">
                @if (_settings.ShowSongName)
                {
                    <MudIcon Color="Color.Success" Icon="@Icons.Material.Filled.Check" Size="Size.Small"></MudIcon>
                }
                @L["Show Song Name"]
            </MudMenuItem>
            <MudMenuItem OnClick="ToggleShowStepArtist">
                @if (_settings.ShowStepArtist)
                {
                    <MudIcon Color="Color.Success" Icon="@Icons.Material.Filled.Check" Size="Size.Small"></MudIcon>
                }
                @L["Show Step Artist"]
            </MudMenuItem>
            @if (CurrentUser.IsLoggedIn)
            {
                @if (_chartType != ChartType.CoOp && _tierListType != "Popularity" && _tierListType != "Chabala")
                {
                    <MudMenuItem OnClick="() => SetUsePersonalized(!_usePersonalizedData)">
                        @if (_usePersonalizedData)
                        {
                            <MudIcon Color="Color.Success" Icon="@Icons.Material.Filled.Check" Size="Size.Small"></MudIcon>
                        }
                        @L["Personalized Difficulty"]
                    </MudMenuItem>
                }
                <MudMenuItem OnClick="() => SetShowAge(!_showAge)">
                    @if (_showAge)
                    {
                        <MudIcon Color="Color.Success" Icon="@Icons.Material.Filled.Check" Size="Size.Small"></MudIcon>
                    }
                    @L["Show Age"]
                </MudMenuItem>
            }
        </MudMenu>    

    </MudItem>
<MudItem xs="6" sm="3">
    <MudMenu Label=@L["Filters"] StartIcon="@Icons.Material.Filled.FilterList" Variant="Variant.Outlined" Color="Color.Primary">
        @foreach (var filter in Enum.GetValues<Filter>().OrderBy(e => e.ToString()))
        {
            <MudMenuItem OnClick="()=>ToggleFilter(filter)">
                @if (_settings.ShowingFilters.Contains(filter))
                {
                    <MudIcon Size="Size.Small" Color="Color.Success" Icon="@Icons.Material.Filled.Check"></MudIcon>
                }
                @_filterNames[filter]
            </MudMenuItem>
        }
    </MudMenu>
</MudItem>
<MudItem xs="6" sm="3">
    <MudButton OnClick="DownloadImage" Color="Color.Primary" Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.FileDownload" Disabled="_isBuildingImage">Download</MudButton>
</MudItem>
    @if (_settings.ShowingFilters.Contains(Filter.SongName))
    {

        <MudItem xs="12" sm="3">
            <MudAutocomplete T="string" Label=@L["Song Name"] Disabled="_isLoading" AdornmentIcon="@Icons.Material.Filled.Search" @bind-Value="_songFilter" SearchFunc="(s,c)=>FilterSongName(s)" CoerceText="false" CoerceValue="true"></MudAutocomplete>
        </MudItem>
    }
    @if (_settings.ShowingFilters.Contains(Filter.SongType))
    {
        <MudItem xs="12" sm="3">
            <MudSelect T="SongType" Clearable="true" MultiSelection="true" SelectedValues="_settings.SongTypes" SelectedValuesChanged="SetSongTypeFilter" Disabled="_isLoading" Label=@L["Song Type"]>
                @foreach (var type in Enum.GetValues<SongType>())
                {
                    <MudSelectItem T="SongType" Value="type">@type</MudSelectItem>
                }
            </MudSelect>
        </MudItem>
    }
    @if (_settings.ShowingFilters.Contains(Filter.ToDo))
    {

        <MudItem xs="12" sm="3">
            <MudCheckBox T="bool?" Value="_settings.ToDo" ValueChanged="SetTodoFilter" TriState="true" Disabled="_isLoading" Label=@L["To Do"]></MudCheckBox>
        </MudItem>
    }
    @if (_settings.ShowingFilters.Contains(Filter.SongArtist))
    {
        <MudItem xs="12" sm="3">
            <MudSelect T="string" SelectedValues="_settings.SongArtists" SelectedValuesChanged="SetSelectedSongArtists" Disabled="_isLoading" Label=@L["Song Artist"] MultiSelection="true" Clearable="true">
                @foreach (var artist in _availableSongArtists)
                {
                    <MudSelectItem T="string" Value="@artist">@artist</MudSelectItem>
                }      
            </MudSelect>
        </MudItem>
    }
    @if (_settings.ShowingFilters.Contains(Filter.StepArtist))
    {
        <MudItem xs="12" sm="3">
            <MudSelect T="string" SelectedValues="_settings.StepArtists" SelectedValuesChanged="SetSelectedStepArtists" Disabled="_isLoading" Label=@L["Step Artist"] HelperText="Not All Step Artists Labeled Yet"  MultiSelection="true" Clearable="true">
              @foreach (var artist in _availableStepArtists)
                 {
                     <MudSelectItem T="string" Value="@artist">@artist</MudSelectItem>
                 }
            </MudSelect>
        </MudItem>
    }
    @if (_settings.ShowingFilters.Contains(Filter.BPM) && _lowestBpm != _highestBpm)
    {

        <MudItem xs="6" sm="3">
            <MudNumericField T="decimal?" Clearable="true" Value="_settings.MinBpm" ValueChanged="SetSelectedMinBpm" Disabled="_isLoading" Label=@L["Min BPM"] Min="_lowestBpm" Max="_highestBpm" HelperText="Not All BPMS Labeled Yet" HideSpinButtons="true"></MudNumericField>
        </MudItem>
        <MudItem xs="6" sm="3">
            <MudNumericField T="decimal?" Clearable="true" Value="_settings.MaxBpm" ValueChanged="SetSelectedMaxBpm" Disabled="_isLoading" Label=@L["Max BPM"] Min="_lowestBpm" Max="_highestBpm" HelperText="Not All BPMS Labeled Yet" HideSpinButtons="true"></MudNumericField>
        </MudItem>
    }
    @if (_settings.ShowingFilters.Contains(Filter.NoteCount) && _lowestNoteCount != _highestNoteCount)
    {

        <MudItem xs="6" sm="3">
            <MudNumericField T="int?" Clearable="true" Value="_settings.MinNoteCount" ValueChanged="SetMinNoteCount" Label=@L["Min Note Count"] Min="_lowestNoteCount" Max="_highestNoteCount" HelperText="Not All Note Counts Labeled Yet" HideSpinButtons="true"></MudNumericField>
        </MudItem>
        <MudItem xs="6" sm="3">
            <MudNumericField T="int?" Clearable="true" Value="_settings.MaxNoteCount" ValueChanged="SetMaxNoteCount" Label=@L["Max Note Count"] Min="_lowestNoteCount" Max="_highestNoteCount" HelperText="Not All Note Counts Labeled Yet" HideSpinButtons="true"></MudNumericField>
        </MudItem>
    }
    @if (CurrentUser.IsLoggedIn)
    {

        @if (_settings.ShowingFilters.Contains(Filter.Completion))
        {
            <MudItem xs="12" sm="3">
                <MudCheckBox T="bool?" TriState="true" Value="_settings.Completion" ValueChanged="SetCompletionFilter" Disabled="_isLoading" Label=@L["Stage Pass"]></MudCheckBox>
            </MudItem>
        }
        @if (_settings.ShowingFilters.Contains(Filter.LetterGrade))
        {
            <MudItem xs="6" sm="3">
                <MudSelect T="PhoenixLetterGrade?" Label=@L["Min Letter Grade"] Value="_settings.MinLetterGrade" ValueChanged="SetMinLetterGrade" Clearable="true">
                    @foreach (var letterGrade in Enum.GetValues<PhoenixLetterGrade>().Reverse())
                    {
                        <MudSelectItem T="PhoenixLetterGrade?" Value="letterGrade">@letterGrade.GetName()</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="6" sm="3">
                <MudSelect T="PhoenixLetterGrade?" Label=@L["Max Letter Grade"] Value="_settings.MaxLetterGrade" ValueChanged="SetMaxLetterGrade" Clearable="true">
                    @foreach (var letterGrade in Enum.GetValues<PhoenixLetterGrade>().Reverse())
                    {
                        <MudSelectItem T="PhoenixLetterGrade?" Value="letterGrade">@letterGrade.GetName()</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
        }
    }
    @if (_isLoading || _isBuildingImage)
    {
        <MudItem xs="12">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true"></MudProgressLinear>
        </MudItem>
    }
    @if (_tierListType == "Chabala" && _chabalaLinks.ContainsKey((_chartType,_level)))
    {
        <MudItem xs="12">
            <MudLink Href="@_chabalaLinks[(_chartType,_level)]" Target="_blank">Original Chabala Tier List</MudLink>
        </MudItem>
    }
    @if (_groupBy == "Score Ranking")
    {
        <MudItem xs="12">
            
            <MudText>Score Ranking: What percent of players of comparable (+/- .5 competitive level) your score is on a chart.</MudText>
            </MudItem>
    }
    @if (_finalEntries.Any() && _finalEntries.All(e=>_charts.ContainsKey(e.ChartId)))
    {
        @foreach (var group in _finalGroupings.Where(g=>g.Any(ShouldChartShow)))
        {
            <MudItem xs="12">
                <MudText Typo="Typo.h6">@group.Key.ToString()</MudText>
                @if (_textView)
                {
                    @if (_clearRate.TryGetValue(group.Key, out var cr) && cr>0)
                    {
                        
                        <MudText>@($"{_clearRate[group.Key]*100:N1}")% Cleared, @_minScores[group.Key] (@_minScores[group.Key].LetterGrade.GetName()) - @_maxScores[group.Key] (@_maxScores[group.Key].LetterGrade.GetName()), @_averageScores[group.Key] (@_averageScores[group.Key].LetterGrade.GetName()) Average</MudText>

                    }
                    else
                    {
                        <MudText>0% Cleared</MudText>
                    }
                }
            </MudItem>
            if (!_textView)
            {
                if (_clearRate.TryGetValue(group.Key, out var cr) && cr > 0)
                {
                    
                     if (_groupBy != "Age" && _groupBy != "Score" &&  _groupBy!="Score Ranking")
                    {

                    <MudItem xs="12" sm="6">
                        <MudProgressLinear Max="1" Min="0" Value="_clearRate[group.Key]" Color="_clearRate[group.Key]>=100.0?Color.Success:Color.Primary">
                            @($"{_clearRate[group.Key]*100.0:N1}%")
                        </MudProgressLinear>
                        </MudItem>
                        <MudItem xs="0" sm="6"></MudItem>
                    }
                    @if (group.Where(e => _scoreRankings.ContainsKey(e.ChartId)).Any())
                    {
                        var ranking = group.Where(e => _scoreRankings.ContainsKey(e.ChartId)).Average(e => _scoreRankings[e.ChartId].Ranking);
                        var players = group.Where(e => _scoreRankings.ContainsKey(e.ChartId)).Max(e => _scoreRankings[e.ChartId].PlayerCount);
                   
                        <MudItem xs="12">
                            <ScoreBreakdown Score="_averageScores[group.Key]" Ranking="new ScoreRankingRecord(ranking,players)" ShowScore="true" OneLine="true"></ScoreBreakdown> Average
                        </MudItem>
                    }

                }
                else
                {

                    if (_groupBy != "Age" && _groupBy != "Score" && _groupBy !="Score Ranking")
                    {
                        <MudItem xs="12" sm="6">
                            <MudProgressLinear Max="1" Min="0" Value="_clearRate[group.Key]" Color="Color.Primary">
                                0%
                            </MudProgressLinear>
                        </MudItem>
                        <MudItem xs="0" sm="6"></MudItem>
                    }
                }
            }

            foreach (var chart in group.Where(ShouldChartShow).Select(c => _charts[c.ChartId]))
            {
                
                @if (_textView)
                {
                    <MudItem xs="12" Style="padding-top:0px;padding-bottom:0px;">
                        
                        <MudText Color=@(_scores.ContainsKey(chart.Id) && _scores[chart.Id].Score>0 ? Color.Success : _todos.Contains(chart.Id)?Color.Info: Color.Default)>
                            @($"{chart.Song.Name} {chart.DifficultyString}") @(_scores.ContainsKey(chart.Id)&&_scores[chart.Id].Score>0?$"- {_scores[chart.Id].Score!.Value.ToGradeString()}":"")
                        </MudText>
                    </MudItem>
                }
                else
                {
                    <MudItem xs="6" sm="3" md="2">

                        <MudCard Class="@CardClass(chart.Id)" Style="@CardStyle(chart.Id)">
                            <MudCardHeader Style=@($"background-image:url(\"{chart.Song.ImagePath}\");")>
                                
                                <DifficultyBubble Chart="chart"></DifficultyBubble>
                            </MudCardHeader>
                            <MudCardContent>
                                @if (_settings.ShowSongName)
                                {
                                    <MudText Typo="Typo.subtitle1" Style=@(chart.Song.Name.Contains("Pneum")?"text-overflow: ellipsis; overflow:hidden;white-space:nowrap;":"")>@chart.Song.Name</MudText>
                                }
                                @if (_settings.ShowStepArtist)
                                {
                                    <MudText Typo="Typo.subtitle1">@chart.StepArtist</MudText>
                                }
                                @if ((_scores.TryGetValue(chart.Id, out var sz) ? sz.Score : 0) > 0 || chart.Skills.Any() || _groupBy != "Difficulty")
                                {
                                    @if (_groupBy != "Difficulty" && _settings.ShowDifficulty)
                                    {
                                        <MudText>
                                            @if (_tierListType == "Popularity")
                                            {

                                                <MudText Style=@($"color:{TierListColor(_chartDifficulties[chart.Id])}")>@_popularityNames[_chartDifficulties[chart.Id]]</MudText>
                                            }
                                            else if (_chartDifficulties[chart.Id] == TierListCategory.Unrecorded && _tierListType == "Chabala")
                                            {

                                                <MudText Style=@($"color:{TierListColor(_chartDifficulties[chart.Id])}")>Subjective</MudText>
                                            }
                                            else
                                            {

                                                <MudText Style=@($"color:{TierListColor(_chartDifficulties[chart.Id])}")>@_chartDifficulties[chart.Id]</MudText>
                                            }
                                        </MudText>
                                    }
                                    @if (_groupBy != "Skill" && _settings.ShowSkills)
                                    {

                                        @foreach (var skill in chart.Skills)
                                        {
                                            <MudChip T="string" Size="Size.Small" Style=@($"background-color:{skill.GetColor()}")>@skill.GetName()</MudChip>

                                        }
                                    }
                                    @if ((_scores.TryGetValue(chart.Id, out var s) ? s.Score : 0) > 0)
                                    {

                                        <br/>
                                        <ScoreBreakdown Score="_scores[chart.Id].Score!.Value" IsBroken="_scores[chart.Id].IsBroken" OneLine="true" ShowScore="true" Plate="_scores[chart.Id].Plate" Ranking="_scoreRankings.TryGetValue(chart.Id, out var r) ? r : null"></ScoreBreakdown>

                                        @if (_showAge)
                                        {
                                            <MudText>@(_ages[chart.Id].ToString("0")) @L["Days Old"]</MudText>
                                        }
                                    }
                                }
                            </MudCardContent>
                            <MudCardActions>
                                @if (_topCharts.Contains(chart.Id))
                                {
                                    <MudTooltip Text=@($"Top 50 {chart.Type}s")>
                                        <MudIcon Icon="@PiuScoresIcons.Crown" Style="color:#00ffff"></MudIcon>
                                    </MudTooltip>
                                }
                                <MudSpacer>
                                </MudSpacer>
                                @if (_charTitles.TryGetValue(chart.Id, out var title))
                                {
                                    <MudTooltip Text=@($"{string.Join(',', title.Select(n => n.ToString()))}")>
                                        <MudIcon Color="Color.Warning" Icon="@Icons.Material.Filled.Star"></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_popularCharts.Contains(chart.Id) && _tierListType != "Popularity")
                                {
                                    <MudTooltip Text="This chart is extra popular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingUp></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_unPopularCharts.Contains(chart.Id) && _tierListType != "Popularity")
                                {

                                    <MudTooltip Text="This chart is extra unpopular and may have skewed data">
                                        <MudIcon Color="Color.Warning" Icon=@Icons.Material.Filled.TrendingDown></MudIcon>
                                    </MudTooltip>
                                }
                                @if (_variance.TryGetValue(chart.Id, out var varianceLevel) && varianceLevel != "Normal")
                                {
                                    <MudTooltip Text=@($"{varianceLevel} Score Variance")>
                                        <MudIcon Icon=@Icons.Material.Filled.GraphicEq Style=@($"color:{(varianceLevel=="Very High"?MudBlazor.Colors.Red.Darken1:varianceLevel=="High"?MudBlazor.Colors.Orange.Darken1:varianceLevel=="Low"?MudBlazor.Colors.Green.Darken1:MudBlazor.Colors.Blue.Darken1)}")></MudIcon>
                                    </MudTooltip>
                                }
                                @if (CurrentUser.IsLoggedIn)
                                {
                                    <MudIconButton Icon="@Icons.Material.Outlined.ListAlt" OnClick="() => ToggleToDo(chart.Id)" Color="_todos.Contains(chart.Id) ? Color.Primary : Color.Default"></MudIconButton>

                                }

                                <MudIconButton Icon="@Icons.Custom.Brands.YouTube" OnClick="@(() => VideoDisplayer.ShowVideo(chart.Id))"></MudIconButton>
                               
                            </MudCardActions>
                        </MudCard>
                    </MudItem>
                }
            }
        }

    }
    @if (!_isLoading && _averageSkillScore.Any(kv=>kv.Value>0))
    {
        <MudItem xs="12">
            <MudText Typo="Typo.h5">Skill Scores</MudText>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Speed Score Averages"
                       Options="_avgSpeedChartOptions"
                       Height="400"
                       @ref=_skillChart>

                <ApexPointSeries TItem="SkillEntry"
                                 Items="_averageSkillScore.Keys.Where(s=>s.IsCategory(SkillCategory.Speed) && _skillProgress.ContainsKey(s)).Select(s=>new SkillEntry(s,_skillProgress[s]))"
                                 Name="Speed Score Average"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />

            </ApexChart>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Skill Score Averages"
                       Options="_avgScoreChartOptions"
                       Height="400"
                       @ref=_speedSkillChart
            >

                <ApexPointSeries TItem="SkillEntry"
                                 Items="_averageSkillScore.Keys.Where(s=>!s.IsCategory(SkillCategory.Speed) && _skillProgress.ContainsKey(s)).Select(s=>new SkillEntry(s,_skillProgress[s]))"
                                 Name="Skill Score Average"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />

            </ApexChart>
        </MudItem>

        <MudItem xs="12">
            <MudText Typo="Typo.h5">Skill Passes</MudText>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Speed Passes"
                       Options="_avgSpeedChartPassOptions"
                       Height="400"
                       @ref=_skillChart>

                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillPassCount.Where(kv=>kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Passes"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />
                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillMaxCount.Where(kv=>kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Charts in Folder"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />


            </ApexChart>
        </MudItem>
        <MudItem xs="12" sm="6">
            <ApexChart TItem="SkillEntry"
                       Title="Skill Passes"
                       Options="_avgSkillChartPassOptions"
                       Height="400"
                       @ref=_skillChart>

                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillPassCount.Where(kv=>!kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Passes"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />
                <ApexPointSeries TItem="SkillEntry"
                                 Items=@_skillMaxCount.Where(kv=>!kv.Key.IsCategory(SkillCategory.Speed)).Select(s=>new SkillEntry(s.Key,s.Value,"Passed"))
                                 Name="Charts in Folder"
                                 SeriesType="SeriesType.Radar"
                                 XValue="@(e => e.Skill.GetName())"
                                 YValue="@(e=>(decimal)e.Metric)"
                                 OrderByDescending="e=>e.Items.First().Skill" />


            </ApexChart>
        </MudItem>
    }
</MudGrid>
<style>
.apexcharts-text {
        fill: #FFA726;
        font-weight:bold;
        padding-left:10px;
}
</style>
@inject ICurrentUserAccessor CurrentUser;
@inject IMediator Mediator;
@inject NavigationManager NavManager;
@inject ITierListRepository TierLists;
@inject ITitleRepository Titles;
@inject IUiSettingsAccessor UiSettings;
@inject IAdminNotificationClient Notifications;
@inject ISnackbar Snackbar;
@inject IPhoenixRecordRepository Records;
@inject IPlayerStatsRepository PlayerStats;
@inject IMemoryCache Cache;

@inject IJSRuntime JSRuntime;
@code
{

    private readonly ApexChartOptions<SkillEntry> _avgSpeedChartPassOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {

  return val.toFixed(0);
      }"
            }
            }}.ToList()
    };
    private readonly ApexChartOptions<SkillEntry> _avgSkillChartPassOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {

  return val.toFixed(0);
      }"
            }
        }}.ToList()
    };
    private readonly ApexChartOptions<SkillEntry> _avgSpeedChartOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Max=7,
            TickAmount = 7,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {


  if(index==0){
    return 'PG'
  }
  if(index==1){
    return 'SSS';
  }
  if(index==2){
    return 'SS';
  }
  if(index==3){
    return 'S';
  }
  if(index==4){
    return 'AAA';
  }
  if(index==5){
    return 'AA';
  }
  if(index==6){
    return 'A';
  }

  return '';
      }"
            }
        }}.ToList(),

    };
    private readonly ApexChartOptions<SkillEntry> _avgScoreChartOptions = new ApexChartOptions<SkillEntry>()
    {
        Yaxis = new[]{new YAxis()
        {
            Min=0,
            Max=7,
            TickAmount = 7,
            Labels = new YAxisLabels()
            {
                Formatter = @"
function(val, index) {

  if(index==0){
    return 'PG'
  }
  if(index==1){
    return 'SSS';
  }
  if(index==2){
    return 'SS';
  }
  if(index==3){
    return 'S';
  }
  if(index==4){
    return 'AAA';
  }
  if(index==5){
    return 'AA';
  }
  if(index==6){
    return 'A';
  }

  return '';
      }"
            }
        }}.ToList(),

    };
    
    private ApexChart<SkillEntry>? _speedSkillChart;
    
    private ApexChart<SkillEntry>? _skillChart;
    private ApexChart<SkillEntry>? _speedSkillPassChart;

    private ApexChart<SkillEntry>? _skillPassChart;
    [Parameter]
    [SupplyParameterFromQuery(Name = "Difficulty")]
    public int? DifficultyFilter { get; set; }

    [Parameter]
    [SupplyParameterFromQuery(Name = "ChartType")]
    public string? ChartTypeFilter { get; set; } = string.Empty;

    [Parameter]
    [SupplyParameterFromQuery(Name = "TierListType")]
    public string? TierListType { get; set; } = string.Empty;
    private DateTimeOffset _now = DateTimeOffset.Now;
    private IDictionary<Skill, List<Chart>> SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());

    private IDictionary<Skill, PhoenixScore> _averageSkillScore = Enum.GetValues<Skill>().ToDictionary(s => s, s => PhoenixScore.Min);
    private IDictionary<Skill, double> _skillProgress = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0.0);
    private IDictionary<Skill, int> _skillPassCount = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);
    private IDictionary<Skill, int> _skillMaxCount = Enum.GetValues<Skill>().ToDictionary(s => s, s => 0);

    private IDictionary<Guid, RecordedPhoenixScore> _scores = new Dictionary<Guid, RecordedPhoenixScore>();
    private IDictionary<Guid, RecordedPhoenixScore> _folderScores = new Dictionary<Guid, RecordedPhoenixScore>();
    private IDictionary<Guid, Chart> _charts = new Dictionary<Guid, Chart>();
    private ISet<Guid> _unPopularCharts = new HashSet<Guid>();
    private ISet<Guid> _popularCharts = new HashSet<Guid>();
    private bool _isBuildingImage = false;
    private FilterSettings _settings = new FilterSettings();
        private const string UserSettingsKey = @"ChartSkills__Settings";
    private async Task ToggleFilter(Filter filter)
    {
        if (_settings.ShowingFilters.Contains(filter))
        {
            _settings.ShowingFilters.Remove(filter);
            switch (filter)
            {
                case Filter.BPM:
                    _settings.MinBpm = null;
                    _settings.MaxBpm = null;
                    break;
                case Filter.LetterGrade:
                    _settings.MinLetterGrade = null;
                    _settings.MaxLetterGrade = null;
                    break;
                case Filter.Completion:
                    _settings.Completion = null;
                    break;
                case Filter.ToDo:
                    _settings.ToDo = null;
                    break;
                case Filter.NoteCount:
                    _settings.MaxNoteCount = null;
                    _settings.MinNoteCount = null;
                    break;
                case Filter.SongArtist:
                    _settings.SongArtists.Clear();
                    break;
                case Filter.StepArtist:
                    _settings.StepArtists.Clear();
                    break;
                case Filter.SongName:
                    break;
                default:
                    break;
            }
        }
        else
        {
            _settings.ShowingFilters.Add(filter);
        }
        await SaveSettings();
    }

    private async Task SaveSettings()
    {
        await UiSettings.SetSetting(UserSettingsKey, JsonSerializer.Serialize(_settings));
    }

    private IDictionary<Filter, string> _filterNames = Enum.GetValues<Filter>().ToDictionary(e => e, e => e.ToString());
    private enum Filter
    {
        SongType,
        SongName,
        ToDo,
        Completion,
        LetterGrade,
        BPM,
        NoteCount,
        StepArtist,
        SongArtist,
    }

    private sealed class FilterSettings
    {
        public HashSet<SongType> SongTypes { get; set; } = new HashSet<SongType>();
        public HashSet<Filter> ShowingFilters { get; set; } = new HashSet<Filter>(new[]{Filter.SongName});
        public bool? ToDo { get; set; }
        public bool? Completion { get; set; }
        public PhoenixLetterGrade? MinLetterGrade { get; set; }
        public PhoenixLetterGrade? MaxLetterGrade { get; set; }
        public decimal? MinBpm { get; set; }
        public decimal? MaxBpm { get; set; }
        public bool ShowStepArtist { get; set; }
        public bool ShowSongName { get; set; }
        public bool ShowSkills { get; set; } = true;
        public bool ShowDifficulty { get; set; } = true;
        public int? MinNoteCount { get; set; }
        public int? MaxNoteCount { get; set; }
        public HashSet<string> StepArtists { get; set; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        public HashSet<string> SongArtists { get; set; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
    }
    private sealed record SkillEntry(Skill Skill, double Metric, string Category="None");
    private async Task SetTextView(bool newSetting)
    {
        await UiSettings.SetSetting("TierLists__TextView", newSetting.ToString());
        _textView = newSetting;
    }
    private IDictionary<Guid, int> _ages = new Dictionary<Guid, int>(); 
    private IDictionary<Guid, IEnumerable<Name>> _charTitles = new Dictionary<Guid, IEnumerable<Name>>();
    private IEnumerable<PhoenixTitle> _titles = Array.Empty<PhoenixTitle>();
    private IEnumerable<Guid> _unpassedTodos => _finalEntries.Select(e => e.ChartId).Where(chartId => _scores.ContainsKey(chartId)&& _scores[chartId].IsBroken && _todos.Contains(chartId));
    private IDictionary<Guid, TierListCategory> _chartDifficulties = new Dictionary<Guid, TierListCategory>();
    private Name[] _availableStepArtists = Array.Empty<Name>();
    private Name[] _availableSongArtists = Array.Empty<Name>();
    private int _lowestNoteCount = 0;
    private int _highestNoteCount = 0;
    private decimal _lowestBpm = 0;
    private decimal _highestBpm = 0;
    private ChartType _chartType = ChartType.Single;
    private bool _textView = false;
    private bool _isLoading = false;
    private bool _showAge = false;

    private ISet<Guid> _todos = new HashSet<Guid>();

    private sealed record LampProgress(string Name, int Order, int Progress);

    private IEnumerable<LampProgress> _lamps = Array.Empty<LampProgress>();
    private IEnumerable<TitleProgress> _titleProgress = Array.Empty<TitleProgress>();
    private Task<IEnumerable<string>> FilterSongName(string search) => Task.FromResult(_finalEntries.Select(c => _charts[c.ChartId].Song.Name.ToString()).Distinct().Where(
        n => string.IsNullOrWhiteSpace(search)|| n.Contains(search, StringComparison.OrdinalIgnoreCase)).OrderBy(n => n == search ? 0 : 1).AsEnumerable());
    private string TierListColor(TierListCategory category) => category switch{
        TierListCategory.Overrated=>Colors.Cyan.Darken1,
        TierListCategory.VeryEasy=>Colors.Green.Darken1,
        TierListCategory.Easy=>Colors.LightGreen.Darken1,
        TierListCategory.Medium=>Colors.Yellow.Darken1,
        TierListCategory.Hard=>Colors.Orange.Darken1,
        TierListCategory.VeryHard=>Colors.Red.Darken1,
        TierListCategory.Underrated=>Colors.Purple.Darken1,
        TierListCategory.Unrecorded=>Colors.Gray.Darken1,
    };
    private IDictionary<Guid, string> _variance = new Dictionary<Guid, string>();
    private async Task CalculateVariance(ChartType chartType, DifficultyLevel level)
    {
        var scores = (await Records.GetAllPlayerScores(chartType, level)).ToArray();
        var players = (await PlayerStats.GetStats(scores.Select(s => s.userId).Distinct().ToArray(), CancellationToken.None))
            .Where(p => Math.Abs((_chartType == ChartType.Single ? p.SinglesCompetitiveLevel : p.DoublesCompetitiveLevel) - level) < 2.0).ToDictionary(p => p.UserId);

        var chartGroups = scores.GroupBy(r => r.record.ChartId).ToDictionary(g => g.Key, g => g.Where(k => players.ContainsKey(k.userId) && k.record is { Score: not null, IsBroken: false }).Select(k => k.record!.Score).ToArray());


        var chartStandards = chartGroups.Where(kv => kv.Value.Count() > 5)
            .Select(kv => (_charts[kv.Key], TierListSaga.StdDev(kv.Value.Select(s => (int)s!.Value), true)))
            .ToArray();

        if (!chartStandards.Any())
        {
            return;
        }
        var average = chartStandards.Average(c => c.Item2);
        var standardDev = TierListSaga.StdDev(chartStandards.Select(c => c.Item2), true);
        var results = chartStandards
            .Select(kv => (kv.Item1, (kv.Item2-average)/standardDev))
            .ToArray();

        _variance = results.ToDictionary(r => r.Item1.Id, r => r.Item2 <= -2.0 ? "Very Low" :
            r.Item2 <= -1.0 ? "Low" :
                r.Item2 >= 2.0 ? "Very High" :
                    r.Item2 >= 1.0 ? "High" : "Normal");

    }
    private async Task SetSongTypeFilter(IEnumerable<SongType> s)
    {
        _settings.SongTypes = s.Distinct().ToHashSet();
        await SaveSettings();
    }

    private async Task SetTodoFilter(bool? newValue)
    {
        _settings.ToDo = newValue;
        await SaveSettings();
    }

    private async Task SetSelectedSongArtists(IEnumerable<string> artists)
    {
        _settings.SongArtists = artists.Distinct(StringComparer.OrdinalIgnoreCase).ToHashSet(StringComparer.OrdinalIgnoreCase);
        await SaveSettings();
    }

    private async Task SetSelectedStepArtists(IEnumerable<string> artists)
    {
        
        _settings.StepArtists = artists.Distinct(StringComparer.OrdinalIgnoreCase).ToHashSet(StringComparer.OrdinalIgnoreCase);
        await SaveSettings();
    }

    private async Task SetSelectedMinBpm(decimal? bpm)
    {
        _settings.MinBpm = bpm;
        await SaveSettings();
    }
    private async Task SetSelectedMaxBpm(decimal? bpm)
    {
        _settings.MaxBpm = bpm;
        await SaveSettings();
    }

    private async Task SetMinNoteCount(int? noteCount)
    {
        _settings.MinNoteCount = noteCount;
        await SaveSettings();
    }
    private async Task SetMaxNoteCount(int? noteCount)
    {
        _settings.MaxNoteCount = noteCount;
        await SaveSettings();
    }

    private async Task SetCompletionFilter(bool? completion)
    {
        _settings.Completion = completion;
        await SaveSettings();
    }

    private async Task SetMinLetterGrade(PhoenixLetterGrade? grade)
    {
        _settings.MinLetterGrade = grade;
        await SaveSettings();
    }
    private async Task SetMaxLetterGrade(PhoenixLetterGrade? grade)
    {
        _settings.MaxLetterGrade = grade;
        await SaveSettings();
    }

    private async Task ToggleShowSkills()
    {
        _settings.ShowSkills = !_settings.ShowSkills;
        await SaveSettings();
    }

    private async Task ToggleShowDifficulty()
    {
        _settings.ShowDifficulty = !_settings.ShowDifficulty;
        await SaveSettings();
    }

    private async Task ToggleShowStepArtist()
    {
        _settings.ShowStepArtist = !_settings.ShowStepArtist;
        await SaveSettings();
    }
    private async Task ToggleShowName()
    {
        _settings.ShowSongName = !_settings.ShowSongName;
        await SaveSettings();
    }

    public string DifficultyBubblePath(ChartType chartType, DifficultyLevel level) =>  $"https://piuimages.arroweclip.se/difficulty/Phoenix/{chartType.GetShortHand().ToLower()}{level}.png";
    private string LetterGradeImage(PhoenixLetterGrade letterGrade, bool isBroken) => 
        $"https://piuimages.arroweclip.se/letters/{letterGrade.ToString().ToLower()}{(isBroken ? "_broken" : "")}.png";

    private string PlateImage(PhoenixPlate plate) => $"https://piuimages.arroweclip.se/plates/{plate.GetShorthand().ToLower()}.png";

    private async Task DownloadImage()
    {
        _isBuildingImage = true;
        using var client = new HttpClient();
        const int width = 1000;
        const int songWidth = 140;
        const int padding = 15;
        const int songHeight = 80;
        const int sectionTextHeight = 45;
        const int gradeWidth = 30;
        const int gradeHeight = 22;
        const int gradePadding = 5;
        var height = 50 + padding * 2+50+padding;
        foreach (var group in _finalGroupings.Where(g => g.Any(ShouldChartShow)))
        {
            height += sectionTextHeight;
            var xTest = padding;
            foreach (var _ in group)
            {
                if (xTest > width - 155)
                {

                    xTest = padding;
                    height += songHeight + padding;
                }
                xTest += songWidth + padding;
            }

            height += songHeight + padding;
        }
        height += padding;
        using var bmp = new Bitmap(width, height);
        using var gr = Graphics.FromImage(bmp);

        gr.Clear(System.Drawing.Color.Black);
        var x = padding;
        var y = padding;

        var userName = CurrentUser.IsLoggedIn ? " - " +( CurrentUser.User.GameTag ?? CurrentUser.User.Name) : "";
        //Bubble and Tier List Name
        var bubble = await LoadImage(client,DifficultyBubblePath(_chartType, _level),50,50);
        gr.DrawImage(bubble,new Rectangle(x,y,50,50));
        x += 50+padding;
        gr.DrawString((_groupBy == "Difficulty" ? _tierListType : _groupBy)+userName, new Font("Tahoma", 36),Brushes.White,x,y);
        y += 50+padding*2;

        var greenPen = new Pen(System.Drawing.Color.Chartreuse, 3);
        var bluePen = new Pen(System.Drawing.Color.Blue, 3);
        var redPen = new Pen(System.Drawing.Color.Red, 3);
        //Sections
        foreach (var group in _finalGroupings.Where(g => g.Any(ShouldChartShow)))
        {
            x = padding;
            gr.DrawString(group.Key,new Font("Tahoma", 24),Brushes.White,x,y);
            y += sectionTextHeight;
            foreach (var entry in group)
            {
                if (x > width - 155)
                {
                    
                    x = padding;
                    y += songHeight+padding;
                }
                var chart = _charts[entry.ChartId];
                var songBmp = await LoadImage(client, chart.Song.ImagePath.ToString(), songWidth, songHeight);
                gr.DrawImage(songBmp, new Rectangle(x, y, songWidth, songHeight));
                
                if (_todos.Contains(entry.ChartId))
                {
                    gr.DrawRectangle(bluePen, new Rectangle(x,y,songWidth,songHeight));
                } else if (CurrentUser.IsLoggedIn)
                {
                    
                    gr.DrawRectangle(redPen, new Rectangle(x,y,songWidth,songHeight));
                }
                if (_scores.TryGetValue(chart.Id, out var score))
                {
                    if (score.Plate != null)
                    {
                        var bitmap = await LoadImage(client, PlateImage(score.Plate.Value), gradeWidth, gradeHeight);

                        gr.DrawImage(bitmap, new Rectangle(x + songWidth - gradeWidth - gradePadding, y + songHeight - gradeHeight - gradePadding, gradeWidth, gradeHeight));
                    }
                    if (score.Score != null)
                    {
                        var letterGrade = score.Score.Value.LetterGrade;
                        var bitmap = await LoadImage(client,LetterGradeImage(letterGrade,score.IsBroken),gradeWidth,gradeHeight);
                        gr.DrawImage(bitmap,new Rectangle(x+songWidth-(gradeWidth+gradePadding)*2,y+songHeight-gradeHeight-gradePadding,gradeWidth,gradeHeight));

                    }
                    if (!score.IsBroken)
                    {
                        gr.DrawRectangle(greenPen, new Rectangle(x, y, songWidth, songHeight));
                    }
                }
                x += songWidth+padding;
            }
            y += songHeight+padding;
        }
        y += padding;
        gr.DrawString("Generated on https://piuscores.arroweclip.se",new Font("Tahoma",24),Brushes.White,padding,y);
        //Download file
        
        var stream = new MemoryStream();
        bmp.Save(stream, System.Drawing.Imaging.ImageFormat.Png);

        using var streamRef = new DotNetStreamReference(stream: stream);
        stream.Seek(0, SeekOrigin.Begin);
        var module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/helpers.js");
        await module.InvokeVoidAsync("downloadFileFromStream", $"{ChartTypeFilter??""}{DifficultyFilter?.ToString()??""}_{DateTimeOffset.Now:d}.png", streamRef);
        _isBuildingImage = false;
    }
    private bool ShouldChartShow(SongTierListEntry entry)
    {
        var score = _scores.TryGetValue(entry.ChartId, out var scr) ? scr : null;
        if (_settings.MinLetterGrade != null &&  (score?.Score== null || score.Score.Value.LetterGrade < _settings.MinLetterGrade))
        {
            return false;
        }
        if (_settings.MaxLetterGrade != null && (score?.Score == null || score.Score.Value.LetterGrade > _settings.MaxLetterGrade))
        {
            return false;
        }
        if (_settings.Completion!=null && _settings.Completion!=(_scores.TryGetValue(entry.ChartId, out var s) && !s.IsBroken))
        {
            return false;
        }
        if (_settings.ToDo!=null && _settings.ToDo!=_todos.Contains(entry.ChartId))
        {
            return false;
        }
        var chart = _charts[entry.ChartId];
        if (_settings.SongTypes.Any() && !_settings.SongTypes.Contains(chart.Song.Type))
        {
            return false;
        }
        if (!string.IsNullOrWhiteSpace(_songFilter) && !chart.Song.Name.ToString().Contains(_songFilter, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        if (_settings.MaxBpm != null && (chart.Song.Bpm == null || chart.Song.Bpm.Value.Max > _settings.MaxBpm))
        {
            return false;
        }
        if (_settings.MinBpm != null && (chart.Song.Bpm == null || chart.Song.Bpm.Value.Min < _settings.MinBpm))
        {
            return false;
        }
        if (_settings.StepArtists.Any() && !_settings.StepArtists.Contains(chart.StepArtist?.ToString() ?? "Unknown"))
        {
            return false;
        }
        if (_settings.SongArtists.Any() && !_settings.SongArtists.Contains(chart.Song.Artist.ToString()))
        {
            return false;
        }
        if (_settings.MinNoteCount != null && (chart.NoteCount != null || _settings.MinNoteCount >= chart.NoteCount))
        {
            return false;
        }
        if (_settings.MaxNoteCount != null && (chart.NoteCount != null || _settings.MaxNoteCount <= chart.NoteCount))
        {
            return false;
        }
        return true;
    }
    private int _highlightedModifier = 10;
    private string _groupBy = "Tier List";
    private int _level = 20;
    private IDictionary<Guid, ScoreRankingRecord> _scoreRankings = new Dictionary<Guid, ScoreRankingRecord>();
    private string _tierListType = "Pass";
    private string _songFilter;
    private int _competitivePlayerCount = 0;
    private async Task SetShowAge(bool newSetting)
    {
        _showAge = newSetting;
        await UiSettings.SetSetting("TierLists__ShowAge", newSetting.ToString());
    }
    private bool _usePersonalizedData = true;
    private IEnumerable<IGrouping<string, SongTierListEntry>>
    _finalGroupings = Array.Empty<IGrouping<string, SongTierListEntry>>();


    private async Task SetUsePersonalized(bool newUse)
    {
        _usePersonalizedData = newUse;

        await SetTierListType(_tierListType);
    }
    private async Task SetTierListType(string type)
    {
        _tierListType = type;
        SetQueryString();
        if (_tierListType == "PG")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 0 },
                { "Similar Players", 0 },
                { "Popularity", 0 },
                { "Pass Count", 0 },
                { "PG", 1 },
                { "Chabala", 0 }
            };

        }
        if (_tierListType == "Chabala")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 0 },
                {"Similar Players", 0},
                { "Popularity", 0 },
                { "Pass Count",0},
                {"PG",0},
                {"Chabala",1}
            };
        }
        if (_tierListType == "Pass")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 2 },
                {"Similar Players", 1},
                { "Popularity", 0 },
                { "Pass Count",2},
                {"PG",0},
                {"Chabala",0}
            };

        }
        if (_tierListType == "Score")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 1 },
                { "Scores", 2 },
                { "Skill", 2 },
                {"Similar Players",1},
                { "Popularity", 0 },
                { "Pass Count",0},
                {"PG",0},
                {"Chabala",0}
            };
        }
        if (_tierListType == "Popularity")
        {
            _modifiers = new Dictionary<string, double>()
            {
                { "Official Scores", 0 },
                { "Scores", 0 },
                { "Skill", 0 },
                { "Popularity", 1 },
                { "Pass Count",0},
                {"Similar Players",0},
                {"PG",0},
                {"Chabala",0}
            };
        }
        if (!_usePersonalizedData)
        {
            _modifiers["Skill"] = 0;
            _modifiers["Similar Players"] = 0;
        }
        await Recalculate();
    }

    private async Task ChangeGrouping(string newGrouping)
    {
        _groupBy = newGrouping;
        await Recalculate();
    }

    private void SetQueryString()
    {

        NavManager.NavigateTo(NavManager.GetUriWithQueryParameters(new Dictionary<string, object?>
        {
            { "Difficulty", _level },
            { "ChartType", _chartType.ToString() },
            {"TierListType",_tierListType}
        }));
    }

    public async Task ToggleToDo(Guid chartId)
    {
        if (!_todos.Contains(chartId))
        {
            await Mediator.Send(new SaveChartToListCommand(ChartListType.ToDo, chartId));
            Snackbar.Add("Added to ToDo List!", Severity.Success);
            _todos.Add(chartId);
        }
        else
        {
            await Mediator.Send(new RemoveChartFromListCommand(ChartListType.ToDo, chartId));
            Snackbar.Add("Removed from ToDo List!", Severity.Success);
            _todos.Remove(chartId);
        }
        StateHasChanged();
    }
    private string CardClass(Guid chartId) =>
        _scores.TryGetValue(chartId,out var broken)&&!broken.IsBroken? "chart-card border-solid border-2" : "chart-card border-dashed border-2";

    private string CardStyle(Guid chartId) =>
        _scores.TryGetValue(chartId, out var broken) && !broken.IsBroken ? $@"border-color:{MudBlazor.Colors.Green.Darken1}" : "";


    private static readonly PhoenixLetterGrade[] _validLetterGrades = new[]
    {
        PhoenixLetterGrade.A,
        PhoenixLetterGrade.AA,
        PhoenixLetterGrade.AAA,
        PhoenixLetterGrade.S,
        PhoenixLetterGrade.SS,
        PhoenixLetterGrade.SSS
    };

    private static IDictionary<string, Bitmap> _cachedImages = new Dictionary<string, Bitmap>(StringComparer.OrdinalIgnoreCase);

    private static async Task<Bitmap> LoadImage(HttpClient client, string location, int newWidth, int newHeight)
    {
        if (_cachedImages.TryGetValue(location, out var bitmap))
        {
            return bitmap;
        }
        var stream = await client.GetStreamAsync(location);

        var bmp = new Bitmap(newWidth, newHeight);
        var gr = Graphics.FromImage(bmp);
        gr.DrawImage(new Bitmap(stream), new Rectangle(0, 0, newWidth, newHeight));
        _cachedImages[location] = bmp;
        return bmp;
    }
    private async Task<IEnumerable<SongTierListEntry>> BuildSkillTierList()
    {

        @if (!_charts.Any(kv => kv.Value.Skills.Any()))
        {
            _averageSkillScore.Clear();
            return _charts.Select(kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
        }
        SkillCharts = Enum.GetValues<Skill>().ToDictionary(s => s, s => new List<Chart>());

        SkillCharts = _charts.Values.SelectMany(c => c.Skills.Select(s => (c,s))).GroupBy(g => g.s).ToDictionary(g => g.Key, g => g.Select(kv => kv.c).ToList());
        _averageSkillScore = SkillCharts.ToDictionary(kv => kv.Key, kv =>
            kv.Value.Any(c => _scores.TryGetValue(c.Id, out var s) && s is { Score: not null,IsBroken: false }) ?
                (PhoenixScore)(int)kv.Value.Where(c => _scores.TryGetValue(c.Id, out var s) && s.Score != null && !s.IsBroken)
                    .Average(c => _scores[c.Id].Score!.Value)
                : PhoenixScore.Min);

        _skillMaxCount = SkillCharts.ToDictionary(kv => kv.Key, kv => kv.Value.Count());
        _skillPassCount = SkillCharts.ToDictionary(kv => kv.Key, kv => kv.Value.Count(c => _scores.TryGetValue(c.Id, out var s) && !s.IsBroken));

        foreach (var kv in _averageSkillScore)
        {
            if (kv.Value == PhoenixScore.Max)
            {
                _skillProgress[kv.Key] = _validLetterGrades.Length;
                continue;
            }
            if (kv.Value < _validLetterGrades.Min().GetMinimumScore())
            {
                _skillProgress[kv.Key] = 0;
                continue;
            }
            var lowGrade = _validLetterGrades.Reverse().First(g => g.GetMinimumScore() <= kv.Value);
            var lowIndex = _validLetterGrades.IndexOf(lowGrade);
            var highScore = lowIndex == _validLetterGrades.Length-1 ? PhoenixScore.Max : _validLetterGrades[lowIndex + 1].GetMinimumScore();
            _skillProgress[kv.Key] = 1.0+ (double)lowIndex + (kv.Value - lowGrade.GetMinimumScore()) / (double)(highScore - lowGrade.GetMinimumScore());
        }
        var avgEstimates = _charts.Values.Where(c => c.Skills.Any(s => _averageSkillScore[s] > 0)).ToDictionary(c => c.Id, c =>
            c.Skills.Where(s => _averageSkillScore[s] > 0).Average(s => _averageSkillScore[s]));

        if (_speedSkillChart != null)
        {
            await _speedSkillChart.UpdateSeriesAsync(true);
            await _speedSkillChart.UpdateOptionsAsync(true, true, true);
        }
        if (_skillChart != null)
        {
            await _skillChart.UpdateSeriesAsync(true);
            await _skillChart.UpdateOptionsAsync(true, true, true);
        }

        if (_skillMaxCount.Any(kv => kv.Key.IsCategory(SkillCategory.Speed)))
        {
            
            _avgSpeedChartPassOptions.Yaxis.First().Max = _skillMaxCount.Where(kv => kv.Key.IsCategory(SkillCategory.Speed)).Max(kv => kv.Value);

        }
        if (_skillMaxCount.Any(kv => !kv.Key.IsCategory(SkillCategory.Speed)))
        {

            _avgSkillChartPassOptions.Yaxis.First().Max = _skillMaxCount.Where(kv => !kv.Key.IsCategory(SkillCategory.Speed)).Max(kv => kv.Value);
        }
        if (_skillPassChart != null)
        {
            await _skillPassChart.UpdateSeriesAsync(true);
            await _skillPassChart.UpdateOptionsAsync(true, true, true);
        }
        if (_speedSkillPassChart != null)
        {
            await _speedSkillPassChart.UpdateSeriesAsync(true);
            await _speedSkillPassChart.UpdateOptionsAsync(true,true,true);
        }
        if (_charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s is {Score:not null, IsBroken:false})<10 || 
            _averageSkillScore.Count(kv=>kv.Value>0)<3)
        {
            return _charts.Select(kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
            
        }
        return TierListSaga.ProcessIntoTierList("Skill", avgEstimates)
            .Concat(_charts.Values.Where(c => !c.Skills.Any(s => _averageSkillScore[s] > 0)).Select(s => new SongTierListEntry("Skill", s.Id, TierListCategory.Unrecorded, 9999)))
            .ToArray();

    }

    private IEnumerable<SongTierListEntry> _finalEntries = Array.Empty<SongTierListEntry>();
    private IDictionary<string, double> _clearRate = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => 0.0);
    private IDictionary<string, PhoenixScore> _minScores = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => PhoenixScore.Min);
    private IDictionary<string, PhoenixScore> _averageScores = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => PhoenixScore.Min);
    private IDictionary<string, PhoenixScore> _maxScores = Enum.GetValues<TierListCategory>().ToDictionary(c => c.ToString(), c => PhoenixScore.Min);
    private IDictionary<string, double> _modifiers = new Dictionary<string, double>()
    {
        { "Official Scores", 0 },
        { "Scores", 1 },
        { "Skill", 2 },
        { "Popularity", .5 },
        { "Pass Count",2},
        {"Similar Players",1},
        {"Chabala",0},
        {"PG",0}
    };


    private int GetScore(TierListCategory category) => (int)category - 3;
    private int _averageRating = 1;
    private async Task<IEnumerable<SongTierListEntry>> GetSimilarPlayers(ChartType type, int level)
    {

        var myLevel = await Titles.GetCurrentTitleLevel(CurrentUser.User.Id, CancellationToken.None);
        var lowLevel = await TierLists.GetUsersOnLevel(myLevel - 1, CancellationToken.None);
        var onMyLevel = await TierLists.GetUsersOnLevel(myLevel - 1, CancellationToken.None);
        var highLevel = await TierLists.GetUsersOnLevel(myLevel - +1, CancellationToken.None);
        var userIds = (lowLevel)
            .Concat(onMyLevel)
            .Concat(highLevel)
            .Where(u => u != CurrentUser.User.Id);
        var userTiersLists = new Dictionary<Guid, IEnumerable<SongTierListEntry>>();
        var myTierList = (await Mediator.Send(new GetMyRelativeTierListQuery(type, level)))
            .ToDictionary(r => r.ChartId);
        foreach (var userId in userIds)
        {
            userTiersLists[userId] = await Mediator.Send(new GetMyRelativeTierListQuery(type, level, userId));
        }
        var userTotals = userTiersLists.ToDictionary(kv => kv.Key, kv => kv.Value.Sum(e => myTierList.ContainsKey(e.ChartId) && myTierList[e.ChartId].Category != TierListCategory.Unrecorded && e.Category != TierListCategory.Unrecorded ?
            (int)TierListCategory.Unrecorded - (int)Math.Abs(e.Category - myTierList[e.ChartId].Category)
            : 0));

        var chartWeights = new Dictionary<Guid, int>();

        foreach (var kv in userTiersLists)
            foreach (var entry in kv.Value.Where(e => e.Category != TierListCategory.Unrecorded))
            {
                if (!chartWeights.ContainsKey(entry.ChartId))
                {
                    chartWeights[entry.ChartId] = 0;
                }
                chartWeights[entry.ChartId] += (TierListCategory.Unrecorded - entry.Category) * userTotals[kv.Key];
            }
        return TierListSaga.ProcessIntoTierList("Similar Players", chartWeights);
        

    }

    private ISet<Guid> _topCharts = new HashSet<Guid>();
    private static readonly IDictionary<TierListCategory, string> _scoreNames = new Dictionary<TierListCategory, string>()
    {
        { TierListCategory.Overrated, "Amazing" },
        { TierListCategory.VeryEasy, "Very Good" },
        { TierListCategory.Easy, "Good" },
        { TierListCategory.Medium, "Average" },
        { TierListCategory.Hard, "Low" },
        { TierListCategory.VeryHard, "Very Low" },
        { TierListCategory.Underrated, "Why Don't You Get Up and Dance, Man?" },
        { TierListCategory.Unrecorded, "Not Recorded" }
    };
    private static readonly IDictionary<TierListCategory, string> _ageNames = new Dictionary<TierListCategory, string>()
    {
        { TierListCategory.Overrated, "Ancient" },
        { TierListCategory.VeryEasy, "Very Old" },
        { TierListCategory.Easy, "Old" },
        { TierListCategory.Medium, "Average" },
        { TierListCategory.Hard, "New" },
        { TierListCategory.VeryHard, "Very New" },
        { TierListCategory.Underrated, "Most Recent" },
        { TierListCategory.Unrecorded, "Not Recorded" }
    };
    private static readonly IDictionary<TierListCategory, string> _popularityNames = new Dictionary<TierListCategory, string>()
    {
        { TierListCategory.Unrecorded, "Unknown" },
        { TierListCategory.Overrated, "Ultra Popular" },
        { TierListCategory.VeryEasy, "Very Popular" },
        { TierListCategory.Easy, "Popular" },
        { TierListCategory.Medium, "Average" },
        { TierListCategory.Hard, "Unpopular" },
        { TierListCategory.VeryHard, "Very Unpopular" },
        { TierListCategory.Underrated, "Ultra Unpopular" }
    };

    private IDictionary<string, IDictionary<TierListCategory, string>> _tierListCategoryNames = new Dictionary<string, IDictionary<TierListCategory, string>>()
    {
        { "Popularity", _popularityNames },
        { "Score", _scoreNames },
        { "Age", _ageNames }

    };
    private async Task Recalculate()
    {
        _isLoading = true;
        if (CurrentUser.IsLoggedIn)
        {
            _competitivePlayerCount = (await Mediator.Send(new GetCompetitivePlayersQuery(_chartType))).Count();
            _scoreRankings = await Mediator.Send(new GetPlayerScoreQualityQuery(_level, _chartType));
        }
        await UiSettings.SetSetting("TierLists__Level", _level.ToString());
        await UiSettings.SetSetting("TierLists__ChartType", _chartType.ToString());
        await UiSettings.SetSetting("TierLists__ListType", _tierListType);
        await UiSettings.SetSetting("TierLists__UsePersonalized", _usePersonalizedData.ToString());
        await UiSettings.SetSetting("TierLists__GroupBy", _groupBy);
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix, _level, _chartType))).ToDictionary(c => c.Id);
        _folderScores = _scores.Where(kv => _charts.ContainsKey(kv.Key)).ToDictionary(kv => kv.Key, kv => kv.Value);
        var titles = _titles.Where(t => t is ISpecificChartTitle).ToArray();
        _charTitles = _charts.Values.SelectMany(c => titles.Select(t => (c,t,((ISpecificChartTitle)t).AppliesToChart(c))))
            .Where(v => v.Item3).GroupBy(v=>v.c.Id).ToDictionary(g =>g.Key,g=> g.Select(v => v.t.Name).ToArray().AsEnumerable());
        
        var popularity = (await Mediator.Send(new GetTierListQuery("Popularity"))).ToDictionary(s => s.ChartId);
        _popularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Overrated).Select(kv => kv.Key).ToHashSet();
        _unPopularCharts = popularity.Where(kv => kv.Value.Category == TierListCategory.Underrated).Select(kv => kv.Key).ToHashSet();
        
        
        

        var cacheKey = $"{nameof(ChartSkills)}__TierList__{_tierListType}__{_chartType}__{_level}";
        if (_usePersonalizedData && CurrentUser.IsLoggedIn)
        {
            cacheKey += $"__{CurrentUser.User.Id}";
        }

        var skillTierList = new Dictionary<Guid, SongTierListEntry>();
        if (CurrentUser.IsLoggedIn)
        {
            //This also builds the skill breakdowns at bottom of page
            skillTierList =   (await BuildSkillTierList()).ToDictionary(e => e.ChartId);
        }
        
        _finalEntries = await Cache.GetOrCreateAsync(cacheKey, async o =>
        {
            o.AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(6);
            o.SlidingExpiration = TimeSpan.FromHours(1);
            var scores = (await Mediator.Send(new GetTierListQuery("Scores"))).ToDictionary(s => s.ChartId); 
            var baseEntries =
                CurrentUser.IsLoggedIn ? skillTierList
                    : scores.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Skill", kv.Key, TierListCategory.Unrecorded, 0));
            var officialScores = (await Mediator.Send(new GetTierListQuery("Official Scores"))).ToDictionary(s => s.ChartId);
            var chabala = (await Mediator.Send(new GetTierListQuery("Chabala"))).ToDictionary(s => s.ChartId);
            var pg = (await Mediator.Send(new GetTierListQuery("PG"))).ToDictionary(s => s.ChartId);
            var similarPlayers = new Dictionary<Guid, SongTierListEntry>();
        var title = (await Mediator.Send(new GetTierListQuery("Pass Count"))).ToDictionary(s => s.ChartId);
            if (CurrentUser.IsLoggedIn && _usePersonalizedData)
            {
                similarPlayers = CurrentUser.IsLoggedIn ? (await GetSimilarPlayers(_chartType, _level))
                    .ToDictionary(e => e.ChartId) : _charts.ToDictionary(kv => kv.Key, kv => new SongTierListEntry("Similar Players", kv.Key, TierListCategory.Unrecorded, 0));

            }

            var result = new List<SongTierListEntry>();
            foreach (var chartId in _charts.Keys)
            {
                var count = 0.0;
                var currentTotal = 0.0;
                foreach (var listItem in new[] { (officialScores, "Official Scores"),(chabala,"Chabala"), (scores, "Scores"), (popularity, "Popularity"), (baseEntries, "Skill"),(pg,"PG"), (title, "Pass Count"), (similarPlayers,"Similar Players") })
                {
                    if (!listItem.Item1.ContainsKey(chartId) || listItem.Item1[chartId].Category == TierListCategory.Unrecorded)
                    {
                        continue;
                    }
                    count += _modifiers[listItem.Item2];
                    currentTotal += _modifiers[listItem.Item2] * (double)GetScore(listItem.Item1[chartId].Category);
                }
                if (count < .0001)
                {
                    result.Add(new SongTierListEntry("Final", chartId, TierListCategory.Unrecorded, 999999));
                    continue;
                }
                var final = currentTotal / (double)count;
                result.Add(new SongTierListEntry("Final", chartId, final < -2.5 ? TierListCategory.Overrated :
                    final < -1.5 ? TierListCategory.VeryEasy :
                        final < -.5 ? TierListCategory.Easy :
                            final <= .5 ? TierListCategory.Medium :
                                final <= 1.5 ? TierListCategory.Hard :
                                    final <= 2.5 ? TierListCategory.VeryHard :
                                        TierListCategory.Underrated, (int)(final * 100.0)));

            }
            return result;
        }) ?? throw new Exception("Tier list could not be retrieved from cache");
        _chartDifficulties = _finalEntries.ToDictionary(e => e.ChartId, e => e.Category);

        if (_groupBy=="Difficulty")
        {
            _finalGroupings = _finalEntries
                .OrderBy(e=>e.Order)
                .GroupBy(e =>
                    _tierListCategoryNames.TryGetValue(_groupBy,out var names)?names[e.Category]:
                    _tierListType=="Popularity"?_popularityNames[e.Category]:
                        _tierListType=="Chabala"&&e.Category==TierListCategory.Unrecorded?"Subjective":
                    e.Category.ToString()).OrderBy(g => g.First().Category)
                .ToArray();
        } else if (_groupBy == "Skill")
        {
            _finalGroupings = _finalEntries
                .OrderBy(e=>_chartDifficulties[e.ChartId])
                .ThenBy(e=>e.Order)
                .GroupBy(e => _charts[e.ChartId].Skills.Any() ? string.Join(' ', _charts[e.ChartId].Skills.OrderBy(s => s).Select(s => s.GetName())) : "Not Rated")
                .OrderBy(g => _charts[g.First().ChartId].Skills.Any()?(int) _charts[g.First().ChartId].Skills.Min():999999)
                .ToArray();
        } else if (_groupBy == "Score")
        {
            var tierList = TierListSaga.ProcessIntoTierList("Score", _folderScores.Where(kv => kv.Value.Score != null).ToDictionary(kv => kv.Key, kv => (int)kv.Value.Score!.Value))
                .ToDictionary(kv => kv.ChartId);
            _finalGroupings = _finalEntries.OrderBy(e => _scores.TryGetValue(e.ChartId, out var s) ? s.Score ?? PhoenixScore.Min : PhoenixScore.Max)
                .GroupBy(e => _scores.ContainsKey(e.ChartId) ? _scoreNames[tierList[e.ChartId].Category] : _scoreNames[TierListCategory.Unrecorded])
                .ToArray();
        }
        else if (_groupBy == "Age")
        {
            if (_folderScores.Values.Select(s => s.RecordedDate).Distinct().Count() < 5)
            {
                _finalGroupings = _finalEntries.GroupBy(kv => _ageNames[TierListCategory.Unrecorded])
                    .ToArray();
            }
            else
            {
                
                var now = DateTimeOffset.Now;
                var tierList = TierListSaga.ProcessIntoTierList("Score", _folderScores.Where(kv => kv.Value.Score != null).ToDictionary(kv => kv.Key, kv => (now - kv.Value.RecordedDate).TotalDays))
                    .ToDictionary(kv => kv.ChartId);
                _finalGroupings = _finalEntries.OrderByDescending(e => _scores.TryGetValue(e.ChartId, out var s) ? (now - s.RecordedDate).TotalDays : -1)
                    .GroupBy(e => _scores.ContainsKey(e.ChartId) ? _ageNames[tierList.TryGetValue(e.ChartId, out var t)?t.Category:TierListCategory.Unrecorded] : _ageNames[TierListCategory.Unrecorded])
                    .ToArray();
            }
        }
        else if (_groupBy == "Score Ranking")
        {
            _finalGroupings = _finalEntries
                .OrderBy(e => _scoreRankings.TryGetValue(e.ChartId, out var r) ? r.Ranking : 99999)
                .GroupBy(e => _scoreRankings.TryGetValue(e.ChartId, out var r) ?
                    (r.Ranking <= 0.01 ?
                        "Last Place" :
                        r.Ranking <= 0.10 ?
                            "0 -> 10%" :
                            r.Ranking <= 0.25 ?
                                "10% -> 25%" :
                                r.Ranking <= .5 ?
                                    "25% -> 50%" :
                                    r.Ranking <= .75 ?
                                        "50% -> 75%" :
                                        r.Ranking <= .9 ?
                                            "75% -> 90%" :
                                            r.Ranking > .99 ?
                                                "The Best":
                                            "90% -> 99.9%"
                        )
                    : "Not Recorded")
                .ToArray();
        }
        else
        {
            _finalGroupings = _finalEntries
                .OrderBy(e => _chartDifficulties[e.ChartId])
                .ThenBy(e => e.Order).GroupBy(e => _charts[e.ChartId].ScoringLevel?.ToString("0.0") ?? "Not Enough Data")
                .OrderBy(g => double.TryParse(g.Key,out var d)?d:10000).ToArray();
        }
        foreach (var group in _finalGroupings)
        {
            var clearRate = 0.0;
            if (group.Any(e => (_scores.TryGetValue(e.ChartId,out var s) && !s.IsBroken)))
            {
                clearRate = group.Count(e => _scores.TryGetValue(e.ChartId, out var s) && !s.IsBroken) / (double)group.Count();
            }
            var scoredCharts = group.Where(e => _scores.TryGetValue(e.ChartId, out var score) && score.Score>0).ToArray();
            if (!scoredCharts.Any())
            {
                _clearRate[group.Key] = 0.0;

                continue;
            }
            _clearRate[group.Key] = clearRate;
            _minScores[group.Key]= (PhoenixScore)scoredCharts.Min(e => (int)_scores[e.ChartId].Score!);
            _averageScores[group.Key]= (PhoenixScore)(int)scoredCharts.Average(e => _scores[e.ChartId].Score!);
            _maxScores[group.Key] = (PhoenixScore)scoredCharts.Max(e => (int)_scores[e.ChartId].Score!);

        }
        var charts = _finalEntries.Select(e => _charts[e.ChartId]).ToArray();
        _lowestBpm = charts.Any(c => c.Song.Bpm != null) ? charts.Where(c => c.Song.Bpm != null).Min(c => c.Song.Bpm!.Value.Min) : 0;
        _settings.MinBpm = null;
        _highestBpm = charts.Any(c => c.Song.Bpm != null) ? charts.Where(c => c.Song.Bpm != null).Max(c => c.Song.Bpm!.Value.Max) : 0;
        _settings.MaxBpm = null;
        _lowestNoteCount = charts.Any(c => c.NoteCount != null) ? charts.Where(c => c.NoteCount != null).Min(c => c.NoteCount!.Value) : 0;
        _settings.MinNoteCount = null;
        _highestNoteCount = charts.Any(c => c.NoteCount != null) ? charts.Where(c => c.NoteCount != null).Max(c => c.NoteCount!.Value) : 0;
        _settings.MaxNoteCount = null;
        _availableStepArtists = charts.Select(c => c.StepArtist ?? "Unknown").Distinct().OrderBy(s=>s).ToArray();
        _availableSongArtists = charts.Select(c => c.Song.Artist).Distinct().OrderBy(s=>s).ToArray();


        var baseRating = DifficultyLevel.From(_level).BaseRating;
        if (_chartType == ChartType.CoOp)
        {
            baseRating = 2000;
        }
        _averageRating = _folderScores.Any(kv => !_scores[kv.Key].IsBroken && kv.Value.Score > 0) ? (int)_folderScores.Where(kv => !_scores[kv.Key].IsBroken && kv.Value.Score > 0).Average(s => s.Value.Score!.Value.LetterGrade.GetModifier() * baseRating) : baseRating;
        await CalculateVariance(_chartType, _level);

        var lamps = new List<LampProgress>();
        lamps.Add(new LampProgress("Pass",0,_charts.Count(kv=>_scores.TryGetValue(kv.Key,out var b)&&!b.IsBroken)));
        var order = 1;
        for (var grade = PhoenixLetterGrade.AA; grade <= PhoenixLetterGrade.SSSPlus; grade++)
        {
            lamps.Add(new LampProgress(grade.GetName(), order++,
                _charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s.Score?.LetterGrade >= grade)));
        }
        lamps.Add(new LampProgress("PG", order, _charts.Count(kv => _scores.TryGetValue(kv.Key, out var s) && s.Score == PhoenixScore.Max)));
        _lamps = lamps;
        await SaveSettings();
        _isLoading = false;
    }
    private async Task SetType(ChartType newType)
    {
        _chartType = newType;
        if (_chartType == ChartType.CoOp && _level is < 2 or > 4)
        {
            _level = 2;
        }
        if (_chartType == ChartType.CoOp && _usePersonalizedData)
        {
            _usePersonalizedData = false;
            _modifiers["Skill"] = 0;
            _modifiers["Similar Players"] = 0;
        }
        SetQueryString();
        await Recalculate();
    }

    private async Task SetLevel(int level)
    {
        _level = level;
        if (_tierListType == "Chabala" && !_chabalaLinks.ContainsKey((_chartType,level)))
        {
            _tierListType = "Difficulty";
        }
        if (_groupBy == "Skill" && !_chabalaLinks.ContainsKey((_chartType,level)))
        {
            _groupBy = "Difficulty";
        }
        SetQueryString();
        await Recalculate();
    }

    private IDictionary<(ChartType,DifficultyLevel), string> _chabalaLinks = new Dictionary<(ChartType, DifficultyLevel), string>()
    {
        { (ChartType.Single,19), "https://drive.google.com/file/d/1A5D6tlFVU2HMwzNO34TQLOx1ie78XwTx/view?usp=drive_link" },
        { (ChartType.Single,20), "https://drive.google.com/file/d/1dOxTW1wkdozZMmlOO2yUMy2JggA6Mhej/view?usp=drive_link" },
        { (ChartType.Single,21), "https://drive.google.com/file/d/1oQh8ZlPhpP0F8Mcn2QV8rjpB7GZEebUU/view?usp=drive_link" },
        { (ChartType.Single,22), "https://drive.google.com/file/d/1oZm4kS26TTvdeyVnIwpktldOeQ188lFQ/view?usp=drive_link" },
        { (ChartType.Single,23), "https://drive.google.com/file/d/160VfJaXtXW6OxgD0Y-pN-rnvOWf-of97/view?usp=drive_link" },
        { (ChartType.Single,24), "https://drive.google.com/file/d/1t21N5FfWfPICeT0GopdCNaXjHqzAILUY/view?usp=drive_link" },
        { (ChartType.Single,25), "https://drive.google.com/file/d/13rPx7mrdhg37iNSdmQMc07CsRb7kkgBP/view?usp=drive_link" },
        { (ChartType.Single,26), "https://drive.google.com/file/d/13rPx7mrdhg37iNSdmQMc07CsRb7kkgBP/view?usp=drive_link" },
        { (ChartType.Double,19), "https://drive.google.com/file/d/1uDXcbC7dCmTDh6r3i72AmW7f1qraJgCu/view?usp=drive_link" },
        { (ChartType.Double,20), "https://drive.google.com/file/d/1uDXcbC7dCmTDh6r3i72AmW7f1qraJgCu/view?usp=drive_link" },
        { (ChartType.Double,21), "https://drive.google.com/file/d/1zuguWTvp3NgyyKpTPHwuSTmGtxRmm8rN/view?usp=drive_link" },
        { (ChartType.Double,22), "https://drive.google.com/file/d/1Mj8JCVx3K6xwz_3D9SDjLQyFuCPiVKcG/view?usp=drive_link" },
        { (ChartType.Double,23), "https://drive.google.com/file/d/1m00Ng0-5m4FLrMKlTqiKjWbQiC_Gglhk/view?usp=drive_link" },
        { (ChartType.Double,24), "https://drive.google.com/file/d/1t21N5FfWfPICeT0GopdCNaXjHqzAILUY/view?usp=drive_link" },
        { (ChartType.Double,25), "https://drive.google.com/file/d/13rPx7mrdhg37iNSdmQMc07CsRb7kkgBP/view?usp=drive_link" },
        { (ChartType.Double,26), "https://drive.google.com/file/d/1zCQO8gKKvrZiCw9TfjFy7JTtog_U9uve/view?usp=drive_link" },
        { (ChartType.Double,27), "https://drive.google.com/file/d/1zCQO8gKKvrZiCw9TfjFy7JTtog_U9uve/view?usp=drive_link" },
        { (ChartType.Double,28), "https://drive.google.com/file/d/1zCQO8gKKvrZiCw9TfjFy7JTtog_U9uve/view?usp=drive_link" },
    };
    protected override async Task OnInitializedAsync()
    {
        _filterNames= new Dictionary<Filter, string>()
        {
            { Filter.SongType, L["Song Type"] },
            { Filter.SongName, L["Song Name"] },
            { Filter.ToDo, L["To Do"] },
            { Filter.Completion, L["Stage Pass"] },
            { Filter.LetterGrade, L["Letter Grade"] },
            { Filter.BPM, L["BPM"] },
            { Filter.NoteCount, L["Note Count"] },
            {
                Filter.StepArtist, L["Step Artist"]
            },
            { Filter.SongArtist, L["Song Artist"] }
        };
        if (CurrentUser.IsLoggedIn)
        {
            
            _scores = (await Mediator.Send(new GetPhoenixRecordsQuery(CurrentUser.User.Id)))
                .ToDictionary(c => c.ChartId);
            _ages = _scores.ToDictionary(c => c.Key, c => (int)(_now - c.Value.RecordedDate).TotalDays); 
        }
        var settingsString = await UiSettings.GetSetting(UserSettingsKey);
        if (!string.IsNullOrWhiteSpace(settingsString))
        {
            _settings = JsonSerializer.Deserialize<FilterSettings>(settingsString);
        }
        _charts = (await Mediator.Send(new GetChartsQuery(MixEnum.Phoenix))).
          ToDictionary(c => c.Id);
        _titles = PhoenixTitleList.BuildList();
        _chartType = ChartType.Double;
        _level = 18;
        _tierListTypes=new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "Pass", L["Pass (Data Backed)"] },
            { "Score", L["Score (Data Backed)"] },
            { "Popularity", L["Popularity (PIIU Game Leaderboard)"] },
            {"Chabala","Chabala"},
            {"PG","PG"}
        };

        if (CurrentUser.IsLoggedIn)
        {

            _topCharts = (await Mediator.Send(new GetTop50CompetitiveQuery(CurrentUser.User.Id, ChartType.Double)))
                .Concat(await Mediator.Send(new GetTop50CompetitiveQuery(CurrentUser.User.Id, ChartType.Single)))
                .Select(c => c.ChartId).Distinct().ToHashSet();
            var stats = await Mediator.Send(new GetPlayerStatsQuery(CurrentUser.User.Id));
            if (stats.DoublesCompetitiveLevel > 1)
            {
                
                _level = (int)Math.Round(stats.DoublesCompetitiveLevel);
            }
            if (stats.SinglesCompetitiveLevel > 1 && stats.SinglesCompetitiveLevel > stats.DoublesCompetitiveLevel)
            {
                _chartType = ChartType.Single;
                _level = (int)Math.Round(stats.SinglesCompetitiveLevel);
            }
            _todos = (await Mediator.Send(new GetSavedChartsQuery())).Where(c => c.ListType == ChartListType.ToDo).Select(c => c.ChartId).Distinct().ToHashSet();
        }
        _showAge = bool.TryParse(await UiSettings.GetSetting("TierLists__ShowAge"), out var res) && res;
        _level = int.TryParse(await UiSettings.GetSetting("TierLists__Level"), out var l) ? l : 18;
        _chartType = Enum.TryParse<ChartType>(await UiSettings.GetSetting("TierLists__ChartType"), out var cType) ? cType : ChartType.Double;
        _tierListType = await UiSettings.GetSetting("TierLists__ListType") ?? "Pass";
        _usePersonalizedData = (await UiSettings.GetSetting("TierLists__UsePersonalized") ?? true.ToString()) == true.ToString();
        _groupBy = await UiSettings.GetSetting("TierLists__GroupBy") ?? "Difficulty";
        _textView = (await UiSettings.GetSetting("TierLists__TextView") ?? false.ToString()) == true.ToString();
        if (DifficultyFilter is >= 1 and <= 29)
        {
            _level = DifficultyFilter.Value;
        }
        _titleProgress = (await Mediator.Send(new GetTitleProgressQuery(MixEnum.Phoenix))).ToArray();
        if (Enum.TryParse<ChartType>(ChartTypeFilter, out var chartType))
        {
            _chartType = chartType;
        }
        if (TierListType!=null && _tierListTypes.ContainsKey(TierListType))
        {
            await SetTierListType(TierListType);
        }
        else
        {
            await SetTierListType(_tierListType);
        }
    }

    private IDictionary<string, string> _tierListTypes = new Dictionary<string, string>();
    public static double StdDev(IEnumerable<double> values,
        bool as_sample)
    {
        // Get the mean.
        double mean = values.Sum() / values.Count();

        // Get the sum of the squares of the differences
        // between the values and the mean.
        var squares_query =
            from double value in values
            select (value - mean) * (value - mean);
        double sum_of_squares = squares_query.Sum();

        if (as_sample)
        {
            return Math.Sqrt(sum_of_squares / (values.Count() - 1));
        }
        else
        {
            return Math.Sqrt(sum_of_squares / values.Count());
        }
    }

}
